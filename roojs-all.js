/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 




// for old browsers
window["undefined"] = window["undefined"];

/**
 * @class Roo
 * Roo core utilities and functions.
 * @singleton
 */
var  Roo = {}; 
/**
 * Copies all the properties of config to obj.
 * @param {Object} obj The receiver of the properties
 * @param {Object} config The source of the properties
 * @param {Object} defaults A different object that will also be applied for default values
 * @return {Object} returns obj
 * @member Roo apply
 */

 
Roo.apply = function(o, c, A){
    if(A){
        // no "this" reference for friendly out of scope calls
        Roo.apply(o, A);
    }
    if(o && c && typeof  c == 'object'){
        for(var  p  in  c){
            o[p] = c[p];
        }
    }
    return  o;
};


(function(){
    var  B = 0;
    var  ua = navigator.userAgent.toLowerCase();

    var  C = document.compatMode == "CSS1Compat",
        D = ua.indexOf("opera") > -1,
        E = (/webkit|khtml/).test(ua),
        F = ua.indexOf("msie") > -1,
        G = ua.indexOf("msie 7") > -1,
        H = !E && ua.indexOf("gecko") > -1,
        I = F && !C,
        J = (ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1),
        K = (ua.indexOf("macintosh") != -1 || ua.indexOf("mac os x") != -1),
        L = (ua.indexOf("linux") != -1),
        M = window.location.href.toLowerCase().indexOf("https") === 0;

    // remove css image flicker
	if(F && !G){
        try{
            document.execCommand("BackgroundImageCache", false, true);
        }catch(e){}
    }


    Roo.apply(Roo, {
        /**
         * True if the browser is in strict mode
         * @type Boolean
         */
        isStrict : C,
        /**
         * True if the page is running over SSL
         * @type Boolean
         */
        isSecure : M,
        /**
         * True when the document is fully initialized and ready for action
         * @type Boolean
         */
        isReady : false,

        /**
         * True to automatically uncache orphaned Roo.Elements periodically (defaults to true)
         * @type Boolean
         */
        enableGarbageCollector : true,

        /**
         * True to automatically purge event listeners after uncaching an element (defaults to false).
         * Note: this only happens if enableGarbageCollector is true.
         * @type Boolean
         */
        enableListenerCollection:false,

        /**
         * URL to a blank file used by Roo when in secure mode for iframe src and onReady src to prevent
         * the IE insecure content warning (defaults to javascript:false).
         * @type String
         */
        SSL_SECURE_URL : "javascript:false",

        /**
         * URL to a 1x1 transparent gif image used by Roo to create inline icons with CSS background images. (Defaults to
         * "http://Roojs.com/s.gif" and you should change this to a URL on your server).
         * @type String
         */
        BLANK_IMAGE_URL : "http:/"+"/localhost/s.gif",

        emptyFn : function(){},

        /**
         * Copies all the properties of config to obj if they don't already exist.
         * @param {Object} obj The receiver of the properties
         * @param {Object} config The source of the properties
         * @return {Object} returns obj
         */
        applyIf : function(o, c){
            if(o && c){
                for(var  p  in  c){
                    if(typeof  o[p] == "undefined"){ o[p] = c[p]; }
                }
            }
            return  o;
        },

        /**
         * Applies event listeners to elements by selectors when the document is ready.
         * The event name is specified with an @ suffix.
<pre><code>
Roo.addBehaviors({
   // add a listener for click on all anchors in element with id foo
   '#foo a@click' : function(e, t){
       // do something
   },

   // add the same listener to multiple selectors (separated by comma BEFORE the @)
   '#foo a, #bar span.some-class@mouseover' : function(){
       // do something
   }
});
</code></pre>
         * @param {Object} obj The list of behaviors to apply
         */
        addBehaviors : function(o){
            if(!Roo.isReady){
                Roo.onReady(function(){
                    Roo.addBehaviors(o);
                });
                return;
            }
            var  N = {}; // simple cache for applying multiple behaviors to same selector does query multiple times
            for(var  b  in  o){
                var  parts = b.split('@');
                if(parts[1]){ // for Object prototype breakers
                    var  s = parts[0];
                    if(!N[s]){
                        N[s] = Roo.select(s);
                    }

                    N[s].on(parts[1], o[b]);
                }
            }

            N = null;
        },

        /**
         * Generates unique ids. If the element already has an id, it is unchanged
         * @param {String/HTMLElement/Element} el (optional) The element to generate an id for
         * @param {String} prefix (optional) Id prefix (defaults "Roo-gen")
         * @return {String} The generated Id.
         */
        id : function(el, O){
            O = O || "roo-gen";
            el = Roo.getDom(el);
            var  id = O + (++B);
            return  el ? (el.id ? el.id : (el.id = id)) : id;
        },
         
       
        /**
         * Extends one class with another class and optionally overrides members with the passed literal. This class
         * also adds the function "override()" to the class that can be used to override
         * members on an instance.
         * @param {Object} subclass The class inheriting the functionality
         * @param {Object} superclass The class being extended
         * @param {Object} overrides (optional) A literal with members
         * @method extend
         */
        extend : function(){
            // inline overrides
            var  io = function(o){
                for(var  m  in  o){
                    this[m] = o[m];
                }
            };
            return  function(sb, sp, P){
                if(typeof  sp == 'object'){ // eg. prototype, rather than function constructor..
                    P = sp;
                    sp = sb;
                    sb = function(){sp.apply(this, arguments);};
                }
                var  F = function(){}, sbp, spp = sp.prototype;
                F.prototype = spp;
                sbp = sb.prototype = new  F();
                sbp.constructor=sb;
                sb.superclass=spp;
                
                if(spp.constructor == Object.prototype.constructor){
                    spp.constructor=sp;
                   
                }

                
                sb.override = function(o){
                    Roo.override(sb, o);
                };
                sbp.override = io;
                Roo.override(sb, P);
                return  sb;
            };
        }(),

        /**
         * Adds a list of functions to the prototype of an existing class, overwriting any existing methods with the same name.
         * Usage:<pre><code>
Roo.override(MyClass, {
    newMethod1: function(){
        // etc.
    },
    newMethod2: function(foo){
        // etc.
    }
});
 </code></pre>
         * @param {Object} origclass The class to override
         * @param {Object} overrides The list of functions to add to origClass.  This should be specified as an object literal
         * containing one or more methods.
         * @method override
         */
        override : function(P, Q){
            if(Q){
                var  p = P.prototype;
                for(var  method  in  Q){
                    p[method] = Q[method];
                }
            }
        },
        /**
         * Creates namespaces to be used for scoping variables and classes so that they are not global.  Usage:
         * <pre><code>
Roo.namespace('Company', 'Company.data');
Company.Widget = function() { ... }
Company.data.CustomStore = function(config) { ... }
</code></pre>
         * @param {String} namespace1
         * @param {String} namespace2
         * @param {String} etc
         * @method namespace
         */
        namespace : function(){
            var  a=arguments, o=null, i, j, d, rt;
            for (i=0; i<a.length; ++i) {
                d=a[i].split(".");
                rt = d[0];
                /** eval:var:o */
                eval('if (typeof ' + rt + ' == "undefined"){' + rt + ' = {};} o = ' + rt + ';');
                for (j=1; j<d.length; ++j) {
                    o[d[j]]=o[d[j]] || {};
                    o=o[d[j]];
                }
            }
        },
        /**
         * Creates namespaces to be used for scoping variables and classes so that they are not global.  Usage:
         * <pre><code>
Roo.factory({ xns: Roo.data, xtype : 'Store', .....});
Roo.factory(conf, Roo.data);
</code></pre>
         * @param {String} classname
         * @param {String} namespace (optional)
         * @method factory
         */
         
        factory : function(c, ns)
        {
            // no xtype, no ns or c.xns - or forced off by c.xns
            if (!c.xtype   || (!ns && !c.xns) ||  (c.xns === false)) { // not enough info...
                return  c;
            }

            ns = c.xns ? c.xns : ns; // if c.xns is set, then use that..
            if (c.constructor == ns[c.xtype]) {// already created...
                return  c;
            }
            if (ns[c.xtype]) {
                console.log("Roo.Factory(" + c.xtype + ")");
                var  ret = new  ns[c.xtype](c);
                ret.xns = false;
                return  ret;
            }

            c.xns = false; // prevent recursion..
            return  c;
        },
         
        /**
         * Takes an object and converts it to an encoded URL. e.g. Roo.urlEncode({foo: 1, bar: 2}); would return "foo=1&bar=2".  Optionally, property values can be arrays, instead of keys and the resulting string that's returned will contain a name/value pair for each array value.
         * @param {Object} o
         * @return {String}
         */
        urlEncode : function(o){
            if(!o){
                return  "";
            }
            var  R = [];
            for(var  key  in  o){
                var  ov = o[key], k = encodeURIComponent(key);
                var  type = typeof  ov;
                if(type == 'undefined'){
                    R.push(k, "=&");
                }else  if(type != "function" && type != "object"){
                    R.push(k, "=", encodeURIComponent(ov), "&");
                }else  if(ov  instanceof  Array){
                    if (ov.length) {
	                    for(var  i = 0, len = ov.length; i < len; i++) {
	                        R.push(k, "=", encodeURIComponent(ov[i] === undefined ? '' : ov[i]), "&");
	                    }
	                } else  {
	                    R.push(k, "=&");
	                }
                }
            }

            R.pop();
            return  R.join("");
        },

        /**
         * Takes an encoded URL and and converts it to an object. e.g. Roo.urlDecode("foo=1&bar=2"); would return {foo: 1, bar: 2} or Roo.urlDecode("foo=1&bar=2&bar=3&bar=4", true); would return {foo: 1, bar: [2, 3, 4]}.
         * @param {String} string
         * @param {Boolean} overwrite (optional) Items of the same name will overwrite previous values instead of creating an an array (Defaults to false).
         * @return {Object} A literal with members
         */
        urlDecode : function(S, T){
            if(!S || !S.length){
                return  {};
            }
            var  U = {};
            var  V = S.split('&');
            var  W, X, Y;
            for(var  i = 0, len = V.length; i < len; i++){
                W = V[i].split('=');
                X = decodeURIComponent(W[0]);
                Y = decodeURIComponent(W[1]);
                if(T !== true){
                    if(typeof  U[X] == "undefined"){
                        U[X] = Y;
                    }else  if(typeof  U[X] == "string"){
                        U[X] = [U[X]];
                        U[X].push(Y);
                    }else {
                        U[X].push(Y);
                    }
                }else {
                    U[X] = Y;
                }
            }
            return  U;
        },

        /**
         * Iterates an array calling the passed function with each item, stopping if your function returns false. If the
         * passed array is not really an array, your function is called once with it.
         * The supplied function is called with (Object item, Number index, Array allItems).
         * @param {Array/NodeList/Mixed} array
         * @param {Function} fn
         * @param {Object} scope
         */
        each : function(Z, fn, f){
            if(typeof  Z.length == "undefined" || typeof  Z == "string"){
                Z = [Z];
            }
            for(var  i = 0, len = Z.length; i < len; i++){
                if(fn.call(f || Z[i], Z[i], i, Z) === false){ return  i; };
            }
        },

        // deprecated
        combine : function(){
            var  as = arguments, l = as.length, r = [];
            for(var  i = 0; i < l; i++){
                var  a = as[i];
                if(a  instanceof  Array){
                    r = r.concat(a);
                }else  if(a.length !== undefined && !a.substr){
                    r = r.concat(Array.prototype.slice.call(a, 0));
                }else {
                    r.push(a);
                }
            }
            return  r;
        },

        /**
         * Escapes the passed string for use in a regular expression
         * @param {String} str
         * @return {String}
         */
        escapeRe : function(s) {
            return  s.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
        },

        // internal
        callback : function(cb, g, h, n){
            if(typeof  cb == "function"){
                if(n){
                    cb.defer(n, g, h || []);
                }else {
                    cb.apply(g, h || []);
                }
            }
        },

        /**
         * Return the dom node for the passed string (id), dom node, or Roo.Element
         * @param {String/HTMLElement/Roo.Element} el
         * @return HTMLElement
         */
        getDom : function(el){
            if(!el){
                return  null;
            }
            return  el.dom ? el.dom : (typeof  el == 'string' ? document.getElementById(el) : el);
        },

        /**
        * Shorthand for {@link Roo.ComponentMgr#get}
        * @param {String} id
        * @return Roo.Component
        */
        getCmp : function(id){
            return  Roo.ComponentMgr.get(id);
        },
         
        num : function(v, q){
            if(typeof  v != 'number'){
                return  q;
            }
            return  v;
        },

        destroy : function(){
            for(var  i = 0, a = arguments, len = a.length; i < len; i++) {
                var  as = a[i];
                if(as){
                    if(as.dom){
                        as.removeAllListeners();
                        as.remove();
                        continue;
                    }
                    if(typeof  as.purgeListeners == 'function'){
                        as.purgeListeners();
                    }
                    if(typeof  as.destroy == 'function'){
                        as.destroy();
                    }
                }
            }
        },

        // inpired by a similar function in mootools library
        /**
         * Returns the type of object that is passed in. If the object passed in is null or undefined it
         * return false otherwise it returns one of the following values:<ul>
         * <li><b>string</b>: If the object passed is a string</li>
         * <li><b>number</b>: If the object passed is a number</li>
         * <li><b>boolean</b>: If the object passed is a boolean value</li>
         * <li><b>function</b>: If the object passed is a function reference</li>
         * <li><b>object</b>: If the object passed is an object</li>
         * <li><b>array</b>: If the object passed is an array</li>
         * <li><b>regexp</b>: If the object passed is a regular expression</li>
         * <li><b>element</b>: If the object passed is a DOM Element</li>
         * <li><b>nodelist</b>: If the object passed is a DOM NodeList</li>
         * <li><b>textnode</b>: If the object passed is a DOM text node and contains something other than whitespace</li>
         * <li><b>whitespace</b>: If the object passed is a DOM text node and contains only whitespace</li>
         * @param {Mixed} object
         * @return {String}
         */
        type : function(o){
            if(o === undefined || o === null){
                return  false;
            }
            if(o.htmlElement){
                return  'element';
            }
            var  t = typeof  o;
            if(t == 'object' && o.nodeName) {
                switch(o.nodeType) {
                    case  1: return  'element';
                    case  3: return  (/\S/).test(o.nodeValue) ? 'textnode' : 'whitespace';
                }
            }
            if(t == 'object' || t == 'function') {
                switch(o.constructor) {
                    case  Array: return  'array';
                    case  RegExp: return  'regexp';
                }
                if(typeof  o.length == 'number' && typeof  o.item == 'function') {
                    return  'nodelist';
                }
            }
            return  t;
        },

        /**
         * Returns true if the passed value is null, undefined or an empty string (optional).
         * @param {Mixed} value The value to test
         * @param {Boolean} allowBlank (optional) Pass true if an empty string is not considered empty
         * @return {Boolean}
         */
        isEmpty : function(v, u){
            return  v === null || v === undefined || (!u ? v === '' : false);
        },
        
        /** @type Boolean */
        isOpera : D,
        /** @type Boolean */
        isSafari : E,
        /** @type Boolean */
        isIE : F,
        /** @type Boolean */
        isIE7 : G,
        /** @type Boolean */
        isGecko : H,
        /** @type Boolean */
        isBorderBox : I,
        /** @type Boolean */
        isWindows : J,
        /** @type Boolean */
        isLinux : L,
        /** @type Boolean */
        isMac : K,

        /**
         * By default, Ext intelligently decides whether floating elements should be shimmed. If you are using flash,
         * you may want to set this to true.
         * @type Boolean
         */
        useShims : ((F && !G) || (H && K))
    });


})();

Roo.namespace("Roo", "Roo.util", "Roo.grid", "Roo.dd", "Roo.tree", "Roo.data",
                "Roo.form", "Roo.menu", "Roo.state", "Roo.lib", "Roo.layout", "Roo.app", "Roo.ux");

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

(function() {    
    // wrappedn so fnCleanup is not in global scope...
    if(Roo.isIE) {
        function  A() {
            var  p = Function.prototype;
            delete  p.createSequence;
            delete  p.defer;
            delete  p.createDelegate;
            delete  p.createCallback;
            delete  p.createInterceptor;

            window.detachEvent("onunload", A);
        }

        window.attachEvent("onunload", A);
    }
})();


/**
 * @class Function
 * These functions are available on every Function object (any JavaScript function).
 */
Roo.apply(Function.prototype, {
     /**
     * Creates a callback that passes arguments[0], arguments[1], arguments[2], ...
     * Call directly on any function. Example: <code>myFunction.createCallback(myarg, myarg2)</code>
     * Will create a function that is bound to those 2 args.
     * @return {Function} The new function
    */
    createCallback : function(/*args...*/){
        // make args available, in function below
        var  B = arguments;
        var  C = this;
        return  function() {
            return  C.apply(window, B);
        };
    },

    /**
     * Creates a delegate (callback) that sets the scope to obj.
     * Call directly on any function. Example: <code>this.myFunction.createDelegate(this)</code>
     * Will create a function that is automatically scoped to this.
     * @param {Object} obj (optional) The object for which the scope is set
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     *                                             if a number the args are inserted at the specified position
     * @return {Function} The new function
     */
    createDelegate : function(D, E, F){
        var  G = this;
        return  function() {
            var  H = E || arguments;
            if(F === true){
                H = Array.prototype.slice.call(arguments, 0);
                H = H.concat(E);
            }else  if(typeof  F == "number"){
                H = Array.prototype.slice.call(arguments, 0); // copy arguments first
                var  applyArgs = [F, 0].concat(E); // create method call params
                Array.prototype.splice.apply(H, applyArgs); // splice them in
            }
            return  G.apply(D || window, H);
        };
    },

    /**
     * Calls this function after the number of millseconds specified.
     * @param {Number} millis The number of milliseconds for the setTimeout call (if 0 the function is executed immediately)
     * @param {Object} obj (optional) The object for which the scope is set
     * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
     * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
     *                                             if a number the args are inserted at the specified position
     * @return {Number} The timeout id that can be used with clearTimeout
     */
    defer : function(H, I, J, K){
        var  fn = this.createDelegate(I, J, K);
        if(H){
            return  setTimeout(fn, H);
        }

        fn();
        return  0;
    },
    /**
     * Create a combined function call sequence of the original function + the passed function.
     * The resulting function returns the results of the original function.
     * The passed fcn is called with the parameters of the original function
     * @param {Function} fcn The function to sequence
     * @param {Object} scope (optional) The scope of the passed fcn (Defaults to scope of original function or window)
     * @return {Function} The new function
     */
    createSequence : function(L, M){
        if(typeof  L != "function"){
            return  this;
        }
        var  N = this;
        return  function() {
            var  O = N.apply(this || window, arguments);
            L.apply(M || this || window, arguments);
            return  O;
        };
    },

    /**
     * Creates an interceptor function. The passed fcn is called before the original one. If it returns false, the original one is not called.
     * The resulting function returns the results of the original function.
     * The passed fcn is called with the parameters of the original function.
     * @addon
     * @param {Function} fcn The function to call before the original
     * @param {Object} scope (optional) The scope of the passed fcn (Defaults to scope of original function or window)
     * @return {Function} The new function
     */
    createInterceptor : function(O, P){
        if(typeof  O != "function"){
            return  this;
        }
        var  Q = this;
        return  function() {
            O.target = this;
            O.method = Q;
            if(O.apply(P || this || window, arguments) === false){
                return;
            }
            return  Q.apply(this || window, arguments);
        };
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

Roo.applyIf(String, {
    
    /** @scope String */
    
    /**
     * Escapes the passed string for ' and \
     * @param {String} string The string to escape
     * @return {String} The escaped string
     * @static
     */
    escape : function(A) {
        return  A.replace(/('|\\)/g, "\\$1");
    },

    /**
     * Pads the left side of a string with a specified character.  This is especially useful
     * for normalizing number and date strings.  Example usage:
     * <pre><code>
var s = String.leftPad('123', 5, '0');
// s now contains the string: '00123'
</code></pre>
     * @param {String} string The original string
     * @param {Number} size The total length of the output string
     * @param {String} char (optional) The character with which to pad the original string (defaults to empty string " ")
     * @return {String} The padded string
     * @static
     */
    leftPad : function (B, C, ch) {
        var  D = new  String(B);
        if(ch === null || ch === undefined || ch === '') {
            ch = " ";
        }
        while (D.length < C) {
            D = ch + D;
        }
        return  D;
    },

    /**
     * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
     * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
     * <pre><code>
var cls = 'my-class', text = 'Some text';
var s = String.format('<div class="{0}">{1}</div>', cls, text);
// s now contains the string: '<div class="my-class">Some text</div>'
</code></pre>
     * @param {String} string The tokenized string to be formatted
     * @param {String} value1 The value to replace token {0}
     * @param {String} value2 Etc...
     * @return {String} The formatted string
     * @static
     */
    format : function(E){
        var  F = Array.prototype.slice.call(arguments, 1);
        return  E.replace(/\{(\d+)\}/g, function(m, i){
            return  Roo.util.Format.htmlEncode(F[i]);
        });
    }
});

/**
 * Utility function that allows you to easily switch a string between two alternating values.  The passed value
 * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
 * they are already different, the first value passed in is returned.  Note that this method returns the new value
 * but does not change the current string.
 * <pre><code>
// alternate sort directions
sort = sort.toggle('ASC', 'DESC');

// instead of conditional logic:
sort = (sort == 'ASC' ? 'DESC' : 'ASC');
</code></pre>
 * @param {String} value The value to compare to the current string
 * @param {String} other The new value to use if the string already equals the first value passed in
 * @return {String} The new value
 */
 
String.prototype.toggle = function(G, H){
    return  this == G ? H : G;
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 /**
 * @class Number
 */
Roo.applyIf(Number.prototype, {
    /**
     * Checks whether or not the current number is within a desired range.  If the number is already within the
     * range it is returned, otherwise the min or max value is returned depending on which side of the range is
     * exceeded.  Note that this method returns the constrained value but does not change the current number.
     * @param {Number} min The minimum number in the range
     * @param {Number} max The maximum number in the range
     * @return {Number} The constrained value if outside the range, otherwise the current value
     */
    constrain : function(A, B){
        return  Math.min(Math.max(this, A), B);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 /**
 * @class Array
 */
Roo.applyIf(Array.prototype, {
    /**
     * Checks whether or not the specified object exists in the array.
     * @param {Object} o The object to check for
     * @return {Number} The index of o in the array (or -1 if it is not found)
     */
    indexOf : function(o){
       for (var  i = 0, len = this.length; i < len; i++){
 	      if(this[i] == o) return  i;
       }
 	   return  -1;
    },

    /**
     * Removes the specified object from the array.  If the object is not found nothing happens.
     * @param {Object} o The object to remove
     */
    remove : function(o){
       var  A = this.indexOf(o);
       if(A != -1){
           this.splice(A, 1);
       }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Date
 *
 * The date parsing and format syntax is a subset of
 * <a href="http://www.php.net/date">PHP's date() function</a>, and the formats that are
 * supported will provide results equivalent to their PHP versions.
 *
 * Following is the list of all currently supported formats:
 *<pre>
Sample date:
'Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)'

Format  Output      Description
------  ----------  --------------------------------------------------------------
  d      10         Day of the month, 2 digits with leading zeros
  D      Wed        A textual representation of a day, three letters
  j      10         Day of the month without leading zeros
  l      Wednesday  A full textual representation of the day of the week
  S      th         English ordinal day of month suffix, 2 chars (use with j)
  w      3          Numeric representation of the day of the week
  z      9          The julian date, or day of the year (0-365)
  W      01         ISO-8601 2-digit week number of year, weeks starting on Monday (00-52)
  F      January    A full textual representation of the month
  m      01         Numeric representation of a month, with leading zeros
  M      Jan        Month name abbreviation, three letters
  n      1          Numeric representation of a month, without leading zeros
  t      31         Number of days in the given month
  L      0          Whether it's a leap year (1 if it is a leap year, else 0)
  Y      2007       A full numeric representation of a year, 4 digits
  y      07         A two digit representation of a year
  a      pm         Lowercase Ante meridiem and Post meridiem
  A      PM         Uppercase Ante meridiem and Post meridiem
  g      3          12-hour format of an hour without leading zeros
  G      15         24-hour format of an hour without leading zeros
  h      03         12-hour format of an hour with leading zeros
  H      15         24-hour format of an hour with leading zeros
  i      05         Minutes with leading zeros
  s      01         Seconds, with leading zeros
  O      -0600      Difference to Greenwich time (GMT) in hours
  T      CST        Timezone setting of the machine running the code
  Z      -21600     Timezone offset in seconds (negative if west of UTC, positive if east)
</pre>
 *
 * Example usage (note that you must escape format specifiers with '\\' to render them as character literals):
 * <pre><code>
var dt = new Date('1/10/2007 03:05:01 PM GMT-0600');
document.write(dt.format('Y-m-d'));                         //2007-01-10
document.write(dt.format('F j, Y, g:i a'));                 //January 10, 2007, 3:05 pm
document.write(dt.format('l, \\t\\he dS of F Y h:i:s A'));  //Wednesday, the 10th of January 2007 03:05:01 PM
 </code></pre>
 *
 * Here are some standard date/time patterns that you might find helpful.  They
 * are not part of the source of Date.js, but to use them you can simply copy this
 * block of code into any script that is included after Date.js and they will also become
 * globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
 * <pre><code>
Date.patterns = {
    ISO8601Long:"Y-m-d H:i:s",
    ISO8601Short:"Y-m-d",
    ShortDate: "n/j/Y",
    LongDate: "l, F d, Y",
    FullDateTime: "l, F d, Y g:i:s A",
    MonthDay: "F d",
    ShortTime: "g:i A",
    LongTime: "g:i:s A",
    SortableDateTime: "Y-m-d\\TH:i:s",
    UniversalSortableDateTime: "Y-m-d H:i:sO",
    YearMonth: "F, Y"
};
</code></pre>
 *
 * Example usage:
 * <pre><code>
var dt = new Date();
document.write(dt.format(Date.patterns.ShortDate));
 </code></pre>
 */

/*
 * Most of the date-formatting functions below are the excellent work of Baron Schwartz.
 * They generate precompiled functions from date formats instead of parsing and
 * processing the pattern every time you format a date.  These functions are available
 * on every Date object (any javascript function).
 *
 * The original article and download are here:
 * http://www.xaprb.com/blog/2005/12/12/javascript-closures-for-runtime-efficiency/
 *
 */
 
 
 // was in core
/**
 Returns the number of milliseconds between this date and date
 @param {Date} date (optional) Defaults to now
 @return {Number} The diff in milliseconds
 @member Date getElapsed
 */
Date.prototype.getElapsed = function(A) {
	return  Math.abs((A || new  Date()).getTime()-this.getTime());
};
// was in date file..


// private
Date.parseFunctions = {count:0};
// private
Date.parseRegexes = [];
// private
Date.formatFunctions = {count:0};

// private
Date.prototype.dateFormat = function(B) {
    if (Date.formatFunctions[B] == null) {
        Date.createNewFormat(B);
    }
    var  C = Date.formatFunctions[B];
    return  this[C]();
};


/**
 * Formats a date given the supplied format string
 * @param {String} format The format string
 * @return {String} The formatted date
 * @method
 */
Date.prototype.format = Date.prototype.dateFormat;

// private
Date.createNewFormat = function(D) {
    var  E = "format" + Date.formatFunctions.count++;
    Date.formatFunctions[D] = E;
    var  F = "Date.prototype." + E + " = function(){return ";
    var  G = false;
    var  ch = '';
    for (var  i = 0; i < D.length; ++i) {
        ch = D.charAt(i);
        if (!G && ch == "\\") {
            G = true;
        }
        else  if (G) {
            G = false;
            F += "'" + String.escape(ch) + "' + ";
        }
        else  {
            F += Date.getFormatCode(ch);
        }
    }

    /** eval:var:zzzzzzzzzzzzz */
    eval(F.substring(0, F.length - 3) + ";}");
};

// private
Date.getFormatCode = function(H) {
    switch (H) {
    case  "d":
        return  "String.leftPad(this.getDate(), 2, '0') + ";
    case  "D":
        return  "Date.dayNames[this.getDay()].substring(0, 3) + ";
    case  "j":
        return  "this.getDate() + ";
    case  "l":
        return  "Date.dayNames[this.getDay()] + ";
    case  "S":
        return  "this.getSuffix() + ";
    case  "w":
        return  "this.getDay() + ";
    case  "z":
        return  "this.getDayOfYear() + ";
    case  "W":
        return  "this.getWeekOfYear() + ";
    case  "F":
        return  "Date.monthNames[this.getMonth()] + ";
    case  "m":
        return  "String.leftPad(this.getMonth() + 1, 2, '0') + ";
    case  "M":
        return  "Date.monthNames[this.getMonth()].substring(0, 3) + ";
    case  "n":
        return  "(this.getMonth() + 1) + ";
    case  "t":
        return  "this.getDaysInMonth() + ";
    case  "L":
        return  "(this.isLeapYear() ? 1 : 0) + ";
    case  "Y":
        return  "this.getFullYear() + ";
    case  "y":
        return  "('' + this.getFullYear()).substring(2, 4) + ";
    case  "a":
        return  "(this.getHours() < 12 ? 'am' : 'pm') + ";
    case  "A":
        return  "(this.getHours() < 12 ? 'AM' : 'PM') + ";
    case  "g":
        return  "((this.getHours() % 12) ? this.getHours() % 12 : 12) + ";
    case  "G":
        return  "this.getHours() + ";
    case  "h":
        return  "String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0') + ";
    case  "H":
        return  "String.leftPad(this.getHours(), 2, '0') + ";
    case  "i":
        return  "String.leftPad(this.getMinutes(), 2, '0') + ";
    case  "s":
        return  "String.leftPad(this.getSeconds(), 2, '0') + ";
    case  "O":
        return  "this.getGMTOffset() + ";
    case  "T":
        return  "this.getTimezone() + ";
    case  "Z":
        return  "(this.getTimezoneOffset() * -60) + ";
    default:
        return  "'" + String.escape(H) + "' + ";
    }
};

/**
 * Parses the passed string using the specified format. Note that this function expects dates in normal calendar
 * format, meaning that months are 1-based (1 = January) and not zero-based like in JavaScript dates.  Any part of
 * the date format that is not specified will default to the current date value for that part.  Time parts can also
 * be specified, but default to 0.  Keep in mind that the input date string must precisely match the specified format
 * string or the parse operation will fail.
 * Example Usage:
<pre><code>
//dt = Fri May 25 2007 (current date)
var dt = new Date();

//dt = Thu May 25 2006 (today's month/day in 2006)
dt = Date.parseDate("2006", "Y");

//dt = Sun Jan 15 2006 (all date parts specified)
dt = Date.parseDate("2006-1-15", "Y-m-d");

//dt = Sun Jan 15 2006 15:20:01 GMT-0600 (CST)
dt = Date.parseDate("2006-1-15 3:20:01 PM", "Y-m-d h:i:s A" );
</code></pre>
 * @param {String} input The unparsed date as a string
 * @param {String} format The format the date is in
 * @return {Date} The parsed date
 * @static
 */
Date.parseDate = function(I, J) {
    if (Date.parseFunctions[J] == null) {
        Date.createParser(J);
    }
    var  K = Date.parseFunctions[J];
    return  Date[K](I);
};

// private
Date.createParser = function(L) {
    var  M = "parse" + Date.parseFunctions.count++;
    var  N = Date.parseRegexes.length;
    var  O = 1;
    Date.parseFunctions[L] = M;

    var  P = "Date." + M + " = function(input){\n"
        + "var y = -1, m = -1, d = -1, h = -1, i = -1, s = -1, o, z, v;\n"
        + "var d = new Date();\n"
        + "y = d.getFullYear();\n"
        + "m = d.getMonth();\n"
        + "d = d.getDate();\n"
        + "var results = input.match(Date.parseRegexes[" + N + "]);\n"
        + "if (results && results.length > 0) {";
    var  Q = "";

    var  R = false;
    var  ch = '';
    for (var  i = 0; i < L.length; ++i) {
        ch = L.charAt(i);
        if (!R && ch == "\\") {
            R = true;
        }
        else  if (R) {
            R = false;
            Q += String.escape(ch);
        }
        else  {
            var  obj = Date.formatCodeToRegex(ch, O);
            O += obj.g;
            Q += obj.s;
            if (obj.g && obj.c) {
                P += obj.c;
            }
        }
    }


    P += "if (y >= 0 && m >= 0 && d > 0 && h >= 0 && i >= 0 && s >= 0)\n"
        + "{v = new Date(y, m, d, h, i, s);}\n"
        + "else if (y >= 0 && m >= 0 && d > 0 && h >= 0 && i >= 0)\n"
        + "{v = new Date(y, m, d, h, i);}\n"
        + "else if (y >= 0 && m >= 0 && d > 0 && h >= 0)\n"
        + "{v = new Date(y, m, d, h);}\n"
        + "else if (y >= 0 && m >= 0 && d > 0)\n"
        + "{v = new Date(y, m, d);}\n"
        + "else if (y >= 0 && m >= 0)\n"
        + "{v = new Date(y, m);}\n"
        + "else if (y >= 0)\n"
        + "{v = new Date(y);}\n"
        + "}return (v && (z || o))?\n" // favour UTC offset over GMT offset
        + "    ((z)? v.add(Date.SECOND, (v.getTimezoneOffset() * 60) + (z*1)) :\n" // reset to UTC, then add offset
        + "        v.add(Date.HOUR, (v.getGMTOffset() / 100) + (o / -100))) : v\n" // reset to GMT, then add offset
        + ";}";

    Date.parseRegexes[N] = new  RegExp("^" + Q + "$");
     /** eval:var:zzzzzzzzzzzzz */
    eval(P);
};

// private
Date.formatCodeToRegex = function(S, T) {
    switch (S) {
    case  "D":
        return  {g:0,
        c:null,
        s:"(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)"};
    case  "j":
        return  {g:1,
            c:"d = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{1,2})"}; // day of month without leading zeroes
    case  "d":
        return  {g:1,
            c:"d = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{2})"}; // day of month with leading zeroes
    case  "l":
        return  {g:0,
            c:null,
            s:"(?:" + Date.dayNames.join("|") + ")"};
    case  "S":
        return  {g:0,
            c:null,
            s:"(?:st|nd|rd|th)"};
    case  "w":
        return  {g:0,
            c:null,
            s:"\\d"};
    case  "z":
        return  {g:0,
            c:null,
            s:"(?:\\d{1,3})"};
    case  "W":
        return  {g:0,
            c:null,
            s:"(?:\\d{2})"};
    case  "F":
        return  {g:1,
            c:"m = parseInt(Date.monthNumbers[results[" + T + "].substring(0, 3)], 10);\n",
            s:"(" + Date.monthNames.join("|") + ")"};
    case  "M":
        return  {g:1,
            c:"m = parseInt(Date.monthNumbers[results[" + T + "]], 10);\n",
            s:"(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)"};
    case  "n":
        return  {g:1,
            c:"m = parseInt(results[" + T + "], 10) - 1;\n",
            s:"(\\d{1,2})"}; // Numeric representation of a month, without leading zeros
    case  "m":
        return  {g:1,
            c:"m = parseInt(results[" + T + "], 10) - 1;\n",
            s:"(\\d{2})"}; // Numeric representation of a month, with leading zeros
    case  "t":
        return  {g:0,
            c:null,
            s:"\\d{1,2}"};
    case  "L":
        return  {g:0,
            c:null,
            s:"(?:1|0)"};
    case  "Y":
        return  {g:1,
            c:"y = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{4})"};
    case  "y":
        return  {g:1,
            c:"var ty = parseInt(results[" + T + "], 10);\n"
                + "y = ty > Date.y2kYear ? 1900 + ty : 2000 + ty;\n",
            s:"(\\d{1,2})"};
    case  "a":
        return  {g:1,
            c:"if (results[" + T + "] == 'am') {\n"
                + "if (h == 12) { h = 0; }\n"
                + "} else { if (h < 12) { h += 12; }}",
            s:"(am|pm)"};
    case  "A":
        return  {g:1,
            c:"if (results[" + T + "] == 'AM') {\n"
                + "if (h == 12) { h = 0; }\n"
                + "} else { if (h < 12) { h += 12; }}",
            s:"(AM|PM)"};
    case  "g":
    case  "G":
        return  {g:1,
            c:"h = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{1,2})"}; // 12/24-hr format  format of an hour without leading zeroes
    case  "h":
    case  "H":
        return  {g:1,
            c:"h = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{2})"}; //  12/24-hr format  format of an hour with leading zeroes
    case  "i":
        return  {g:1,
            c:"i = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{2})"};
    case  "s":
        return  {g:1,
            c:"s = parseInt(results[" + T + "], 10);\n",
            s:"(\\d{2})"};
    case  "O":
        return  {g:1,
            c:[
                "o = results[", T, "];\n",
                "var sn = o.substring(0,1);\n", // get + / - sign
                "var hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60);\n", // get hours (performs minutes-to-hour conversion also)
                "var mn = o.substring(3,5) % 60;\n", // get minutes
                "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))?\n", // -12hrs <= GMT offset <= 14hrs
                "    (sn + String.leftPad(hr, 2, 0) + String.leftPad(mn, 2, 0)) : null;\n"
            ].join(""),
            s:"([+\-]\\d{4})"};
    case  "T":
        return  {g:0,
            c:null,
            s:"[A-Z]{1,4}"}; // timezone abbrev. may be between 1 - 4 chars
    case  "Z":
        return  {g:1,
            c:"z = results[" + T + "];\n" // -43200 <= UTC offset <= 50400
                  + "z = (-43200 <= z*1 && z*1 <= 50400)? z : null;\n",
            s:"([+\-]?\\d{1,5})"}; // leading '+' sign is optional for UTC offset
    default:
        return  {g:0,
            c:null,
            s:String.escape(S)};
    }
};

/**
 * Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
 * @return {String} The abbreviated timezone name (e.g. 'CST')
 */
Date.prototype.getTimezone = function() {
    return  this.toString().replace(/^.*? ([A-Z]{1,4})[\-+][0-9]{4} .*$/, "$1");
};

/**
 * Get the offset from GMT of the current date (equivalent to the format specifier 'O').
 * @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600')
 */
Date.prototype.getGMTOffset = function() {
    return  (this.getTimezoneOffset() > 0 ? "-" : "+")
        + String.leftPad(Math.abs(Math.floor(this.getTimezoneOffset() / 60)), 2, "0")
        + String.leftPad(this.getTimezoneOffset() % 60, 2, "0");
};

/**
 * Get the numeric day number of the year, adjusted for leap year.
 * @return {Number} 0 through 364 (365 in leap years)
 */
Date.prototype.getDayOfYear = function() {
    var  U = 0;
    Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
    for (var  i = 0; i < this.getMonth(); ++i) {
        U += Date.daysInMonth[i];
    }
    return  U + this.getDate() - 1;
};

/**
 * Get the string representation of the numeric week number of the year
 * (equivalent to the format specifier 'W').
 * @return {String} '00' through '52'
 */
Date.prototype.getWeekOfYear = function() {
    // Skip to Thursday of this week
    var  V = this.getDayOfYear() + (4 - this.getDay());
    // Find the first Thursday of the year
    var  W = new  Date(this.getFullYear(), 0, 1);
    var  X = (7 - W.getDay() + 4);
    return  String.leftPad(((V - X) / 7) + 1, 2, "0");
};

/**
 * Whether or not the current date is in a leap year.
 * @return {Boolean} True if the current date is in a leap year, else false
 */
Date.prototype.isLeapYear = function() {
    var  Y = this.getFullYear();
    return  ((Y & 3) == 0 && (Y % 100 || (Y % 400 == 0 && Y)));
};

/**
 * Get the first day of the current month, adjusted for leap year.  The returned value
 * is the numeric day index within the week (0-6) which can be used in conjunction with
 * the {@link #monthNames} array to retrieve the textual day name.
 * Example:
 *<pre><code>
var dt = new Date('1/10/2007');
document.write(Date.dayNames[dt.getFirstDayOfMonth()]); //output: 'Monday'
</code></pre>
 * @return {Number} The day number (0-6)
 */
Date.prototype.getFirstDayOfMonth = function() {
    var  Z = (this.getDay() - (this.getDate() - 1)) % 7;
    return  (Z < 0) ? (Z + 7) : Z;
};

/**
 * Get the last day of the current month, adjusted for leap year.  The returned value
 * is the numeric day index within the week (0-6) which can be used in conjunction with
 * the {@link #monthNames} array to retrieve the textual day name.
 * Example:
 *<pre><code>
var dt = new Date('1/10/2007');
document.write(Date.dayNames[dt.getLastDayOfMonth()]); //output: 'Wednesday'
</code></pre>
 * @return {Number} The day number (0-6)
 */
Date.prototype.getLastDayOfMonth = function() {
    var  a = (this.getDay() + (Date.daysInMonth[this.getMonth()] - this.getDate())) % 7;
    return  (a < 0) ? (a + 7) : a;
};


/**
 * Get the first date of this date's month
 * @return {Date}
 */
Date.prototype.getFirstDateOfMonth = function() {
    return  new  Date(this.getFullYear(), this.getMonth(), 1);
};

/**
 * Get the last date of this date's month
 * @return {Date}
 */
Date.prototype.getLastDateOfMonth = function() {
    return  new  Date(this.getFullYear(), this.getMonth(), this.getDaysInMonth());
};
/**
 * Get the number of days in the current month, adjusted for leap year.
 * @return {Number} The number of days in the month
 */
Date.prototype.getDaysInMonth = function() {
    Date.daysInMonth[1] = this.isLeapYear() ? 29 : 28;
    return  Date.daysInMonth[this.getMonth()];
};

/**
 * Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
 * @return {String} 'st, 'nd', 'rd' or 'th'
 */
Date.prototype.getSuffix = function() {
    switch (this.getDate()) {
        case  1:
        case  21:
        case  31:
            return  "st";
        case  2:
        case  22:
            return  "nd";
        case  3:
        case  23:
            return  "rd";
        default:
            return  "th";
    }
};

// private
Date.daysInMonth = [31,28,31,30,31,30,31,31,30,31,30,31];

/**
 * An array of textual month names.
 * Override these values for international dates, for example...
 * Date.monthNames = ['JanInYourLang', 'FebInYourLang', ...];
 * @type Array
 * @static
 */
Date.monthNames =
   ["January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"];

/**
 * An array of textual day names.
 * Override these values for international dates, for example...
 * Date.dayNames = ['SundayInYourLang', 'MondayInYourLang', ...];
 * @type Array
 * @static
 */
Date.dayNames =
   ["Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"];

// private
Date.y2kYear = 50;
// private
Date.monthNumbers = {
    Jan:0,
    Feb:1,
    Mar:2,
    Apr:3,
    May:4,
    Jun:5,
    Jul:6,
    Aug:7,
    Sep:8,
    Oct:9,
    Nov:10,
    Dec:11};

/**
 * Creates and returns a new Date instance with the exact same date value as the called instance.
 * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
 * variable will also be changed.  When the intention is to create a new variable that will not
 * modify the original instance, you should create a clone.
 *
 * Example of correctly cloning a date:
 * <pre><code>
//wrong way:
var orig = new Date('10/1/2006');
var copy = orig;
copy.setDate(5);
document.write(orig);  //returns 'Thu Oct 05 2006'!

//correct way:
var orig = new Date('10/1/2006');
var copy = orig.clone();
copy.setDate(5);
document.write(orig);  //returns 'Thu Oct 01 2006'
</code></pre>
 * @return {Date} The new Date instance
 */
Date.prototype.clone = function() {
	return  new  Date(this.getTime());
};

/**
 * Clears any time information from this date
 @param {Boolean} clone true to create a clone of this date, clear the time and return it
 @return {Date} this or the clone
 */
Date.prototype.clearTime = function(b){
    if(b){
        return  this.clone().clearTime();
    }

    this.setHours(0);
    this.setMinutes(0);
    this.setSeconds(0);
    this.setMilliseconds(0);
    return  this;
};

// private
// safari setMonth is broken
if(Roo.isSafari){
    Date.brokenSetMonth = Date.prototype.setMonth;
	Date.prototype.setMonth = function(c){
		if(c <= -1){
			var  n = Math.ceil(-c);
			var  back_year = Math.ceil(n/12);
			var  month = (n % 12) ? 12 - n % 12 : 0 ;
			this.setFullYear(this.getFullYear() - back_year);
			return  Date.brokenSetMonth.call(this, month);
		} else  {
			return  Date.brokenSetMonth.apply(this, arguments);
		}
	};
}


/** Date interval constant 
* @static 
* @type String */
Date.MILLI = "ms";
/** Date interval constant 
* @static 
* @type String */
Date.SECOND = "s";
/** Date interval constant 
* @static 
* @type String */
Date.MINUTE = "mi";
/** Date interval constant 
* @static 
* @type String */
Date.HOUR = "h";
/** Date interval constant 
* @static 
* @type String */
Date.DAY = "d";
/** Date interval constant 
* @static 
* @type String */
Date.MONTH = "mo";
/** Date interval constant 
* @static 
* @type String */
Date.YEAR = "y";

/**
 * Provides a convenient method of performing basic date arithmetic.  This method
 * does not modify the Date instance being called - it creates and returns
 * a new Date instance containing the resulting date value.
 *
 * Examples:
 * <pre><code>
//Basic usage:
var dt = new Date('10/29/2006').add(Date.DAY, 5);
document.write(dt); //returns 'Fri Oct 06 2006 00:00:00'

//Negative values will subtract correctly:
var dt2 = new Date('10/1/2006').add(Date.DAY, -5);
document.write(dt2); //returns 'Tue Sep 26 2006 00:00:00'

//You can even chain several calls together in one line!
var dt3 = new Date('10/1/2006').add(Date.DAY, 5).add(Date.HOUR, 8).add(Date.MINUTE, -30);
document.write(dt3); //returns 'Fri Oct 06 2006 07:30:00'
 </code></pre>
 *
 * @param {String} interval   A valid date interval enum value
 * @param {Number} value      The amount to add to the current date
 * @return {Date} The new Date instance
 */
Date.prototype.add = function(e, f){
  var  d = this.clone();
  if (!e || f === 0) return  d;
  switch(e.toLowerCase()){
    case  Date.MILLI:
      d.setMilliseconds(this.getMilliseconds() + f);
      break;
    case  Date.SECOND:
      d.setSeconds(this.getSeconds() + f);
      break;
    case  Date.MINUTE:
      d.setMinutes(this.getMinutes() + f);
      break;
    case  Date.HOUR:
      d.setHours(this.getHours() + f);
      break;
    case  Date.DAY:
      d.setDate(this.getDate() + f);
      break;
    case  Date.MONTH:
      var  a = this.getDate();
      if(a > 28){
          a = Math.min(a, this.getFirstDateOfMonth().add('mo', f).getLastDateOfMonth().getDate());
      }

      d.setDate(a);
      d.setMonth(this.getMonth() + f);
      break;
    case  Date.YEAR:
      d.setFullYear(this.getFullYear() + f);
      break;
  }
  return  d;
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

Roo.lib.Dom = {
    getViewWidth : function(A) {
        return  A ? this.getDocumentWidth() : this.getViewportWidth();
    },

    getViewHeight : function(B) {
        return  B ? this.getDocumentHeight() : this.getViewportHeight();
    },

    getDocumentHeight: function() {
        var  C = (document.compatMode != "CSS1Compat") ? document.body.scrollHeight : document.documentElement.scrollHeight;
        return  Math.max(C, this.getViewportHeight());
    },

    getDocumentWidth: function() {
        var  D = (document.compatMode != "CSS1Compat") ? document.body.scrollWidth : document.documentElement.scrollWidth;
        return  Math.max(D, this.getViewportWidth());
    },

    getViewportHeight: function() {
        var  E = self.innerHeight;
        var  F = document.compatMode;

        if ((F || Roo.isIE) && !Roo.isOpera) {
            E = (F == "CSS1Compat") ?
                     document.documentElement.clientHeight :
                     document.body.clientHeight;
        }

        return  E;
    },

    getViewportWidth: function() {
        var  G = self.innerWidth;
        var  H = document.compatMode;

        if (H || Roo.isIE) {
            G = (H == "CSS1Compat") ?
                    document.documentElement.clientWidth :
                    document.body.clientWidth;
        }
        return  G;
    },

    isAncestor : function(p, c) {
        p = Roo.getDom(p);
        c = Roo.getDom(c);
        if (!p || !c) {
            return  false;
        }

        if (p.contains && !Roo.isSafari) {
            return  p.contains(c);
        } else  if (p.compareDocumentPosition) {
            return  !!(p.compareDocumentPosition(c) & 16);
        } else  {
            var  parent = c.parentNode;
            while (parent) {
                if (parent == p) {
                    return  true;
                }
                else  if (!parent.tagName || parent.tagName.toUpperCase() == "HTML") {
                    return  false;
                }

                parent = parent.parentNode;
            }
            return  false;
        }
    },

    getRegion : function(el) {
        return  Roo.lib.Region.getRegion(el);
    },

    getY : function(el) {
        return  this.getXY(el)[1];
    },

    getX : function(el) {
        return  this.getXY(el)[0];
    },

    getXY : function(el) {
        var  p, pe, b, I, bd = document.body;
        el = Roo.getDom(el);
        var  J = Roo.lib.AnimBase.fly;
        if (el.getBoundingClientRect) {
            b = el.getBoundingClientRect();
            I = J(document).getScroll();
            return  [b.left + I.left, b.top + I.top];
        }
        var  x = 0, y = 0;

        p = el;

        var  K = J(el).getStyle("position") == "absolute";

        while (p) {

            x += p.offsetLeft;
            y += p.offsetTop;

            if (!K && J(p).getStyle("position") == "absolute") {
                K = true;
            }

            if (Roo.isGecko) {
                pe = J(p);

                var  bt = parseInt(pe.getStyle("borderTopWidth"), 10) || 0;
                var  bl = parseInt(pe.getStyle("borderLeftWidth"), 10) || 0;


                x += bl;
                y += bt;


                if (p != el && pe.getStyle('overflow') != 'visible') {
                    x += bl;
                    y += bt;
                }
            }

            p = p.offsetParent;
        }

        if (Roo.isSafari && K) {
            x -= bd.offsetLeft;
            y -= bd.offsetTop;
        }

        if (Roo.isGecko && !K) {
            var  dbd = J(bd);
            x += parseInt(dbd.getStyle("borderLeftWidth"), 10) || 0;
            y += parseInt(dbd.getStyle("borderTopWidth"), 10) || 0;
        }


        p = el.parentNode;
        while (p && p != bd) {
            if (!Roo.isOpera || (p.tagName != 'TR' && J(p).getStyle("display") != "inline")) {
                x -= p.scrollLeft;
                y -= p.scrollTop;
            }

            p = p.parentNode;
        }
        return  [x, y];
    },
 
  


    setXY : function(el, xy) {
        el = Roo.fly(el, '_setXY');
        el.position();
        var  L = el.translatePoints(xy);
        if (xy[0] !== false) {
            el.dom.style.left = L.left + "px";
        }
        if (xy[1] !== false) {
            el.dom.style.top = L.top + "px";
        }
    },

    setX : function(el, x) {
        this.setXY(el, [x, false]);
    },

    setY : function(el, y) {
        this.setXY(el, [false, y]);
    }
};

/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */

Roo.lib.Event = function() {
    var  A = false;
    var  B = [];
    var  C = [];
    var  D = 0;
    var  E = [];
    var  F = 0;
    var  G = null;

    return  {
        POLL_RETRYS: 200,
        POLL_INTERVAL: 20,
        EL: 0,
        TYPE: 1,
        FN: 2,
        WFN: 3,
        OBJ: 3,
        ADJ_SCOPE: 4,
        _interval: null,

        startInterval: function() {
            if (!this._interval) {
                var  self = this;
                var  callback = function() {
                    self._tryPreloadAttach();
                };
                this._interval = setInterval(callback, this.POLL_INTERVAL);

            }
        },

        onAvailable: function(h, k, m, n) {
            E.push({ id:         h,
                fn:         k,
                obj:        m,
                override:   n,
                checkReady: false    });

            D = this.POLL_RETRYS;
            this.startInterval();
        },


        addListener: function(el, o, fn) {
            el = Roo.getDom(el);
            if (!el || !fn) {
                return  false;
            }

            if ("unload" == o) {
                C[C.length] =
                [el, o, fn];
                return  true;
            }

            var  p = function(e) {
                return  fn(Roo.lib.Event.getEvent(e));
            };

            var  li = [el, o, fn, p];

            var  q = B.length;
            B[q] = li;

            this.doAdd(el, o, p, false);
            return  true;

        },


        removeListener: function(el, r, fn) {
            var  i, s;

            el = Roo.getDom(el);

            if(!fn) {
                return  this.purgeElement(el, false, r);
            }


            if ("unload" == r) {

                for (i = 0,s = C.length; i < s; i++) {
                    var  li = C[i];
                    if (li &&
                        li[0] == el &&
                        li[1] == r &&
                        li[2] == fn) {
                        C.splice(i, 1);
                        return  true;
                    }
                }

                return  false;
            }

            var  u = null;


            var  v = arguments[3];

            if ("undefined" == typeof  v) {
                v = this._getCacheIndex(el, r, fn);
            }

            if (v >= 0) {
                u = B[v];
            }

            if (!el || !u) {
                return  false;
            }


            this.doRemove(el, r, u[this.WFN], false);

            delete  B[v][this.WFN];
            delete  B[v][this.FN];
            B.splice(v, 1);

            return  true;

        },


        getTarget: function(ev, w) {
            ev = ev.browserEvent || ev;
            var  t = ev.target || ev.srcElement;
            return  this.resolveTextNode(t);
        },


        resolveTextNode: function(z) {
            if (Roo.isSafari && z && 3 == z.nodeType) {
                return  z.parentNode;
            } else  {
                return  z;
            }
        },


        getPageX: function(ev) {
            ev = ev.browserEvent || ev;
            var  x = ev.pageX;
            if (!x && 0 !== x) {
                x = ev.clientX || 0;

                if (Roo.isIE) {
                    x += this.getScroll()[1];
                }
            }

            return  x;
        },


        getPageY: function(ev) {
            ev = ev.browserEvent || ev;
            var  y = ev.pageY;
            if (!y && 0 !== y) {
                y = ev.clientY || 0;

                if (Roo.isIE) {
                    y += this.getScroll()[0];
                }
            }


            return  y;
        },


        getXY: function(ev) {
            ev = ev.browserEvent || ev;
            return  [this.getPageX(ev), this.getPageY(ev)];
        },


        getRelatedTarget: function(ev) {
            ev = ev.browserEvent || ev;
            var  t = ev.relatedTarget;
            if (!t) {
                if (ev.type == "mouseout") {
                    t = ev.toElement;
                } else  if (ev.type == "mouseover") {
                    t = ev.fromElement;
                }
            }

            return  this.resolveTextNode(t);
        },


        getTime: function(ev) {
            ev = ev.browserEvent || ev;
            if (!ev.time) {
                var  t = new  Date().getTime();
                try {
                    ev.time = t;
                } catch(ex) {
                    this.lastError = ex;
                    return  t;
                }
            }

            return  ev.time;
        },


        stopEvent: function(ev) {
            this.stopPropagation(ev);
            this.preventDefault(ev);
        },


        stopPropagation: function(ev) {
            ev = ev.browserEvent || ev;
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else  {
                ev.cancelBubble = true;
            }
        },


        preventDefault: function(ev) {
            ev = ev.browserEvent || ev;
            if(ev.preventDefault) {
                ev.preventDefault();
            } else  {
                ev.returnValue = false;
            }
        },


        getEvent: function(e) {
            var  ev = e || window.event;
            if (!ev) {
                var  c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev && Event == ev.constructor) {
                        break;
                    }

                    c = c.caller;
                }
            }
            return  ev;
        },


        getCharCode: function(ev) {
            ev = ev.browserEvent || ev;
            return  ev.charCode || ev.keyCode || 0;
        },


        _getCacheIndex: function(el, AA, fn) {
            for (var  i = 0,s = B.length; i < s; ++i) {
                var  li = B[i];
                if (li &&
                    li[this.FN] == fn &&
                    li[this.EL] == el &&
                    li[this.TYPE] == AA) {
                    return  i;
                }
            }

            return  -1;
        },


        elCache: {},


        getEl: function(id) {
            return  document.getElementById(id);
        },


        clearCache: function() {
        },


        _load: function(e) {
            A = true;
            var  EU = Roo.lib.Event;


            if (Roo.isIE) {
                EU.doRemove(window, "load", EU._load);
            }
        },


        _tryPreloadAttach: function() {

            if (this.locked) {
                return  false;
            }


            this.locked = true;


            var  AB = !A;
            if (!AB) {
                AB = (D > 0);
            }


            var  AC = [];
            for (var  i = 0,s = E.length; i < s; ++i) {
                var  item = E[i];
                if (item) {
                    var  el = this.getEl(item.id);

                    if (el) {
                        if (!item.checkReady ||
                            A ||
                            el.nextSibling ||
                            (document && document.body)) {

                            var  scope = el;
                            if (item.override) {
                                if (item.override === true) {
                                    scope = item.obj;
                                } else  {
                                    scope = item.override;
                                }
                            }

                            item.fn.call(scope, item.obj);
                            E[i] = null;
                        }
                    } else  {
                        AC.push(item);
                    }
                }
            }


            D = (AC.length === 0) ? 0 : D - 1;

            if (AB) {

                this.startInterval();
            } else  {
                clearInterval(this._interval);
                this._interval = null;
            }


            this.locked = false;

            return  true;

        },


        purgeElement: function(el, AD, AE) {
            var  AF = this.getListeners(el, AE);
            if (AF) {
                for (var  i = 0,s = AF.length; i < s; ++i) {
                    var  l = AF[i];
                    this.removeListener(el, l.type, l.fn);
                }
            }

            if (AD && el && el.childNodes) {
                for (i = 0,s = el.childNodes.length; i < s; ++i) {
                    this.purgeElement(el.childNodes[i], AD, AE);
                }
            }
        },


        getListeners: function(el, AG) {
            var  AH = [], AI;
            if (!AG) {
                AI = [B, C];
            } else  if (AG == "unload") {
                AI = [C];
            } else  {
                AI = [B];
            }

            for (var  j = 0; j < AI.length; ++j) {
                var  searchList = AI[j];
                if (searchList && searchList.length > 0) {
                    for (var  i = 0,s = searchList.length; i < s; ++i) {
                        var  l = searchList[i];
                        if (l && l[this.EL] === el &&
                            (!AG || AG === l[this.TYPE])) {
                            AH.push({
                                type:   l[this.TYPE],
                                fn:     l[this.FN],
                                obj:    l[this.OBJ],
                                adjust: l[this.ADJ_SCOPE],
                                index:  i
                            });
                        }
                    }
                }
            }

            return  (AH.length) ? AH : null;
        },


        _unload: function(e) {

            var  EU = Roo.lib.Event, i, j, l, AJ, AK;

            for (i = 0,AJ = C.length; i < AJ; ++i) {
                l = C[i];
                if (l) {
                    var  scope = window;
                    if (l[EU.ADJ_SCOPE]) {
                        if (l[EU.ADJ_SCOPE] === true) {
                            scope = l[EU.OBJ];
                        } else  {
                            scope = l[EU.ADJ_SCOPE];
                        }
                    }

                    l[EU.FN].call(scope, EU.getEvent(e), l[EU.OBJ]);
                    C[i] = null;
                    l = null;
                    scope = null;
                }
            }


            C = null;

            if (B && B.length > 0) {
                j = B.length;
                while (j) {
                    AK = j - 1;
                    l = B[AK];
                    if (l) {
                        EU.removeListener(l[EU.EL], l[EU.TYPE],
                                l[EU.FN], AK);
                    }

                    j = j - 1;
                }

                l = null;

                EU.clearCache();
            }


            EU.doRemove(window, "unload", EU._unload);

        },


        getScroll: function() {
            var  dd = document.documentElement, db = document.body;
            if (dd && (dd.scrollTop || dd.scrollLeft)) {
                return  [dd.scrollTop, dd.scrollLeft];
            } else  if (db) {
                return  [db.scrollTop, db.scrollLeft];
            } else  {
                return  [0, 0];
            }
        },


        doAdd: function () {
            if (window.addEventListener) {
                return  function(el, AL, fn, AM) {
                    el.addEventListener(AL, fn, (AM));
                };
            } else  if (window.attachEvent) {
                return  function(el, AL, fn, AM) {
                    el.attachEvent("on" + AL, fn);
                };
            } else  {
                return  function() {
                };
            }
        }(),


        doRemove: function() {
            if (window.removeEventListener) {
                return  function (el, AL, fn, AM) {
                    el.removeEventListener(AL, fn, (AM));
                };
            } else  if (window.detachEvent) {
                return  function (el, AL, fn) {
                    el.detachEvent("on" + AL, fn);
                };
            } else  {
                return  function() {
                };
            }
        }()
    };
    
}();
(function() {     
   
    var  E = Roo.lib.Event;
    E.on = E.addListener;
    E.un = E.removeListener;

    if (document && document.body) {
        E._load();
    } else  {
        E.doAdd(window, "load", E._load);
    }

    E.doAdd(window, "unload", E._unload);
    E._tryPreloadAttach();
})();


/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */

(function() {
    
    Roo.lib.Ajax = {
        request : function(A, B, cb, C, D) {
            if(D){
                var  hs = D.headers;
                if(hs){
                    for(var  h  in  hs){
                        if(hs.hasOwnProperty(h)){
                            this.initHeader(h, hs[h], false);
                        }
                    }
                }
                if(D.xmlData){
                    this.initHeader('Content-Type', 'text/xml', false);
                    A = 'POST';
                    C = D.xmlData;
                }
            }

            return  this.asyncRequest(A, B, cb, C);
        },

        serializeForm : function(E) {
            if(typeof  E == 'string') {
                E = (document.getElementById(E) || document.forms[E]);
            }

            var  el, F, G, H, I = '', J = false;
            for (var  i = 0; i < E.elements.length; i++) {
                el = E.elements[i];
                H = E.elements[i].disabled;
                F = E.elements[i].name;
                G = E.elements[i].value;

                if (!H && F){
                    switch (el.type)
                            {
                        case  'select-one':
                        case  'select-multiple':
                            for (var  j = 0; j < el.options.length; j++) {
                                if (el.options[j].selected) {
                                    if (Roo.isIE) {
                                        I += encodeURIComponent(F) + '=' + encodeURIComponent(el.options[j].attributes['value'].specified ? el.options[j].value : el.options[j].text) + '&';
                                    }
                                    else  {
                                        I += encodeURIComponent(F) + '=' + encodeURIComponent(el.options[j].hasAttribute('value') ? el.options[j].value : el.options[j].text) + '&';
                                    }
                                }
                            }
                            break;
                        case  'radio':
                        case  'checkbox':
                            if (el.checked) {
                                I += encodeURIComponent(F) + '=' + encodeURIComponent(G) + '&';
                            }
                            break;
                        case  'file':

                        case  undefined:

                        case  'reset':

                        case  'button':

                            break;
                        case  'submit':
                            if(J == false) {
                                I += encodeURIComponent(F) + '=' + encodeURIComponent(G) + '&';
                                J = true;
                            }
                            break;
                        default:
                            I += encodeURIComponent(F) + '=' + encodeURIComponent(G) + '&';
                            break;
                    }
                }
            }

            I = I.substr(0, I.length - 1);
            return  I;
        },

        headers:{},

        hasHeaders:false,

        useDefaultHeader:true,

        defaultPostHeader:'application/x-www-form-urlencoded',

        useDefaultXhrHeader:true,

        defaultXhrHeader:'XMLHttpRequest',

        hasDefaultHeaders:true,

        defaultHeaders:{},

        poll:{},

        timeout:{},

        pollInterval:50,

        transactionId:0,

        setProgId:function(id)
        {
            this.activeX.unshift(id);
        },

        setDefaultPostHeader:function(b)
        {
            this.useDefaultHeader = b;
        },

        setDefaultXhrHeader:function(b)
        {
            this.useDefaultXhrHeader = b;
        },

        setPollingInterval:function(i)
        {
            if (typeof  i == 'number' && isFinite(i)) {
                this.pollInterval = i;
            }
        },

        createXhrObject:function(K)
        {
            var  L,M;
            try
            {

                M = new  XMLHttpRequest();

                L = { conn:M, tId:K };
            }
            catch(e)
            {
                for (var  i = 0; i < this.activeX.length; ++i) {
                    try
                    {

                        http = new  ActiveXObject(this.activeX[i]);

                        obj = { conn:http, tId:transactionId };
                        break;
                    }
                    catch(e) {
                    }
                }
            }
            finally
            {
                return  L;
            }
        },

        getConnectionObject:function()
        {
            var  o;
            var  N = this.transactionId;

            try
            {
                o = this.createXhrObject(N);
                if (o) {
                    this.transactionId++;
                }
            }
            catch(e) {
            }
            finally
            {
                return  o;
            }
        },

        asyncRequest:function(O, P, Q, R)
        {
            var  o = this.getConnectionObject();

            if (!o) {
                return  null;
            }
            else  {
                o.conn.open(O, P, true);

                if (this.useDefaultXhrHeader) {
                    if (!this.defaultHeaders['X-Requested-With']) {
                        this.initHeader('X-Requested-With', this.defaultXhrHeader, true);
                    }
                }

                if(R && this.useDefaultHeader){
                    this.initHeader('Content-Type', this.defaultPostHeader);
                }

                 if (this.hasDefaultHeaders || this.hasHeaders) {
                    this.setHeader(o);
                }


                this.handleReadyState(o, Q);
                o.conn.send(R || null);

                return  o;
            }
        },

        handleReadyState:function(o, S)
        {
            var  T = this;

            if (S && S.timeout) {
                this.timeout[o.tId] = window.setTimeout(function() {
                    T.abort(o, S, true);
                }, S.timeout);
            }


            this.poll[o.tId] = window.setInterval(
                    function() {
                        if (o.conn && o.conn.readyState == 4) {
                            window.clearInterval(T.poll[o.tId]);
                            delete  T.poll[o.tId];

                            if(S && S.timeout) {
                                window.clearTimeout(T.timeout[o.tId]);
                                delete  T.timeout[o.tId];
                            }


                            T.handleTransactionResponse(o, S);
                        }
                    }
                    , this.pollInterval);
        },

        handleTransactionResponse:function(o, U, V)
        {

            if (!U) {
                this.releaseObject(o);
                return;
            }

            var  W, X;

            try
            {
                if (o.conn.status !== undefined && o.conn.status != 0) {
                    W = o.conn.status;
                }
                else  {
                    W = 13030;
                }
            }
            catch(e) {


                httpStatus = 13030;
            }

            if (W >= 200 && W < 300) {
                X = this.createResponseObject(o, U.argument);
                if (U.success) {
                    if (!U.scope) {
                        U.success(X);
                    }
                    else  {


                        U.success.apply(U.scope, [X]);
                    }
                }
            }
            else  {
                switch (W) {

                    case  12002:
                    case  12029:
                    case  12030:
                    case  12031:
                    case  12152:
                    case  13030:
                        X = this.createExceptionObject(o.tId, U.argument, (V ? V : false));
                        if (U.failure) {
                            if (!U.scope) {
                                U.failure(X);
                            }
                            else  {
                                U.failure.apply(U.scope, [X]);
                            }
                        }
                        break;
                    default:
                        X = this.createResponseObject(o, U.argument);
                        if (U.failure) {
                            if (!U.scope) {
                                U.failure(X);
                            }
                            else  {
                                U.failure.apply(U.scope, [X]);
                            }
                        }
                }
            }


            this.releaseObject(o);
            X = null;
        },

        createResponseObject:function(o, Y)
        {
            var  Z = {};
            var  a = {};

            try
            {
                var  headerStr = o.conn.getAllResponseHeaders();
                var  header = headerStr.split('\n');
                for (var  i = 0; i < header.length; i++) {
                    var  delimitPos = header[i].indexOf(':');
                    if (delimitPos != -1) {
                        a[header[i].substring(0, delimitPos)] = header[i].substring(delimitPos + 2);
                    }
                }
            }
            catch(e) {
            }


            Z.tId = o.tId;
            Z.status = o.conn.status;
            Z.statusText = o.conn.statusText;
            Z.getResponseHeader = a;
            Z.getAllResponseHeaders = headerStr;
            Z.responseText = o.conn.responseText;
            Z.responseXML = o.conn.responseXML;

            if (typeof  Y !== undefined) {
                Z.argument = Y;
            }

            return  Z;
        },

        createExceptionObject:function(c, d, f)
        {
            var  g = 0;
            var  k = 'communication failure';
            var  l = -1;
            var  m = 'transaction aborted';

            var  n = {};

            n.tId = c;
            if (f) {
                n.status = l;
                n.statusText = m;
            }
            else  {
                n.status = g;
                n.statusText = k;
            }

            if (d) {
                n.argument = d;
            }

            return  n;
        },

        initHeader:function(p, q, r)
        {
            var  s = (r) ? this.defaultHeaders : this.headers;

            if (s[p] === undefined) {
                s[p] = q;
            }
            else  {


                s[p] = q + "," + s[p];
            }

            if (r) {
                this.hasDefaultHeaders = true;
            }
            else  {
                this.hasHeaders = true;
            }
        },


        setHeader:function(o)
        {
            if (this.hasDefaultHeaders) {
                for (var  prop  in  this.defaultHeaders) {
                    if (this.defaultHeaders.hasOwnProperty(prop)) {
                        o.conn.setRequestHeader(prop, this.defaultHeaders[prop]);
                    }
                }
            }

            if (this.hasHeaders) {
                for (var  prop  in  this.headers) {
                    if (this.headers.hasOwnProperty(prop)) {
                        o.conn.setRequestHeader(prop, this.headers[prop]);
                    }
                }

                this.headers = {};
                this.hasHeaders = false;
            }
        },

        resetDefaultHeaders:function() {
            delete  this.defaultHeaders;
            this.defaultHeaders = {};
            this.hasDefaultHeaders = false;
        },

        abort:function(o, t, u)
        {
            if(this.isCallInProgress(o)) {
                o.conn.abort();
                window.clearInterval(this.poll[o.tId]);
                delete  this.poll[o.tId];
                if (u) {
                    delete  this.timeout[o.tId];
                }


                this.handleTransactionResponse(o, t, true);

                return  true;
            }
            else  {
                return  false;
            }
        },


        isCallInProgress:function(o)
        {
            if (o && o.conn) {
                return  o.conn.readyState != 4 && o.conn.readyState != 0;
            }
            else  {

                return  false;
            }
        },


        releaseObject:function(o)
        {

            o.conn = null;

            o = null;
        },

        activeX:[
        'MSXML2.XMLHTTP.3.0',
        'MSXML2.XMLHTTP',
        'Microsoft.XMLHTTP'
        ]


    };
})();
/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */

Roo.lib.Region = function(t, r, b, l) {
    this.top = t;
    this[1] = t;
    this.right = r;
    this.bottom = b;
    this.left = l;
    this[0] = l;
};


Roo.lib.Region.prototype = {
    contains : function(A) {
        return  ( A.left >= this.left &&
                 A.right <= this.right &&
                 A.top >= this.top &&
                 A.bottom <= this.bottom    );

    },

    getArea : function() {
        return  ( (this.bottom - this.top) * (this.right - this.left) );
    },

    intersect : function(B) {
        var  t = Math.max(this.top, B.top);
        var  r = Math.min(this.right, B.right);
        var  b = Math.min(this.bottom, B.bottom);
        var  l = Math.max(this.left, B.left);

        if (b >= t && r >= l) {
            return  new  Roo.lib.Region(t, r, b, l);
        } else  {
            return  null;
        }
    },
    union : function(C) {
        var  t = Math.min(this.top, C.top);
        var  r = Math.max(this.right, C.right);
        var  b = Math.max(this.bottom, C.bottom);
        var  l = Math.min(this.left, C.left);

        return  new  Roo.lib.Region(t, r, b, l);
    },

    adjust : function(t, l, b, r) {
        this.top += t;
        this.left += l;
        this.right += r;
        this.bottom += b;
        return  this;
    }
};

Roo.lib.Region.getRegion = function(el) {
    var  p = Roo.lib.Dom.getXY(el);

    var  t = p[1];
    var  r = p[0] + el.offsetWidth;
    var  b = p[1] + el.offsetHeight;
    var  l = p[0];

    return  new  Roo.lib.Region(t, r, b, l);
};

/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
//@@dep Roo.lib.Region


Roo.lib.Point = function(x, y) {
    if (x  instanceof  Array) {
        y = x[1];
        x = x[0];
    }

    this.x = this.right = this.left = this[0] = x;
    this.y = this.top = this.bottom = this[1] = y;
};

Roo.lib.Point.prototype = new  Roo.lib.Region();

/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
 
(function() {   

    Roo.lib.Anim = {
        scroll : function(el, A, B, C, cb, D) {
            this.run(el, A, B, C, cb, D, Roo.lib.Scroll);
        },

        motion : function(el, E, F, G, cb, H) {
            this.run(el, E, F, G, cb, H, Roo.lib.Motion);
        },

        color : function(el, I, J, K, cb, L) {
            this.run(el, I, J, K, cb, L, Roo.lib.ColorAnim);
        },

        run : function(el, M, N, O, cb, P, Q) {
            Q = Q || Roo.lib.AnimBase;
            if (typeof  O == "string") {
                O = Roo.lib.Easing[O];
            }
            var  R = new  Q(el, M, N, O);
            R.animateX(function() {
                Roo.callback(cb, P);
            });
            return  R;
        }
    };
})();
/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */

(function() {    
    var  A;
    
    function  B(el) {
        if (!A) {
            A = new  Roo.Element.Flyweight();
        }

        A.dom = el;
        return  A;
    }


    // since this uses fly! - it cant be in DOM (which does not have fly yet..)
    
   
    
    Roo.lib.AnimBase = function(el, C, D, E) {
        if (el) {
            this.init(el, C, D, E);
        }
    };

    Roo.lib.AnimBase.fly = B;
    
    
    
    Roo.lib.AnimBase.prototype = {

        toString: function() {
            var  el = this.getEl();
            var  id = el.id || el.tagName;
            return  ("Anim " + id);
        },

        patterns: {
            noNegatives:        /width|height|opacity|padding/i,
            offsetAttribute:  /^((width|height)|(top|left))$/,
            defaultUnit:        /width|height|top$|bottom$|left$|right$/i,
            offsetUnit:         /\d+(em|%|en|ex|pt|in|cm|mm|pc)$/i
        },


        doMethod: function(C, D, E) {
            return  this.method(this.currentFrame, D, E - D, this.totalFrames);
        },


        setAttribute: function(F, G, H) {
            if (this.patterns.noNegatives.test(F)) {
                G = (G > 0) ? G : 0;
            }


            Roo.fly(this.getEl(), '_anim').setStyle(F, G + H);
        },


        getAttribute: function(I) {
            var  el = this.getEl();
            var  J = B(el).getStyle(I);

            if (J !== 'auto' && !this.patterns.offsetUnit.test(J)) {
                return  parseFloat(J);
            }

            var  a = this.patterns.offsetAttribute.exec(I) || [];
            var  K = !!( a[3] );
            var  L = !!( a[2] );


            if (L || (B(el).getStyle('position') == 'absolute' && K)) {
                J = el['offset' + a[0].charAt(0).toUpperCase() + a[0].substr(1)];
            } else  {
                J = 0;
            }

            return  J;
        },


        getDefaultUnit: function(M) {
            if (this.patterns.defaultUnit.test(M)) {
                return  'px';
            }

            return  '';
        },

        animateX : function(N, O) {
            var  f = function() {
                this.onComplete.removeListener(f);
                if (typeof  N == "function") {
                    N.call(O || this, this);
                }
            };
            this.onComplete.addListener(f, this);
            this.animate();
        },


        setRuntimeAttribute: function(P) {
            var  Q;
            var  R;
            var  S = this.attributes;

            this.runtimeAttributes[P] = {};

            var  T = function(U) {
                return  (typeof  U !== 'undefined');
            };

            if (!T(S[P]['to']) && !T(S[P]['by'])) {
                return  false;
            }


            Q = ( T(S[P]['from']) ) ? S[P]['from'] : this.getAttribute(P);


            if (T(S[P]['to'])) {
                R = S[P]['to'];
            } else  if (T(S[P]['by'])) {
                if (Q.constructor == Array) {
                    R = [];
                    for (var  i = 0, len = Q.length; i < len; ++i) {
                        R[i] = Q[i] + S[P]['by'][i];
                    }
                } else  {
                    R = Q + S[P]['by'];
                }
            }


            this.runtimeAttributes[P].start = Q;
            this.runtimeAttributes[P].end = R;


            this.runtimeAttributes[P].unit = ( T(S[P].unit) ) ? S[P]['unit'] : this.getDefaultUnit(P);
        },


        init: function(el, U, V, W) {

            var  X = false;


            var  Y = null;


            var  Z = 0;


            el = Roo.getDom(el);


            this.attributes = U || {};


            this.duration = V || 1;


            this.method = W || Roo.lib.Easing.easeNone;


            this.useSeconds = true;


            this.currentFrame = 0;


            this.totalFrames = Roo.lib.AnimMgr.fps;


            this.getEl = function() {
                return  el;
            };


            this.isAnimated = function() {
                return  X;
            };


            this.getStartTime = function() {
                return  Y;
            };

            this.runtimeAttributes = {};


            this.animate = function() {
                if (this.isAnimated()) {
                    return  false;
                }


                this.currentFrame = 0;

                this.totalFrames = ( this.useSeconds ) ? Math.ceil(Roo.lib.AnimMgr.fps * this.duration) : this.duration;

                Roo.lib.AnimMgr.registerElement(this);
            };


            this.stop = function(e) {
                if (e) {
                    this.currentFrame = this.totalFrames;
                    this._onTween.fire();
                }

                Roo.lib.AnimMgr.stop(this);
            };

            var  b = function() {
                this.onStart.fire();

                this.runtimeAttributes = {};
                for (var  P  in  this.attributes) {
                    this.setRuntimeAttribute(P);
                }


                X = true;
                Z = 0;
                Y = new  Date();
            };


            var  c = function() {
                var  e = {
                    duration: new  Date() - this.getStartTime(),
                    currentFrame: this.currentFrame
                };

                e.toString = function() {
                    return  (
                            'duration: ' + e.duration +
                            ', currentFrame: ' + e.currentFrame
                            );
                };

                this.onTween.fire(e);

                var  g = this.runtimeAttributes;

                for (var  P  in  g) {
                    this.setAttribute(P, this.doMethod(P, g[P].start, g[P].end), g[P].unit);
                }


                Z += 1;
            };

            var  d = function() {
                var  e = (new  Date() - Y) / 1000 ;

                var  g = {
                    duration: e,
                    frames: Z,
                    fps: Z / e
                };

                g.toString = function() {
                    return  (
                            'duration: ' + g.duration +
                            ', frames: ' + g.frames +
                            ', fps: ' + g.fps
                            );
                };

                X = false;
                Z = 0;
                this.onComplete.fire(g);
            };


            this._onStart = new  Roo.util.Event(this);
            this.onStart = new  Roo.util.Event(this);
            this.onTween = new  Roo.util.Event(this);
            this._onTween = new  Roo.util.Event(this);
            this.onComplete = new  Roo.util.Event(this);
            this._onComplete = new  Roo.util.Event(this);
            this._onStart.addListener(b);
            this._onTween.addListener(c);
            this._onComplete.addListener(d);
        }
    };
})();

/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */

Roo.lib.AnimMgr = new  function() {

        var  A = null;


        var  B = [];


        var  C = 0;


        this.fps = 1000;


        this.delay = 1;


        this.registerElement = function(F) {
            B[B.length] = F;
            C += 1;
            F._onStart.fire();
            this.start();
        };


        this.unRegister = function(F, G) {
            F._onComplete.fire();
            G = G || D(F);
            if (G != -1) {
                B.splice(G, 1);
            }


            C -= 1;
            if (C <= 0) {
                this.stop();
            }
        };


        this.start = function() {
            if (A === null) {
                A = setInterval(this.run, this.delay);
            }
        };


        this.stop = function(F) {
            if (!F) {
                clearInterval(A);

                for (var  i = 0, len = B.length; i < len; ++i) {
                    if (B[0].isAnimated()) {
                        this.unRegister(B[0], 0);
                    }
                }


                B = [];
                A = null;
                C = 0;
            }
            else  {
                this.unRegister(F);
            }
        };


        this.run = function() {
            for (var  i = 0, len = B.length; i < len; ++i) {
                var  tween = B[i];
                if (!tween || !tween.isAnimated()) {
                    continue;
                }

                if (tween.currentFrame < tween.totalFrames || tween.totalFrames === null)
                {
                    tween.currentFrame += 1;

                    if (tween.useSeconds) {
                        E(tween);
                    }

                    tween._onTween.fire();
                }
                else  {
                    Roo.lib.AnimMgr.stop(tween, i);
                }
            }
        };

        var  D = function(F) {
            for (var  i = 0, len = B.length; i < len; ++i) {
                if (B[i] == F) {
                    return  i;
                }
            }
            return  -1;
        };


        var  E = function(F) {
            var  G = F.totalFrames;
            var  H = F.currentFrame;
            var  I = (F.currentFrame * F.duration * 1000 / F.totalFrames);
            var  J = (new  Date() - F.getStartTime());
            var  K = 0;

            if (J < F.duration * 1000) {
                K = Math.round((J / I - 1) * F.currentFrame);
            } else  {
                K = G - (H + 1);
            }
            if (K > 0 && isFinite(K)) {
                if (F.currentFrame + K >= G) {
                    K = G - (H + 1);
                }


                F.currentFrame += K;
            }
        };
    };
/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
Roo.lib.Bezier = new  function() {

        this.getPosition = function(A, t) {
            var  n = A.length;
            var  B = [];

            for (var  i = 0; i < n; ++i) {
                B[i] = [A[i][0], A[i][1]];
            }

            for (var  j = 1; j < n; ++j) {
                for (i = 0; i < n - j; ++i) {
                    B[i][0] = (1 - t) * B[i][0] + t * B[parseInt(i + 1, 10)][0];
                    B[i][1] = (1 - t) * B[i][1] + t * B[parseInt(i + 1, 10)][1];
                }
            }

            return  [ B[0][0], B[0][1] ];

        };
    };
/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
(function() {

    Roo.lib.ColorAnim = function(el, D, E, F) {
        Roo.lib.ColorAnim.superclass.constructor.call(this, el, D, E, F);
    };

    Roo.extend(Roo.lib.ColorAnim, Roo.lib.AnimBase);

    var  A = Roo.lib.AnimBase.fly;
    var  Y = Roo.lib;
    var  B = Y.ColorAnim.superclass;
    var  C = Y.ColorAnim.prototype;

    C.toString = function() {
        var  el = this.getEl();
        var  id = el.id || el.tagName;
        return  ("ColorAnim " + id);
    };

    C.patterns.color = /color$/i;
    C.patterns.rgb = /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i;
    C.patterns.hex = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i;
    C.patterns.hex3 = /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;
    C.patterns.transparent = /^transparent|rgba\(0, 0, 0, 0\)$/;


    C.parseColor = function(s) {
        if (s.length == 3) {
            return  s;
        }

        var  c = this.patterns.hex.exec(s);
        if (c && c.length == 4) {
            return  [ parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16) ];
        }


        c = this.patterns.rgb.exec(s);
        if (c && c.length == 4) {
            return  [ parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10) ];
        }


        c = this.patterns.hex3.exec(s);
        if (c && c.length == 4) {
            return  [ parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16) ];
        }

        return  null;
    };
    // since this uses fly! - it cant be in ColorAnim (which does not have fly yet..)
    C.getAttribute = function(D) {
        var  el = this.getEl();
        if (this.patterns.color.test(D)) {
            var  val = A(el).getStyle(D);

            if (this.patterns.transparent.test(val)) {
                var  parent = el.parentNode;
                val = A(parent).getStyle(D);

                while (parent && this.patterns.transparent.test(val)) {
                    parent = parent.parentNode;
                    val = A(parent).getStyle(D);
                    if (parent.tagName.toUpperCase() == 'HTML') {
                        val = '#fff';
                    }
                }
            }
        } else  {
            val = B.getAttribute.call(this, D);
        }

        return  val;
    };
    C.getAttribute = function(D) {
        var  el = this.getEl();
        if (this.patterns.color.test(D)) {
            var  val = A(el).getStyle(D);

            if (this.patterns.transparent.test(val)) {
                var  parent = el.parentNode;
                val = A(parent).getStyle(D);

                while (parent && this.patterns.transparent.test(val)) {
                    parent = parent.parentNode;
                    val = A(parent).getStyle(D);
                    if (parent.tagName.toUpperCase() == 'HTML') {
                        val = '#fff';
                    }
                }
            }
        } else  {
            val = B.getAttribute.call(this, D);
        }

        return  val;
    };

    C.doMethod = function(D, E, F) {
        var  G;

        if (this.patterns.color.test(D)) {
            G = [];
            for (var  i = 0, len = E.length; i < len; ++i) {
                G[i] = B.doMethod.call(this, D, E[i], F[i]);
            }


            G = 'rgb(' + Math.floor(G[0]) + ',' + Math.floor(G[1]) + ',' + Math.floor(G[2]) + ')';
        }
        else  {
            G = B.doMethod.call(this, D, E, F);
        }

        return  G;
    };

    C.setRuntimeAttribute = function(D) {
        B.setRuntimeAttribute.call(this, D);

        if (this.patterns.color.test(D)) {
            var  attributes = this.attributes;
            var  start = this.parseColor(this.runtimeAttributes[D].start);
            var  end = this.parseColor(this.runtimeAttributes[D].end);

            if (typeof  attributes[D]['to'] === 'undefined' && typeof  attributes[D]['by'] !== 'undefined') {
                end = this.parseColor(attributes[D].by);

                for (var  i = 0, len = start.length; i < len; ++i) {
                    end[i] = start[i] + end[i];
                }
            }


            this.runtimeAttributes[D].start = start;
            this.runtimeAttributes[D].end = end;
        }
    };
})();


/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
Roo.lib.Easing = {


    easeNone: function (t, b, c, d) {
        return  c * t / d + b;
    },


    easeIn: function (t, b, c, d) {
        return  c * (t /= d) * t + b;
    },


    easeOut: function (t, b, c, d) {
        return  -c * (t /= d) * (t - 2) + b;
    },


    easeBoth: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return  c / 2 * t * t + b;
        }

        return  -c / 2 * ((--t) * (t - 2) - 1) + b;
    },


    easeInStrong: function (t, b, c, d) {
        return  c * (t /= d) * t * t * t + b;
    },


    easeOutStrong: function (t, b, c, d) {
        return  -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },


    easeBothStrong: function (t, b, c, d) {
        if ((t /= d / 2) < 1) {
            return  c / 2 * t * t * t * t + b;
        }

        return  -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },



    elasticIn: function (t, b, c, d, a, p) {
        if (t == 0) {
            return  b;
        }
        if ((t /= d) == 1) {
            return  b + c;
        }
        if (!p) {
            p = d * .3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            var  s = p / 4;
        }
        else  {
            var  s = p / (2 * Math.PI) * Math.asin(c / a);
        }

        return  -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },


    elasticOut: function (t, b, c, d, a, p) {
        if (t == 0) {
            return  b;
        }
        if ((t /= d) == 1) {
            return  b + c;
        }
        if (!p) {
            p = d * .3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            var  s = p / 4;
        }
        else  {
            var  s = p / (2 * Math.PI) * Math.asin(c / a);
        }

        return  a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    },


    elasticBoth: function (t, b, c, d, a, p) {
        if (t == 0) {
            return  b;
        }

        if ((t /= d / 2) == 2) {
            return  b + c;
        }

        if (!p) {
            p = d * (.3 * 1.5);
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            var  s = p / 4;
        }
        else  {
            var  s = p / (2 * Math.PI) * Math.asin(c / a);
        }

        if (t < 1) {
            return  -.5 * (a * Math.pow(2, 10 * (t -= 1)) *
                          Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        }
        return  a * Math.pow(2, -10 * (t -= 1)) *
               Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
    },



    backIn: function (t, b, c, d, s) {
        if (typeof  s == 'undefined') {
            s = 1.70158;
        }
        return  c * (t /= d) * t * ((s + 1) * t - s) + b;
    },


    backOut: function (t, b, c, d, s) {
        if (typeof  s == 'undefined') {
            s = 1.70158;
        }
        return  c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },


    backBoth: function (t, b, c, d, s) {
        if (typeof  s == 'undefined') {
            s = 1.70158;
        }

        if ((t /= d / 2 ) < 1) {
            return  c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        }
        return  c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    },


    bounceIn: function (t, b, c, d) {
        return  c - Roo.lib.Easing.bounceOut(d - t, 0, c, d) + b;
    },


    bounceOut: function (t, b, c, d) {
        if ((t /= d) < (1 / 2.75)) {
            return  c * (7.5625 * t * t) + b;
        } else  if (t < (2 / 2.75)) {
            return  c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        } else  if (t < (2.5 / 2.75)) {
            return  c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        }
        return  c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
    },


    bounceBoth: function (t, b, c, d) {
        if (t < d / 2) {
            return  Roo.lib.Easing.bounceIn(t * 2, 0, c, d) * .5 + b;
        }
        return  Roo.lib.Easing.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    }
};
/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
    (function() {
        Roo.lib.Motion = function(el, E, F, G) {
            if (el) {
                Roo.lib.Motion.superclass.constructor.call(this, el, E, F, G);
            }
        };

        Roo.extend(Roo.lib.Motion, Roo.lib.ColorAnim);


        var  Y = Roo.lib;
        var  A = Y.Motion.superclass;
        var  B = Y.Motion.prototype;

        B.toString = function() {
            var  el = this.getEl();
            var  id = el.id || el.tagName;
            return  ("Motion " + id);
        };

        B.patterns.points = /^points$/i;

        B.setAttribute = function(E, F, G) {
            if (this.patterns.points.test(E)) {
                G = G || 'px';
                A.setAttribute.call(this, 'left', F[0], G);
                A.setAttribute.call(this, 'top', F[1], G);
            } else  {
                A.setAttribute.call(this, E, F, G);
            }
        };

        B.getAttribute = function(E) {
            if (this.patterns.points.test(E)) {
                var  val = [
                        A.getAttribute.call(this, 'left'),
                        A.getAttribute.call(this, 'top')
                        ];
            } else  {
                val = A.getAttribute.call(this, E);
            }

            return  val;
        };

        B.doMethod = function(E, F, G) {
            var  H = null;

            if (this.patterns.points.test(E)) {
                var  t = this.method(this.currentFrame, 0, 100, this.totalFrames) / 100;
                H = Y.Bezier.getPosition(this.runtimeAttributes[E], t);
            } else  {
                H = A.doMethod.call(this, E, F, G);
            }
            return  H;
        };

        B.setRuntimeAttribute = function(E) {
            if (this.patterns.points.test(E)) {
                var  el = this.getEl();
                var  attributes = this.attributes;
                var  start;
                var  control = attributes['points']['control'] || [];
                var  end;
                var  i, len;

                if (control.length > 0 && !(control[0]  instanceof  Array)) {
                    control = [control];
                } else  {
                    var  tmp = [];
                    for (i = 0,len = control.length; i < len; ++i) {
                        tmp[i] = control[i];
                    }

                    control = tmp;
                }


                Roo.fly(el).position();

                if (D(attributes['points']['from'])) {
                    Roo.lib.Dom.setXY(el, attributes['points']['from']);
                }
                else  {
                    Roo.lib.Dom.setXY(el, Roo.lib.Dom.getXY(el));
                }


                start = this.getAttribute('points');


                if (D(attributes['points']['to'])) {
                    end = C.call(this, attributes['points']['to'], start);

                    var  pageXY = Roo.lib.Dom.getXY(this.getEl());
                    for (i = 0,len = control.length; i < len; ++i) {
                        control[i] = C.call(this, control[i], start);
                    }


                } else  if (D(attributes['points']['by'])) {
                    end = [ start[0] + attributes['points']['by'][0], start[1] + attributes['points']['by'][1] ];

                    for (i = 0,len = control.length; i < len; ++i) {
                        control[i] = [ start[0] + control[i][0], start[1] + control[i][1] ];
                    }
                }


                this.runtimeAttributes[E] = [start];

                if (control.length > 0) {
                    this.runtimeAttributes[E] = this.runtimeAttributes[E].concat(control);
                }


                this.runtimeAttributes[E][this.runtimeAttributes[E].length] = end;
            }
            else  {
                A.setRuntimeAttribute.call(this, E);
            }
        };

        var  C = function(E, F) {
            var  G = Roo.lib.Dom.getXY(this.getEl());
            E = [ E[0] - G[0] + F[0], E[1] - G[1] + F[1] ];

            return  E;
        };

        var  D = function(E) {
            return  (typeof  E !== 'undefined');
        };
    })();

/*
 * Portions of this file are based on pieces of Yahoo User Interface Library
 * Copyright (c) 2007, Yahoo! Inc. All rights reserved.
 * YUI licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 * <script type="text/javascript">
 *
 */
    (function() {
        Roo.lib.Scroll = function(el, C, D, E) {
            if (el) {
                Roo.lib.Scroll.superclass.constructor.call(this, el, C, D, E);
            }
        };

        Roo.extend(Roo.lib.Scroll, Roo.lib.ColorAnim);


        var  Y = Roo.lib;
        var  A = Y.Scroll.superclass;
        var  B = Y.Scroll.prototype;

        B.toString = function() {
            var  el = this.getEl();
            var  id = el.id || el.tagName;
            return  ("Scroll " + id);
        };

        B.doMethod = function(C, D, E) {
            var  F = null;

            if (C == 'scroll') {
                F = [
                        this.method(this.currentFrame, D[0], E[0] - D[0], this.totalFrames),
                        this.method(this.currentFrame, D[1], E[1] - D[1], this.totalFrames)
                        ];

            } else  {
                F = A.doMethod.call(this, C, D, E);
            }
            return  F;
        };

        B.getAttribute = function(C) {
            var  D = null;
            var  el = this.getEl();

            if (C == 'scroll') {
                D = [ el.scrollLeft, el.scrollTop ];
            } else  {
                D = A.getAttribute.call(this, C);
            }

            return  D;
        };

        B.setAttribute = function(C, D, E) {
            var  el = this.getEl();

            if (C == 'scroll') {
                el.scrollLeft = D[0];
                el.scrollTop = D[1];
            } else  {
                A.setAttribute.call(this, C, D, E);
            }
        };
    })();

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.DomHelper
 * Utility class for working with DOM and/or Templates. It transparently supports using HTML fragments or DOM.
 * For more information see <a href="http://www.jackslocum.com/yui/2006/10/06/domhelper-create-elements-using-dom-html-fragments-or-templates/">this blog post with examples</a>.
 * @singleton
 */
Roo.DomHelper = function(){
    var  A = null;
    var  B = /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i;
    var  C = /^table|tbody|tr|td$/i;
    var  D = {};
    // build as innerHTML where available
    /** @ignore */
    var  E = function(o){
        if(typeof  o == 'string'){
            return  o;
        }
        var  b = "";
        if(!o.tag){
            o.tag = "div";
        }

        b += "<" + o.tag;
        for(var  attr  in  o){
            if(attr == "tag" || attr == "children" || attr == "cn" || attr == "html" || typeof  o[attr] == "function") continue;
            if(attr == "style"){
                var  s = o["style"];
                if(typeof  s == "function"){
                    s = s.call();
                }
                if(typeof  s == "string"){
                    b += ' style="' + s + '"';
                }else  if(typeof  s == "object"){
                    b += ' style="';
                    for(var  key  in  s){
                        if(typeof  s[key] != "function"){
                            b += key + ":" + s[key] + ";";
                        }
                    }

                    b += '"';
                }
            }else {
                if(attr == "cls"){
                    b += ' class="' + o["cls"] + '"';
                }else  if(attr == "htmlFor"){
                    b += ' for="' + o["htmlFor"] + '"';
                }else {
                    b += " " + attr + '="' + o[attr] + '"';
                }
            }
        }
        if(B.test(o.tag)){
            b += "/>";
        }else {
            b += ">";
            var  cn = o.children || o.cn;
            if(cn){
                //http://bugs.kde.org/show_bug.cgi?id=71506
                if((cn  instanceof  Array) || (Roo.isSafari && typeof(cn.join) == "function")){
                    for(var  i = 0, len = cn.length; i < len; i++) {
                        b += E(cn[i], b);
                    }
                }else {
                    b += E(cn, b);
                }
            }
            if(o.html){
                b += o.html;
            }

            b += "</" + o.tag + ">";
        }
        return  b;
    };

    // build as dom
    /** @ignore */
    var  F = function(o, M){
         
        // defininition craeted..
        var  ns = false;
        if (o.ns && o.ns != 'html') {
               
            if (o.xmlns && typeof(D[o.ns]) == 'undefined') {
                D[o.ns] = o.xmlns;
                ns = o.xmlns;
            }
            if (typeof(D[o.ns]) == 'undefined') {
                console.log("Trying to create namespace element " + o.ns + ", however no xmlns was sent to builder previously");
            }

            ns = D[o.ns];
        }
        
        
        if (typeof(o) == 'string') {
            return  M.appendChild(document.createTextNode(o));
        }

        o.tag = o.tag || div;
        if (o.ns && Roo.isIE) {
            ns = false;
            o.tag = o.ns + ':' + o.tag;
            
        }
        var  el = ns ? document.createElementNS( ns, o.tag||'div') :  document.createElement(o.tag||'div');
        var  N = el.setAttribute ? true : false; // In IE some elements don't have setAttribute
        for(var  attr  in  o){
            
            if(attr == "tag" || attr == "ns" ||attr == "xmlns" ||attr == "children" || attr == "cn" || attr == "html" || 
                    attr == "style" || typeof  o[attr] == "function") continue;
                    
            if(attr=="cls" && Roo.isIE){
                el.className = o["cls"];
            }else {
                if(N) el.setAttribute(attr=="cls" ? 'class' : attr, o[attr]);
                else  el[attr] = o[attr];
            }
        }

        Roo.DomHelper.applyStyles(el, o.style);
        var  cn = o.children || o.cn;
        if(cn){
            //http://bugs.kde.org/show_bug.cgi?id=71506
             if((cn  instanceof  Array) || (Roo.isSafari && typeof(cn.join) == "function")){
                for(var  i = 0, len = cn.length; i < len; i++) {
                    F(cn[i], el);
                }
            }else {
                F(cn, el);
            }
        }
        if(o.html){
            el.innerHTML = o.html;
        }
        if(M){
           M.appendChild(el);
        }
        return  el;
    };

    var  G = function(M, s, h, e){
        A.innerHTML = [s, h, e].join('');
        var  i = -1, el = A;
        while(++i < M){
            el = el.firstChild;
        }
        return  el;
    };

    // kill repeat to save bytes
    var  ts = '<table>',
        te = '</table>',
        H = ts+'<tbody>',
        I = '</tbody>'+te,
        J = H + '<tr>',
        K = '</tr>'+I;

    /**
     * @ignore
     * Nasty code for IE's broken table implementation
     */
    var  L = function(M, N, el, O){
        if(!A){
            A = document.createElement('div');
        }
        var  P;
        var  Q = null;
        if(M == 'td'){
            if(N == 'afterbegin' || N == 'beforeend'){ // INTO a TD
                return;
            }
            if(N == 'beforebegin'){
                Q = el;
                el = el.parentNode;
            } else {
                Q = el.nextSibling;
                el = el.parentNode;
            }

            P = G(4, J, O, K);
        }
        else  if(M == 'tr'){
            if(N == 'beforebegin'){
                Q = el;
                el = el.parentNode;
                P = G(3, H, O, I);
            } else  if(N == 'afterend'){
                Q = el.nextSibling;
                el = el.parentNode;
                P = G(3, H, O, I);
            } else { // INTO a TR
                if(N == 'afterbegin'){
                    Q = el.firstChild;
                }

                P = G(4, J, O, K);
            }
        } else  if(M == 'tbody'){
            if(N == 'beforebegin'){
                Q = el;
                el = el.parentNode;
                P = G(2, ts, O, te);
            } else  if(N == 'afterend'){
                Q = el.nextSibling;
                el = el.parentNode;
                P = G(2, ts, O, te);
            } else {
                if(N == 'afterbegin'){
                    Q = el.firstChild;
                }

                P = G(3, H, O, I);
            }
        } else { // TABLE
            if(N == 'beforebegin' || N == 'afterend'){ // OUTSIDE the table
                return;
            }
            if(N == 'afterbegin'){
                Q = el.firstChild;
            }

            P = G(2, ts, O, te);
        }

        el.insertBefore(P, Q);
        return  P;
    };

    return  {
    /** True to force the use of DOM instead of html fragments @type Boolean */
    useDom : false,

    /**
     * Returns the markup for the passed Element(s) config
     * @param {Object} o The Dom object spec (and children)
     * @return {String}
     */
    markup : function(o){
        return  E(o);
    },

    /**
     * Applies a style specification to an element
     * @param {String/HTMLElement} el The element to apply styles to
     * @param {String/Object/Function} styles A style specification string eg "width:100px", or object in the form {width:"100px"}, or
     * a function which returns such a specification.
     */
    applyStyles : function(el, c){
        if(c){
           el = Roo.fly(el);
           if(typeof  c == "string"){
               var  re = /\s?([a-z\-]*)\:\s?([^;]*);?/gi;
               var  matches;
               while ((matches = re.exec(c)) != null){
                   el.setStyle(matches[1], matches[2]);
               }
           }else  if (typeof  c == "object"){
               for (var  style  in  c){
                  el.setStyle(style, c[style]);
               }
           }else  if (typeof  c == "function"){
                Roo.DomHelper.applyStyles(el, c.call());
           }
        }
    },

    /**
     * Inserts an HTML fragment into the Dom
     * @param {String} where Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd.
     * @param {HTMLElement} el The context element
     * @param {String} html The HTML fragmenet
     * @return {HTMLElement} The new node
     */
    insertHtml : function(d, el, e){
        d = d.toLowerCase();
        if(el.insertAdjacentHTML){
            if(C.test(el.tagName)){
                var  rs;
                if(rs = L(el.tagName.toLowerCase(), d, el, e)){
                    return  rs;
                }
            }
            switch(d){
                case  "beforebegin":
                    el.insertAdjacentHTML('BeforeBegin', e);
                    return  el.previousSibling;
                case  "afterbegin":
                    el.insertAdjacentHTML('AfterBegin', e);
                    return  el.firstChild;
                case  "beforeend":
                    el.insertAdjacentHTML('BeforeEnd', e);
                    return  el.lastChild;
                case  "afterend":
                    el.insertAdjacentHTML('AfterEnd', e);
                    return  el.nextSibling;
            }
            throw  'Illegal insertion point -> "' + d + '"';
        }
        var  f = el.ownerDocument.createRange();
        var  g;
        switch(d){
             case  "beforebegin":
                f.setStartBefore(el);
                g = f.createContextualFragment(e);
                el.parentNode.insertBefore(g, el);
                return  el.previousSibling;
             case  "afterbegin":
                if(el.firstChild){
                    f.setStartBefore(el.firstChild);
                    g = f.createContextualFragment(e);
                    el.insertBefore(g, el.firstChild);
                    return  el.firstChild;
                }else {
                    el.innerHTML = e;
                    return  el.firstChild;
                }
            case  "beforeend":
                if(el.lastChild){
                    f.setStartAfter(el.lastChild);
                    g = f.createContextualFragment(e);
                    el.appendChild(g);
                    return  el.lastChild;
                }else {
                    el.innerHTML = e;
                    return  el.lastChild;
                }
            case  "afterend":
                f.setStartAfter(el);
                g = f.createContextualFragment(e);
                el.parentNode.insertBefore(g, el.nextSibling);
                return  el.nextSibling;
            }
            throw  'Illegal insertion point -> "' + d + '"';
    },

    /**
     * Creates new Dom element(s) and inserts them before el
     * @param {String/HTMLElement/Element} el The context element
     * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
     * @param {Boolean} returnElement (optional) true to return a Roo.Element
     * @return {HTMLElement/Roo.Element} The new node
     */
    insertBefore : function(el, o, h){
        return  this.doInsert(el, o, h, "beforeBegin");
    },

    /**
     * Creates new Dom element(s) and inserts them after el
     * @param {String/HTMLElement/Element} el The context element
     * @param {Object} o The Dom object spec (and children)
     * @param {Boolean} returnElement (optional) true to return a Roo.Element
     * @return {HTMLElement/Roo.Element} The new node
     */
    insertAfter : function(el, o, j){
        return  this.doInsert(el, o, j, "afterEnd", "nextSibling");
    },

    /**
     * Creates new Dom element(s) and inserts them as the first child of el
     * @param {String/HTMLElement/Element} el The context element
     * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
     * @param {Boolean} returnElement (optional) true to return a Roo.Element
     * @return {HTMLElement/Roo.Element} The new node
     */
    insertFirst : function(el, o, k){
        return  this.doInsert(el, o, k, "afterBegin");
    },

    // private
    doInsert : function(el, o, l, m, n){
        el = Roo.getDom(el);
        var  p;
        if(this.useDom || o.ns){
            p = F(o, null);
            el.parentNode.insertBefore(p, n ? el[n] : el);
        }else {
            var  e = E(o);
            p = this.insertHtml(m, el, e);
        }
        return  l ? Roo.get(p, true) : p;
    },

    /**
     * Creates new Dom element(s) and appends them to el
     * @param {String/HTMLElement/Element} el The context element
     * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
     * @param {Boolean} returnElement (optional) true to return a Roo.Element
     * @return {HTMLElement/Roo.Element} The new node
     */
    append : function(el, o, q){
        el = Roo.getDom(el);
        var  r;
        if(this.useDom || o.ns){
            r = F(o, null);
            el.appendChild(r);
        }else {
            var  e = E(o);
            r = this.insertHtml("beforeEnd", el, e);
        }
        return  q ? Roo.get(r, true) : r;
    },

    /**
     * Creates new Dom element(s) and overwrites the contents of el with them
     * @param {String/HTMLElement/Element} el The context element
     * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
     * @param {Boolean} returnElement (optional) true to return a Roo.Element
     * @return {HTMLElement/Roo.Element} The new node
     */
    overwrite : function(el, o, t){
        el = Roo.getDom(el);
        if (o.ns) {
          
            while (el.childNodes.length) {
                el.removeChild(el.firstChild);
            }

            F(o, el);
        } else  {
            el.innerHTML = E(o);   
        }
        
        return  t ? Roo.get(el.firstChild, true) : el.firstChild;
    },

    /**
     * Creates a new Roo.DomHelper.Template from the Dom object spec
     * @param {Object} o The Dom object spec (and children)
     * @return {Roo.DomHelper.Template} The new template
     */
    createTemplate : function(o){
        var  u = E(o);
        return  new  Roo.Template(u);
    }
    };
}();

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
* @class Roo.Template
* Represents an HTML fragment template. Templates can be precompiled for greater performance.
* For a list of available format functions, see {@link Roo.util.Format}.<br />
* Usage:
<pre><code>
var t = new Roo.Template(
    '&lt;div name="{id}"&gt;',
        '&lt;span class="{cls}"&gt;{name:trim} {value:ellipsis(10)}&lt;/span&gt;',
    '&lt;/div&gt;'
);
t.append('some-element', {id: 'myid', cls: 'myclass', name: 'foo', value: 'bar'});
</code></pre>
* For more information see this blog post with examples: <a href="http://www.jackslocum.com/yui/2006/10/06/domhelper-create-elements-using-dom-html-fragments-or-templates/">DomHelper - Create Elements using DOM, HTML fragments and Templates</a>. 
* @constructor
* @param {String/Array} html The HTML fragment or an array of fragments to join("") or multiple arguments to join("")
*/
Roo.Template = function(A){
    if(A  instanceof  Array){
        A = A.join("");
    }else  if(arguments.length > 1){
        A = Array.prototype.join.call(arguments, "");
    }

    /**@private*/
    this.html = A;
    
};
Roo.Template.prototype = {
    /**
     * Returns an HTML fragment of this template with the specified values applied.
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @return {String} The HTML fragment
     */
    applyTemplate : function(B){
        if(this.compiled){
            return  this.compiled(B);
        }
        var  C = this.disableFormats !== true;
        var  fm = Roo.util.Format, D = this;
        var  fn = function(m, E, F, G){
            if(F && C){
                if(F.substr(0, 5) == "this."){
                    return  D.call(F.substr(5), B[E], B);
                }else {
                    if(G){
                        // quoted values are required for strings in compiled templates, 
                        // but for non compiled we need to strip them
                        // quoted reversed for jsmin
                        var  re = /^\s*['"](.*)["']\s*$/;
                        G = G.split(',');
                        for(var  i = 0, len = G.length; i < len; i++){
                            G[i] = G[i].replace(re, "$1");
                        }

                        G = [B[E]].concat(G);
                    }else {
                        G = [B[E]];
                    }
                    return  fm[F].apply(fm, G);
                }
            }else {
                return  B[E] !== undefined ? B[E] : "";
            }
        };
        return  this.html.replace(this.re, fn);
    },
    
    /**
     * Sets the HTML used as the template and optionally compiles it.
     * @param {String} html
     * @param {Boolean} compile (optional) True to compile the template (defaults to undefined)
     * @return {Roo.Template} this
     */
    set : function(E, F){
        this.html = E;
        this.compiled = null;
        if(F){
            this.compile();
        }
        return  this;
    },
    
    /**
     * True to disable format functions (defaults to false)
     * @type Boolean
     */
    disableFormats : false,
    
    /**
    * The regular expression used to match template variables 
    * @type RegExp
    * @property 
    */
    re : /\{([\w-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
    
    /**
     * Compiles the template into an internal function, eliminating the RegEx overhead.
     * @return {Roo.Template} this
     */
    compile : function(){
        var  fm = Roo.util.Format;
        var  G = this.disableFormats !== true;
        var  H = Roo.isGecko ? "+" : ",";
        var  fn = function(m, J, K, L){
            if(K && G){
                L = L ? ',' + L : "";
                if(K.substr(0, 5) != "this."){
                    K = "fm." + K + '(';
                }else {
                    K = 'this.call("'+ K.substr(5) + '", ';
                    L = ", values";
                }
            }else {
                L= ''; K = "(values['" + J + "'] == undefined ? '' : ";
            }
            return  "'"+ H + K + "values['" + J + "']" + L + ")"+H+"'";
        };
        var  I;
        // branched to use + in gecko and [].join() in others
        if(Roo.isGecko){
            I = "this.compiled = function(values){ return '" +
                   this.html.replace(/\\/g, '\\\\').replace(/(\r\n|\n)/g, '\\n').replace(/'/g, "\\'").replace(this.re, fn) +
                    "';};";
        }else {
            I = ["this.compiled = function(values){ return ['"];
            I.push(this.html.replace(/\\/g, '\\\\').replace(/(\r\n|\n)/g, '\\n').replace(/'/g, "\\'").replace(this.re, fn));
            I.push("'].join('');};");
            I = I.join('');
        }

        /**
         * eval:var:values
         * eval:var:fm
         */
        eval(I);
        return  this;
    },
    
    // private function used to call members
    call : function(J, K, L){
        return  this[J](K, L);
    },
    
    /**
     * Applies the supplied values to the template and inserts the new node(s) as the first child of el.
     * @param {String/HTMLElement/Roo.Element} el The context element
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @param {Boolean} returnElement (optional) true to return a Roo.Element (defaults to undefined)
     * @return {HTMLElement/Roo.Element} The new node or Element
     */
    insertFirst: function(el, M, N){
        return  this.doInsert('afterBegin', el, M, N);
    },

    /**
     * Applies the supplied values to the template and inserts the new node(s) before el.
     * @param {String/HTMLElement/Roo.Element} el The context element
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @param {Boolean} returnElement (optional) true to return a Roo.Element (defaults to undefined)
     * @return {HTMLElement/Roo.Element} The new node or Element
     */
    insertBefore: function(el, O, P){
        return  this.doInsert('beforeBegin', el, O, P);
    },

    /**
     * Applies the supplied values to the template and inserts the new node(s) after el.
     * @param {String/HTMLElement/Roo.Element} el The context element
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @param {Boolean} returnElement (optional) true to return a Roo.Element (defaults to undefined)
     * @return {HTMLElement/Roo.Element} The new node or Element
     */
    insertAfter : function(el, Q, R){
        return  this.doInsert('afterEnd', el, Q, R);
    },
    
    /**
     * Applies the supplied values to the template and appends the new node(s) to el.
     * @param {String/HTMLElement/Roo.Element} el The context element
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @param {Boolean} returnElement (optional) true to return a Roo.Element (defaults to undefined)
     * @return {HTMLElement/Roo.Element} The new node or Element
     */
    append : function(el, S, T){
        return  this.doInsert('beforeEnd', el, S, T);
    },

    doInsert : function(U, el, V, W){
        el = Roo.getDom(el);
        var  X = Roo.DomHelper.insertHtml(U, el, this.applyTemplate(V));
        return  W ? Roo.get(X, true) : X;
    },

    /**
     * Applies the supplied values to the template and overwrites the content of el with the new node(s).
     * @param {String/HTMLElement/Roo.Element} el The context element
     * @param {Object} values The template values. Can be an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})
     * @param {Boolean} returnElement (optional) true to return a Roo.Element (defaults to undefined)
     * @return {HTMLElement/Roo.Element} The new node or Element
     */
    overwrite : function(el, Y, Z){
        el = Roo.getDom(el);
        el.innerHTML = this.applyTemplate(Y);
        return  Z ? Roo.get(el.firstChild, true) : el.firstChild;
    }
};
/**
 * Alias for {@link #applyTemplate}
 * @method
 */
Roo.Template.prototype.apply = Roo.Template.prototype.applyTemplate;

// backwards compat
Roo.DomHelper.Template = Roo.Template;

/**
 * Creates a template from the passed element's value (<i>display:none</i> textarea, preferred) or innerHTML.
 * @param {String/HTMLElement} el A DOM element or its id
 * @returns {Roo.Template} The created template
 * @static
 */
Roo.Template.from = function(el){
    el = Roo.getDom(el);
    return  new  Roo.Template(el.value || el.innerHTML);
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/*
 * This is code is also distributed under MIT license for use
 * with jQuery and prototype JavaScript libraries.
 */
/**
 * @class Roo.DomQuery
Provides high performance selector/xpath processing by compiling queries into reusable functions. New pseudo classes and matchers can be plugged. It works on HTML and XML documents (if a content node is passed in).
<p>
DomQuery supports most of the <a href="http://www.w3.org/TR/2005/WD-css3-selectors-20051215/">CSS3 selectors spec</a>, along with some custom selectors and basic XPath.</p>

<p>
All selectors, attribute filters and pseudos below can be combined infinitely in any order. For example "div.foo:nth-child(odd)[@foo=bar].bar:first" would be a perfectly valid selector. Node filters are processed in the order in which they appear, which allows you to optimize your queries for your document structure.
</p>
<h4>Element Selectors:</h4>
<ul class="list">
    <li> <b>*</b> any element</li>
    <li> <b>E</b> an element with the tag E</li>
    <li> <b>E F</b> All descendent elements of E that have the tag F</li>
    <li> <b>E > F</b> or <b>E/F</b> all direct children elements of E that have the tag F</li>
    <li> <b>E + F</b> all elements with the tag F that are immediately preceded by an element with the tag E</li>
    <li> <b>E ~ F</b> all elements with the tag F that are preceded by a sibling element with the tag E</li>
</ul>
<h4>Attribute Selectors:</h4>
<p>The use of @ and quotes are optional. For example, div[@foo='bar'] is also a valid attribute selector.</p>
<ul class="list">
    <li> <b>E[foo]</b> has an attribute "foo"</li>
    <li> <b>E[foo=bar]</b> has an attribute "foo" that equals "bar"</li>
    <li> <b>E[foo^=bar]</b> has an attribute "foo" that starts with "bar"</li>
    <li> <b>E[foo$=bar]</b> has an attribute "foo" that ends with "bar"</li>
    <li> <b>E[foo*=bar]</b> has an attribute "foo" that contains the substring "bar"</li>
    <li> <b>E[foo%=2]</b> has an attribute "foo" that is evenly divisible by 2</li>
    <li> <b>E[foo!=bar]</b> has an attribute "foo" that does not equal "bar"</li>
</ul>
<h4>Pseudo Classes:</h4>
<ul class="list">
    <li> <b>E:first-child</b> E is the first child of its parent</li>
    <li> <b>E:last-child</b> E is the last child of its parent</li>
    <li> <b>E:nth-child(<i>n</i>)</b> E is the <i>n</i>th child of its parent (1 based as per the spec)</li>
    <li> <b>E:nth-child(odd)</b> E is an odd child of its parent</li>
    <li> <b>E:nth-child(even)</b> E is an even child of its parent</li>
    <li> <b>E:only-child</b> E is the only child of its parent</li>
    <li> <b>E:checked</b> E is an element that is has a checked attribute that is true (e.g. a radio or checkbox) </li>
    <li> <b>E:first</b> the first E in the resultset</li>
    <li> <b>E:last</b> the last E in the resultset</li>
    <li> <b>E:nth(<i>n</i>)</b> the <i>n</i>th E in the resultset (1 based)</li>
    <li> <b>E:odd</b> shortcut for :nth-child(odd)</li>
    <li> <b>E:even</b> shortcut for :nth-child(even)</li>
    <li> <b>E:contains(foo)</b> E's innerHTML contains the substring "foo"</li>
    <li> <b>E:nodeValue(foo)</b> E contains a textNode with a nodeValue that equals "foo"</li>
    <li> <b>E:not(S)</b> an E element that does not match simple selector S</li>
    <li> <b>E:has(S)</b> an E element that has a descendent that matches simple selector S</li>
    <li> <b>E:next(S)</b> an E element whose next sibling matches simple selector S</li>
    <li> <b>E:prev(S)</b> an E element whose previous sibling matches simple selector S</li>
</ul>
<h4>CSS Value Selectors:</h4>
<ul class="list">
    <li> <b>E{display=none}</b> css value "display" that equals "none"</li>
    <li> <b>E{display^=none}</b> css value "display" that starts with "none"</li>
    <li> <b>E{display$=none}</b> css value "display" that ends with "none"</li>
    <li> <b>E{display*=none}</b> css value "display" that contains the substring "none"</li>
    <li> <b>E{display%=2}</b> css value "display" that is evenly divisible by 2</li>
    <li> <b>E{display!=none}</b> css value "display" that does not equal "none"</li>
</ul>
 * @singleton
 */
Roo.DomQuery = function(){
    var  A = {}, simpleCache = {}, valueCache = {};
    var  B = /\S/;
    var  C = /^\s+|\s+$/g;
    var  D = /\{(\d+)\}/g;
    var  E = /^(\s?[\/>+~]\s?|\s|$)/;
    var  F = /^(#)?([\w-\*]+)/;
    var  G = /(\d*)n\+?(\d*)/, H = /\D/;

    function  I(p, f){
        var  i = 0;
        var  n = p.firstChild;
        while(n){
            if(n.nodeType == 1){
               if(++i == f){
                   return  n;
               }
            }

            n = n.nextSibling;
        }
        return  null;
    };

    function  J(n){
        while((n = n.nextSibling) && n.nodeType != 1);
        return  n;
    };

    function  K(n){
        while((n = n.previousSibling) && n.nodeType != 1);
        return  n;
    };

    function  L(d){
        var  n = d.firstChild, ni = -1;
 	    while(n){
 	        var  nx = n.nextSibling;
 	        if(n.nodeType == 3 && !B.test(n.nodeValue)){
 	            d.removeChild(n);
 	        }else {
 	            n.nodeIndex = ++ni;
 	        }

 	        n = nx;
 	    }
 	    return  this;
 	};

    function  M(c, a, v){
        if(!v){
            return  c;
        }
        var  r = [], ri = -1, cn;
        for(var  i = 0, ci; ci = c[i]; i++){
            if((' '+ci.className+' ').indexOf(v) != -1){
                r[++ri] = ci;
            }
        }
        return  r;
    };

    function  N(n, f){
        if(!n.tagName && typeof  n.length != "undefined"){
            n = n[0];
        }
        if(!n){
            return  null;
        }
        if(f == "for"){
            return  n.htmlFor;
        }
        if(f == "class" || f == "className"){
            return  n.className;
        }
        return  n.getAttribute(f) || n[f];

    };

    function  O(ns, f, g){
        var  h = [], ri = -1, cs;
        if(!ns){
            return  h;
        }

        g = g || "*";
        if(typeof  ns.getElementsByTagName != "undefined"){
            ns = [ns];
        }
        if(!f){
            for(var  i = 0, ni; ni = ns[i]; i++){
                cs = ni.getElementsByTagName(g);
                for(var  j = 0, ci; ci = cs[j]; j++){
                    h[++ri] = ci;
                }
            }
        }else  if(f == "/" || f == ">"){
            var  utag = g.toUpperCase();
            for(var  i = 0, ni, cn; ni = ns[i]; i++){
                cn = ni.children || ni.childNodes;
                for(var  j = 0, cj; cj = cn[j]; j++){
                    if(cj.nodeName == utag || cj.nodeName == g  || g == '*'){
                        h[++ri] = cj;
                    }
                }
            }
        }else  if(f == "+"){
            var  utag = g.toUpperCase();
            for(var  i = 0, n; n = ns[i]; i++){
                while((n = n.nextSibling) && n.nodeType != 1);
                if(n && (n.nodeName == utag || n.nodeName == g || g == '*')){
                    h[++ri] = n;
                }
            }
        }else  if(f == "~"){
            for(var  i = 0, n; n = ns[i]; i++){
                while((n = n.nextSibling) && (n.nodeType != 1 || (g == '*' || n.tagName.toLowerCase()!=g)));
                if(n){
                    h[++ri] = n;
                }
            }
        }
        return  h;
    };

    function  P(a, b){
        if(b.slice){
            return  a.concat(b);
        }
        for(var  i = 0, l = b.length; i < l; i++){
            a[a.length] = b[i];
        }
        return  a;
    }

    function  Q(cs, f){
        if(cs.tagName || cs == document){
            cs = [cs];
        }
        if(!f){
            return  cs;
        }
        var  r = [], ri = -1;
        f = f.toLowerCase();
        for(var  i = 0, ci; ci = cs[i]; i++){
            if(ci.nodeType == 1 && ci.tagName.toLowerCase()==f){
                r[++ri] = ci;
            }
        }
        return  r;
    };

    function  R(cs, f, id){
        if(cs.tagName || cs == document){
            cs = [cs];
        }
        if(!id){
            return  cs;
        }
        var  r = [], ri = -1;
        for(var  i = 0,ci; ci = cs[i]; i++){
            if(ci && ci.id == id){
                r[++ri] = ci;
                return  r;
            }
        }
        return  r;
    };

    function  S(cs, g, h, op, k){
        var  r = [], ri = -1, st = k=="{";
        var  f = Roo.DomQuery.operators[op];
        for(var  i = 0, ci; ci = cs[i]; i++){
            var  a;
            if(st){
                a = Roo.DomQuery.getStyle(ci, g);
            }
            else  if(g == "class" || g == "className"){
                a = ci.className;
            }else  if(g == "for"){
                a = ci.htmlFor;
            }else  if(g == "href"){
                a = ci.getAttribute("href", 2);
            }else {
                a = ci.getAttribute(g);
            }
            if((f && f(a, h)) || (!f && a)){
                r[++ri] = ci;
            }
        }
        return  r;
    };

    function  T(cs, f, g){
        return  Roo.DomQuery.pseudos[f](cs, g);
    };

    // This is for IE MSXML which does not support expandos.
    // IE runs the same speed using setAttribute, however FF slows way down
    // and Safari completely fails so they need to continue to use expandos.
    var  U = window.ActiveXObject ? true : false;

    // this eval is stop the compressor from
    // renaming the variable to something shorter
    
    /** eval:var:batch */
    var  V = 30803; 

    var  W = 30803;

    function  X(cs){
        var  d = ++W;
        cs[0].setAttribute("_nodup", d);
        var  r = [cs[0]];
        for(var  i = 1, len = cs.length; i < len; i++){
            var  c = cs[i];
            if(!c.getAttribute("_nodup") != d){
                c.setAttribute("_nodup", d);
                r[r.length] = c;
            }
        }
        for(var  i = 0, len = cs.length; i < len; i++){
            cs[i].removeAttribute("_nodup");
        }
        return  r;
    }

    function  Y(cs){
        if(!cs){
            return  [];
        }
        var  f = cs.length, c, i, r = cs, cj, ri = -1;
        if(!f || typeof  cs.nodeType != "undefined" || f == 1){
            return  cs;
        }
        if(U && typeof  cs[0].selectSingleNode != "undefined"){
            return  X(cs);
        }
        var  d = ++W;
        cs[0]._nodup = d;
        for(i = 1; c = cs[i]; i++){
            if(c._nodup != d){
                c._nodup = d;
            }else {
                r = [];
                for(var  j = 0; j < i; j++){
                    r[++ri] = cs[j];
                }
                for(j = i+1; cj = cs[j]; j++){
                    if(cj._nodup != d){
                        cj._nodup = d;
                        r[++ri] = cj;
                    }
                }
                return  r;
            }
        }
        return  r;
    }

    function  Z(c1, c2){
        var  d = ++W;
        for(var  i = 0, len = c1.length; i < len; i++){
            c1[i].setAttribute("_qdiff", d);
        }
        var  r = [];
        for(var  i = 0, len = c2.length; i < len; i++){
            if(c2[i].getAttribute("_qdiff") != d){
                r[r.length] = c2[i];
            }
        }
        for(var  i = 0, len = c1.length; i < len; i++){
           c1[i].removeAttribute("_qdiff");
        }
        return  r;
    }

    function  b(c1, c2){
        var  f = c1.length;
        if(!f){
            return  c2;
        }
        if(U && c1[0].selectSingleNode){
            return  Z(c1, c2);
        }
        var  d = ++W;
        for(var  i = 0; i < f; i++){
            c1[i]._qdiff = d;
        }
        var  r = [];
        for(var  i = 0, len = c2.length; i < len; i++){
            if(c2[i]._qdiff != d){
                r[r.length] = c2[i];
            }
        }
        return  r;
    }

    function  e(ns, f, g, id){
        if(ns == g){
           var  d = g.ownerDocument || g;
           return  d.getElementById(id);
        }

        ns = O(ns, f, "*");
        return  R(ns, null, id);
    }

    return  {
        getStyle : function(el, AK){
            return  Roo.fly(el).getStyle(AK);
        },
        /**
         * Compiles a selector/xpath query into a reusable function. The returned function
         * takes one parameter "root" (optional), which is the context node from where the query should start.
         * @param {String} selector The selector/xpath query
         * @param {String} type (optional) Either "select" (the default) or "simple" for a simple selector match
         * @return {Function}
         */
        compile : function(AL, AM){
            AM = AM || "select";
            
            var  fn = ["var f = function(root){\n var mode; ++batch; var n = root || document;\n"];
            var  q = AL, AN, lq;
            var  tk = Roo.DomQuery.matchers;
            var  AO = tk.length;
            var  mm;

            // accept leading mode switch
            var  AP = q.match(E);
            if(AP && AP[1]){
                fn[fn.length] = 'mode="'+AP[1].replace(C, "")+'";';
                q = q.replace(AP[1], "");
            }
            // strip leading slashes
            while(AL.substr(0, 1)=="/"){
                AL = AL.substr(1);
            }

            while(q && lq != q){
                lq = q;
                var  tm = q.match(F);
                if(AM == "select"){
                    if(tm){
                        if(tm[1] == "#"){
                            fn[fn.length] = 'n = quickId(n, mode, root, "'+tm[2]+'");';
                        }else {
                            fn[fn.length] = 'n = getNodes(n, mode, "'+tm[2]+'");';
                        }

                        q = q.replace(tm[0], "");
                    }else  if(q.substr(0, 1) != '@'){
                        fn[fn.length] = 'n = getNodes(n, mode, "*");';
                    }
                }else {
                    if(tm){
                        if(tm[1] == "#"){
                            fn[fn.length] = 'n = byId(n, null, "'+tm[2]+'");';
                        }else {
                            fn[fn.length] = 'n = byTag(n, "'+tm[2]+'");';
                        }

                        q = q.replace(tm[0], "");
                    }
                }
                while(!(mm = q.match(E))){
                    var  matched = false;
                    for(var  j = 0; j < AO; j++){
                        var  t = tk[j];
                        var  m = q.match(t.re);
                        if(m){
                            fn[fn.length] = t.select.replace(D, function(x, i){
                                                    return  m[i];
                                                });
                            q = q.replace(m[0], "");
                            matched = true;
                            break;
                        }
                    }
                    // prevent infinite loop on bad selector
                    if(!matched){
                        throw  'Error parsing selector, parsing failed at "' + q + '"';
                    }
                }
                if(mm[1]){
                    fn[fn.length] = 'mode="'+mm[1].replace(C, "")+'";';
                    q = q.replace(mm[1], "");
                }
            }

            fn[fn.length] = "return nodup(n);\n}";
            
             /** 
              * list of variables that need from compression as they are used by eval.
             *  eval:var:batch 
             *  eval:var:nodup
             *  eval:var:byTag
             *  eval:var:ById
             *  eval:var:getNodes
             *  eval:var:quickId
             *  eval:var:mode
             *  eval:var:root
             *  eval:var:n
             *  eval:var:byClassName
             *  eval:var:byPseudo
             *  eval:var:byAttribute
             *  eval:var:attrValue
             * 
             **/ 
            eval(fn.join(""));
            return  f;
        },

        /**
         * Selects a group of elements.
         * @param {String} selector The selector/xpath query (can be a comma separated list of selectors)
         * @param {Node} root (optional) The start of the query (defaults to document).
         * @return {Array}
         */
        select : function(AQ, AR, AS){
            if(!AR || AR == document){
                AR = document;
            }
            if(typeof  AR == "string"){
                AR = document.getElementById(AR);
            }
            var  AT = AQ.split(",");
            var  AU = [];
            for(var  i = 0, len = AT.length; i < len; i++){
                var  p = AT[i].replace(C, "");
                if(!A[p]){
                    A[p] = Roo.DomQuery.compile(p);
                    if(!A[p]){
                        throw  p + " is not a valid selector";
                    }
                }
                var  AJ = A[p](AR);
                if(AJ && AJ != document){
                    AU = AU.concat(AJ);
                }
            }
            if(AT.length > 1){
                return  Y(AU);
            }
            return  AU;
        },

        /**
         * Selects a single element.
         * @param {String} selector The selector/xpath query
         * @param {Node} root (optional) The start of the query (defaults to document).
         * @return {Element}
         */
        selectNode : function(AV, AW){
            return  Roo.DomQuery.select(AV, AW)[0];
        },

        /**
         * Selects the value of a node, optionally replacing null with the defaultValue.
         * @param {String} selector The selector/xpath query
         * @param {Node} root (optional) The start of the query (defaults to document).
         * @param {String} defaultValue
         */
        selectValue : function(AX, AY, AZ){
            AX = AX.replace(C, "");
            if(!valueCache[AX]){
                valueCache[AX] = Roo.DomQuery.compile(AX, "select");
            }
            var  n = valueCache[AX](AY);
            n = n[0] ? n[0] : n;
            var  v = (n && n.firstChild ? n.firstChild.nodeValue : null);
            return  ((v === null||v === undefined||v==='') ? AZ : v);
        },

        /**
         * Selects the value of a node, parsing integers and floats.
         * @param {String} selector The selector/xpath query
         * @param {Node} root (optional) The start of the query (defaults to document).
         * @param {Number} defaultValue
         * @return {Number}
         */
        selectNumber : function(Aa, Ab, Ac){
            var  v = Roo.DomQuery.selectValue(Aa, Ab, Ac || 0);
            return  parseFloat(v);
        },

        /**
         * Returns true if the passed element(s) match the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String/HTMLElement/Array} el An element id, element or array of elements
         * @param {String} selector The simple selector to test
         * @return {Boolean}
         */
        is : function(el, ss){
            if(typeof  el == "string"){
                el = document.getElementById(el);
            }
            var  Ad = (el  instanceof  Array);
            var  Ae = Roo.DomQuery.filter(Ad ? el : [el], ss);
            return  Ad ? (Ae.length == el.length) : (Ae.length > 0);
        },

        /**
         * Filters an array of elements to only include matches of a simple selector (e.g. div.some-class or span:first-child)
         * @param {Array} el An array of elements to filter
         * @param {String} selector The simple selector to test
         * @param {Boolean} nonMatches If true, it returns the elements that DON'T match
         * the selector instead of the ones that match
         * @return {Array}
         */
        filter : function(Af, ss, Ag){
            ss = ss.replace(C, "");
            if(!simpleCache[ss]){
                simpleCache[ss] = Roo.DomQuery.compile(ss, "simple");
            }
            var  Ah = simpleCache[ss](Af);
            return  Ag ? b(Ah, Af) : Ah;
        },

        /**
         * Collection of matching regular expressions and code snippets.
         */
        matchers : [{
                re: /^\.([\w-]+)/,
                select: 'n = byClassName(n, null, " {1} ");'
            }, {
                re: /^\:([\w-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
                select: 'n = byPseudo(n, "{1}", "{2}");'
            },{
                re: /^(?:([\[\{])(?:@)?([\w-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
                select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
            }, {
                re: /^#([\w-]+)/,
                select: 'n = byId(n, null, "{1}");'
            },{
                re: /^@([\w-]+)/,
                select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
            }
        ],

        /**
         * Collection of operator comparison functions. The default operators are =, !=, ^=, $=, *=, %=, |= and ~=.
         * New operators can be added as long as the match the format <i>c</i>= where <i>c</i> is any character other than space, &gt; &lt;.
         */
        operators : {
            "=" : function(a, v){
                return  a == v;
            },
            "!=" : function(a, v){
                return  a != v;
            },
            "^=" : function(a, v){
                return  a && a.substr(0, v.length) == v;
            },
            "$=" : function(a, v){
                return  a && a.substr(a.length-v.length) == v;
            },
            "*=" : function(a, v){
                return  a && a.indexOf(v) !== -1;
            },
            "%=" : function(a, v){
                return  (a % v) == 0;
            },
            "|=" : function(a, v){
                return  a && (a == v || a.substr(0, v.length+1) == v+'-');
            },
            "~=" : function(a, v){
                return  a && (' '+a+' ').indexOf(' '+v+' ') != -1;
            }
        },

        /**
         * Collection of "pseudo class" processors. Each processor is passed the current nodeset (array)
         * and the argument (if any) supplied in the selector.
         */
        pseudos : {
            "first-child" : function(c){
                var  r = [], ri = -1, n;
                for(var  i = 0, ci; ci = n = c[i]; i++){
                    while((n = n.previousSibling) && n.nodeType != 1);
                    if(!n){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "last-child" : function(c){
                var  r = [], ri = -1, n;
                for(var  i = 0, ci; ci = n = c[i]; i++){
                    while((n = n.nextSibling) && n.nodeType != 1);
                    if(!n){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "nth-child" : function(c, a) {
                var  r = [], ri = -1;
                var  m = G.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !H.test(a) && "n+" + a || a);
                var  f = (m[1] || 1) - 0, l = m[2] - 0;
                for(var  i = 0, n; n = c[i]; i++){
                    var  pn = n.parentNode;
                    if (V != pn._batch) {
                        var  j = 0;
                        for(var  cn = pn.firstChild; cn; cn = cn.nextSibling){
                            if(cn.nodeType == 1){
                               cn.nodeIndex = ++j;
                            }
                        }

                        pn._batch = V;
                    }
                    if (f == 1) {
                        if (l == 0 || n.nodeIndex == l){
                            r[++ri] = n;
                        }
                    } else  if ((n.nodeIndex + l) % f == 0){
                        r[++ri] = n;
                    }
                }

                return  r;
            },

            "only-child" : function(c){
                var  r = [], ri = -1;;
                for(var  i = 0, ci; ci = c[i]; i++){
                    if(!K(ci) && !J(ci)){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "empty" : function(c){
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    var  cns = ci.childNodes, j = 0, cn, empty = true;
                    while(cn = cns[j]){
                        ++j;
                        if(cn.nodeType == 1 || cn.nodeType == 3){
                            empty = false;
                            break;
                        }
                    }
                    if(empty){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "contains" : function(c, v){
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    if((ci.textContent||ci.innerText||'').indexOf(v) != -1){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "nodeValue" : function(c, v){
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    if(ci.firstChild && ci.firstChild.nodeValue == v){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "checked" : function(c){
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    if(ci.checked == true){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "not" : function(c, ss){
                return  Roo.DomQuery.filter(c, ss, true);
            },

            "odd" : function(c){
                return  this["nth-child"](c, "odd");
            },

            "even" : function(c){
                return  this["nth-child"](c, "even");
            },

            "nth" : function(c, a){
                return  c[a-1] || [];
            },

            "first" : function(c){
                return  c[0] || [];
            },

            "last" : function(c){
                return  c[c.length-1] || [];
            },

            "has" : function(c, ss){
                var  s = Roo.DomQuery.select;
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    if(s(ss, ci).length > 0){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "next" : function(c, ss){
                var  is = Roo.DomQuery.is;
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    var  n = J(ci);
                    if(n && is(n, ss)){
                        r[++ri] = ci;
                    }
                }
                return  r;
            },

            "prev" : function(c, ss){
                var  is = Roo.DomQuery.is;
                var  r = [], ri = -1;
                for(var  i = 0, ci; ci = c[i]; i++){
                    var  n = K(ci);
                    if(n && is(n, ss)){
                        r[++ri] = ci;
                    }
                }
                return  r;
            }
        }
    };
}();

/**
 * Selects an array of DOM nodes by CSS/XPath selector. Shorthand of {@link Roo.DomQuery#select}
 * @param {String} path The selector/xpath query
 * @param {Node} root (optional) The start of the query (defaults to document).
 * @return {Array}
 * @member Roo
 * @method query
 */
Roo.query = Roo.DomQuery.select;

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.util.Observable
 * Base class that provides a common interface for publishing events. Subclasses are expected to
 * to have a property "events" with all the events defined.<br>
 * For example:
 * <pre><code>
 Employee = function(name){
    this.name = name;
    this.addEvents({
        "fired" : true,
        "quit" : true
    });
 }
 Roo.extend(Employee, Roo.util.Observable);
</code></pre>
 * @param {Object} config properties to use (incuding events / listeners)
 */

Roo.util.Observable = function(A){
    
    A = A|| {};
    this.addEvents(A.events || {});
    if (A.events) {
        delete  A.events; // make sure
    }

     
    Roo.apply(this, A);
    
    if(this.listeners){
        this.on(this.listeners);
        delete  this.listeners;
    }
};
Roo.util.Observable.prototype = {
    /** 
 * @cfg {Object} listeners  list of events and functions to call for this object, 
 * For example :
 * <pre><code>
    listeners :  { 
       'click' : function(e) {
           ..... 
        } ,
        .... 
    } 
  </code></pre>
 */
    
    
    /**
     * Fires the specified event with the passed parameters (minus the event name).
     * @param {String} eventName
     * @param {Object...} args Variable number of parameters are passed to handlers
     * @return {Boolean} returns false if any of the handlers return false otherwise it returns true
     */
    fireEvent : function(){
        var  ce = this.events[arguments[0].toLowerCase()];
        if(typeof  ce == "object"){
            return  ce.fire.apply(ce, Array.prototype.slice.call(arguments, 1));
        }else {
            return  true;
        }
    },

    // private
    filterOptRe : /^(?:scope|delay|buffer|single)$/,

    /**
     * Appends an event handler to this component
     * @param {String}   eventName The type of event to listen for
     * @param {Function} handler The method the event invokes
     * @param {Object}   scope (optional) The scope in which to execute the handler
     * function. The handler function's "this" context.
     * @param {Object}   options (optional) An object containing handler configuration
     * properties. This may contain any of the following properties:<ul>
     * <li>scope {Object} The scope in which to execute the handler function. The handler function's "this" context.</li>
     * <li>delay {Number} The number of milliseconds to delay the invocation of the handler after te event fires.</li>
     * <li>single {Boolean} True to add a handler to handle just the next firing of the event, and then remove itself.</li>
     * <li>buffer {Number} Causes the handler to be scheduled to run in an {@link Roo.util.DelayedTask} delayed
     * by the specified number of milliseconds. If the event fires again within that time, the original
     * handler is <em>not</em> invoked, but the new handler is scheduled in its place.</li>
     * </ul><br>
     * <p>
     * <b>Combining Options</b><br>
     * Using the options argument, it is possible to combine different types of listeners:<br>
     * <br>
     * A normalized, delayed, one-time listener that auto stops the event and passes a custom argument (forumId)
		<pre><code>
		el.on('click', this.onClick, this, {
 			single: true,
    		delay: 100,
    		forumId: 4
		});
		</code></pre>
     * <p>
     * <b>Attaching multiple handlers in 1 call</b><br>
     * The method also allows for a single argument to be passed which is a config object containing properties
     * which specify multiple handlers.
     * <pre><code>
		el.on({
			'click': {
        		fn: this.onClick,
        		scope: this,
        		delay: 100
    		}, 
    		'mouseover': {
        		fn: this.onMouseOver,
        		scope: this
    		},
    		'mouseout': {
        		fn: this.onMouseOut,
        		scope: this
    		}
		});
		</code></pre>
     * <p>
     * Or a shorthand syntax which passes the same scope object to all handlers:
     	<pre><code>
		el.on({
			'click': this.onClick,
    		'mouseover': this.onMouseOver,
    		'mouseout': this.onMouseOut,
    		scope: this
		});
		</code></pre>
     */
    addListener : function(B, fn, C, o){
        if(typeof  B == "object"){
            o = B;
            for(var  e  in  o){
                if(this.filterOptRe.test(e)){
                    continue;
                }
                if(typeof  o[e] == "function"){
                    // shared options
                    this.addListener(e, o[e], o.scope,  o);
                }else {
                    // individual options
                    this.addListener(e, o[e].fn, o[e].scope, o[e]);
                }
            }
            return;
        }

        o = (!o || typeof  o == "boolean") ? {} : o;
        B = B.toLowerCase();
        var  ce = this.events[B] || true;
        if(typeof  ce == "boolean"){
            ce = new  Roo.util.Event(this, B);
            this.events[B] = ce;
        }

        ce.addListener(fn, C, o);
    },

    /**
     * Removes a listener
     * @param {String}   eventName     The type of event to listen for
     * @param {Function} handler        The handler to remove
     * @param {Object}   scope  (optional) The scope (this object) for the handler
     */
    removeListener : function(D, fn, E){
        var  ce = this.events[D.toLowerCase()];
        if(typeof  ce == "object"){
            ce.removeListener(fn, E);
        }
    },

    /**
     * Removes all listeners for this object
     */
    purgeListeners : function(){
        for(var  evt  in  this.events){
            if(typeof  this.events[evt] == "object"){
                 this.events[evt].clearListeners();
            }
        }
    },

    relayEvents : function(o, F){
        var  G = function(H){
            return  function(){
                return  this.fireEvent.apply(this, Roo.combine(H, Array.prototype.slice.call(arguments, 0)));
            };
        };
        for(var  i = 0, len = F.length; i < len; i++){
            var  ename = F[i];
            if(!this.events[ename]){ this.events[ename] = true; };
            o.on(ename, G(ename), this);
        }
    },

    /**
     * Used to define events on this Observable
     * @param {Object} object The object with the events defined
     */
    addEvents : function(o){
        if(!this.events){
            this.events = {};
        }

        Roo.applyIf(this.events, o);
    },

    /**
     * Checks to see if this object has any listeners for a specified event
     * @param {String} eventName The name of the event to check for
     * @return {Boolean} True if the event is being listened for, else false
     */
    hasListener : function(H){
        var  e = this.events[H];
        return  typeof  e == "object" && e.listeners.length > 0;
    }
};
/**
 * Appends an event handler to this element (shorthand for addListener)
 * @param {String}   eventName     The type of event to listen for
 * @param {Function} handler        The method the event invokes
 * @param {Object}   scope (optional) The scope in which to execute the handler
 * function. The handler function's "this" context.
 * @param {Object}   options  (optional)
 * @method
 */
Roo.util.Observable.prototype.on = Roo.util.Observable.prototype.addListener;
/**
 * Removes a listener (shorthand for removeListener)
 * @param {String}   eventName     The type of event to listen for
 * @param {Function} handler        The handler to remove
 * @param {Object}   scope  (optional) The scope (this object) for the handler
 * @method
 */
Roo.util.Observable.prototype.un = Roo.util.Observable.prototype.removeListener;

/**
 * Starts capture on the specified Observable. All events will be passed
 * to the supplied function with the event name + standard signature of the event
 * <b>before</b> the event is fired. If the supplied function returns false,
 * the event will not fire.
 * @param {Observable} o The Observable to capture
 * @param {Function} fn The function to call
 * @param {Object} scope (optional) The scope (this object) for the fn
 * @static
 */
Roo.util.Observable.capture = function(o, fn, I){
    o.fireEvent = o.fireEvent.createInterceptor(fn, I);
};

/**
 * Removes <b>all</b> added captures from the Observable.
 * @param {Observable} o The Observable to release
 * @static
 */
Roo.util.Observable.releaseCapture = function(o){
    o.fireEvent = Roo.util.Observable.prototype.fireEvent;
};

(function(){

    var  J = function(h, o, M){
        var  N = new  Roo.util.DelayedTask();
        return  function(){
            N.delay(o.buffer, h, M, Array.prototype.slice.call(arguments, 0));
        };
    };

    var  K = function(h, e, fn, M){
        return  function(){
            e.removeListener(fn, M);
            return  h.apply(M, arguments);
        };
    };

    var  L = function(h, o, M){
        return  function(){
            var  N = Array.prototype.slice.call(arguments, 0);
            setTimeout(function(){
                h.apply(M, N);
            }, o.delay || 10);
        };
    };

    Roo.util.Event = function(M, N){
        this.name = N;
        this.obj = M;
        this.listeners = [];
    };

    Roo.util.Event.prototype = {
        addListener : function(fn, M, N){
            var  o = N || {};
            M = M || this.obj;
            if(!this.isListening(fn, M)){
                var  l = {fn: fn, scope: M, options: o};
                var  h = fn;
                if(o.delay){
                    h = L(h, o, M);
                }
                if(o.single){
                    h = K(h, this, fn, M);
                }
                if(o.buffer){
                    h = J(h, o, M);
                }

                l.fireFn = h;
                if(!this.firing){ // if we are currently firing this event, don't disturb the listener loop
                    this.listeners.push(l);
                }else {
                    this.listeners = this.listeners.slice(0);
                    this.listeners.push(l);
                }
            }
        },

        findListener : function(fn, O){
            O = O || this.obj;
            var  ls = this.listeners;
            for(var  i = 0, len = ls.length; i < len; i++){
                var  l = ls[i];
                if(l.fn == fn && l.scope == O){
                    return  i;
                }
            }
            return  -1;
        },

        isListening : function(fn, P){
            return  this.findListener(fn, P) != -1;
        },

        removeListener : function(fn, Q){
            var  R;
            if((R = this.findListener(fn, Q)) != -1){
                if(!this.firing){
                    this.listeners.splice(R, 1);
                }else {
                    this.listeners = this.listeners.slice(0);
                    this.listeners.splice(R, 1);
                }
                return  true;
            }
            return  false;
        },

        clearListeners : function(){
            this.listeners = [];
        },

        fire : function(){
            var  ls = this.listeners, S, T = ls.length;
            if(T > 0){
                this.firing = true;
                var  args = Array.prototype.slice.call(arguments, 0);
                for(var  i = 0; i < T; i++){
                    var  l = ls[i];
                    if(l.fireFn.apply(l.scope||this.obj||window, arguments) === false){
                        this.firing = false;
                        return  false;
                    }
                }

                this.firing = false;
            }
            return  true;
        }
    };
})();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.EventManager
 * Registers event handlers that want to receive a normalized EventObject instead of the standard browser event and provides 
 * several useful events directly.
 * See {@link Roo.EventObject} for more details on normalized event objects.
 * @singleton
 */
Roo.EventManager = function(){
    var  A, B, C = false;
    var  F, G, H, I;
    var  E = Roo.lib.Event;
    var  D = Roo.lib.Dom;


    var  J = function(){
        if(!C){
            C = true;
            Roo.isReady = true;
            if(B){
                clearInterval(B);
            }
            if(Roo.isGecko || Roo.isOpera) {
                document.removeEventListener("DOMContentLoaded", J, false);
            }
            if(Roo.isIE){
                var  defer = document.getElementById("ie-deferred-loader");
                if(defer){
                    defer.onreadystatechange = null;
                    defer.parentNode.removeChild(defer);
                }
            }
            if(A){
                A.fire();
                A.clearListeners();
            }
        }
    };
    
    var  K = function(){
        A = new  Roo.util.Event();
        if(Roo.isGecko || Roo.isOpera) {
            document.addEventListener("DOMContentLoaded", J, false);
        }else  if(Roo.isIE){
            document.write("<s"+'cript id="ie-deferred-loader" defer="defer" src="/'+'/:"></s'+"cript>");
            var  defer = document.getElementById("ie-deferred-loader");
            defer.onreadystatechange = function(){
                if(this.readyState == "complete"){
                    J();
                }
            };
        }else  if(Roo.isSafari){ 
            B = setInterval(function(){
                var  rs = document.readyState;
                if(rs == "complete") {
                    J();     
                 }
            }, 10);
        }

        // no matter what, make sure it fires on load
        E.on(window, "load", J);
    };

    var  L = function(h, o){
        var  S = new  Roo.util.DelayedTask(h);
        return  function(e){
            // create new event object impl so new events don't wipe out properties
            e = new  Roo.EventObjectImpl(e);
            S.delay(o.buffer, h, null, [e]);
        };
    };

    var  M = function(h, el, S, fn){
        return  function(e){
            Roo.EventManager.removeListener(el, S, fn);
            h(e);
        };
    };

    var  N = function(h, o){
        return  function(e){
            // create new event object impl so new events don't wipe out properties
            e = new  Roo.EventObjectImpl(e);
            setTimeout(function(){
                h(e);
            }, o.delay || 10);
        };
    };

    var  O = function(S, T, U, fn, V){
        var  o = (!U || typeof  U == "boolean") ? {} : U;
        fn = fn || o.fn; V = V || o.scope;
        var  el = Roo.getDom(S);
        if(!el){
            throw  "Error listening for \"" + T + '\". Element "' + S + '" doesn\'t exist.';
        }
        var  h = function(e){
            e = Roo.EventObject.setEvent(e);
            var  t;
            if(o.delegate){
                t = e.getTarget(o.delegate, el);
                if(!t){
                    return;
                }
            }else {
                t = e.target;
            }
            if(o.stopEvent === true){
                e.stopEvent();
            }
            if(o.preventDefault === true){
               e.preventDefault();
            }
            if(o.stopPropagation === true){
                e.stopPropagation();
            }

            if(o.normalized === false){
                e = e.browserEvent;
            }


            fn.call(V || el, e, t, o);
        };
        if(o.delay){
            h = N(h, o);
        }
        if(o.single){
            h = M(h, el, T, fn);
        }
        if(o.buffer){
            h = L(h, o);
        }

        fn._handlers = fn._handlers || [];
        fn._handlers.push([Roo.id(el), T, h]);

        E.on(el, T, h);
        if(T == "mousewheel" && el.addEventListener){ // workaround for jQuery
            el.addEventListener("DOMMouseScroll", h, false);
            E.on(window, 'unload', function(){
                el.removeEventListener("DOMMouseScroll", h, false);
            });
        }
        if(T == "mousedown" && el == document){ // fix stopped mousedowns on the document
            Roo.EventManager.stoppedMouseDownEvent.addListener(h);
        }
        return  h;
    };

    var  P = function(el, S, fn){
        var  id = Roo.id(el), T = fn._handlers, hd = fn;
        if(T){
            for(var  i = 0, len = T.length; i < len; i++){
                var  h = T[i];
                if(h[0] == id && h[1] == S){
                    hd = h[2];
                    T.splice(i, 1);
                    break;
                }
            }
        }

        E.un(el, S, hd);
        el = Roo.getDom(el);
        if(S == "mousewheel" && el.addEventListener){
            el.removeEventListener("DOMMouseScroll", hd, false);
        }
        if(S == "mousedown" && el == document){ // fix stopped mousedowns on the document
            Roo.EventManager.stoppedMouseDownEvent.removeListener(hd);
        }
    };

    var  Q = /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/;
    
    var  R = {
        
        
        /** 
         * Fix for doc tools
         * @scope Roo.EventManager
         */
        
        
        /** 
         * This is no longer needed and is deprecated. Places a simple wrapper around an event handler to override the browser event
         * object with a Roo.EventObject
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    An object that becomes the scope of the handler
         * @param {boolean}  override If true, the obj passed in becomes
         *                             the execution scope of the listener
         * @return {Function} The wrapped function
         * @deprecated
         */
        wrap : function(fn, S, T){
            return  function(e){
                Roo.EventObject.setEvent(e);
                fn.call(T ? S || window : window, Roo.EventObject, S);
            };
        },
        
        /**
     * Appends an event handler to an element (shorthand for addListener)
     * @param {String/HTMLElement}   element        The html element or id to assign the
     * @param {String}   eventName The type of event to listen for
     * @param {Function} handler The method the event invokes
     * @param {Object}   scope (optional) The scope in which to execute the handler
     * function. The handler function's "this" context.
     * @param {Object}   options (optional) An object containing handler configuration
     * properties. This may contain any of the following properties:<ul>
     * <li>scope {Object} The scope in which to execute the handler function. The handler function's "this" context.</li>
     * <li>delegate {String} A simple selector to filter the target or look for a descendant of the target</li>
     * <li>stopEvent {Boolean} True to stop the event. That is stop propagation, and prevent the default action.</li>
     * <li>preventDefault {Boolean} True to prevent the default action</li>
     * <li>stopPropagation {Boolean} True to prevent event propagation</li>
     * <li>normalized {Boolean} False to pass a browser event to the handler function instead of an Roo.EventObject</li>
     * <li>delay {Number} The number of milliseconds to delay the invocation of the handler after te event fires.</li>
     * <li>single {Boolean} True to add a handler to handle just the next firing of the event, and then remove itself.</li>
     * <li>buffer {Number} Causes the handler to be scheduled to run in an {@link Roo.util.DelayedTask} delayed
     * by the specified number of milliseconds. If the event fires again within that time, the original
     * handler is <em>not</em> invoked, but the new handler is scheduled in its place.</li>
     * </ul><br>
     * <p>
     * <b>Combining Options</b><br>
     * Using the options argument, it is possible to combine different types of listeners:<br>
     * <br>
     * A normalized, delayed, one-time listener that auto stops the event and passes a custom argument (forumId)<div style="margin: 5px 20px 20px;">
     * Code:<pre><code>
el.on('click', this.onClick, this, {
    single: true,
    delay: 100,
    stopEvent : true,
    forumId: 4
});</code></pre>
     * <p>
     * <b>Attaching multiple handlers in 1 call</b><br>
      * The method also allows for a single argument to be passed which is a config object containing properties
     * which specify multiple handlers.
     * <p>
     * Code:<pre><code>
el.on({
    'click' : {
        fn: this.onClick
        scope: this,
        delay: 100
    },
    'mouseover' : {
        fn: this.onMouseOver
        scope: this
    },
    'mouseout' : {
        fn: this.onMouseOut
        scope: this
    }
});</code></pre>
     * <p>
     * Or a shorthand syntax:<br>
     * Code:<pre><code>
el.on({
    'click' : this.onClick,
    'mouseover' : this.onMouseOver,
    'mouseout' : this.onMouseOut
    scope: this
});</code></pre>
     */
        addListener : function(U, V, fn, W, X){
            if(typeof  V == "object"){
                var  o = V;
                for(var  e  in  o){
                    if(Q.test(e)){
                        continue;
                    }
                    if(typeof  o[e] == "function"){
                        // shared options
                        O(U, e, o, o[e], o.scope);
                    }else {
                        // individual options
                        O(U, e, o[e]);
                    }
                }
                return;
            }
            return  O(U, V, X, fn, W);
        },
        
        /**
         * Removes an event handler
         *
         * @param {String/HTMLElement}   element        The id or html element to remove the 
         *                             event from
         * @param {String}   eventName     The type of event
         * @param {Function} fn
         * @return {Boolean} True if a listener was actually removed
         */
        removeListener : function(Y, Z, fn){
            return  P(Y, Z, fn);
        },
        
        /**
         * Fires when the document is ready (before onload and before images are loaded). Can be 
         * accessed shorthanded Roo.onReady().
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    An  object that becomes the scope of the handler
         * @param {boolean}  options
         */
        onDocumentReady : function(fn, a, b){
            if(C){ // if it already fired
                A.addListener(fn, a, b);
                A.fire();
                A.clearListeners();
                return;
            }
            if(!A){
                K();
            }

            A.addListener(fn, a, b);
        },
        
        /**
         * Fires when the window is resized and provides resize event buffering (50 milliseconds), passes new viewport width and height to handlers.
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    An object that becomes the scope of the handler
         * @param {boolean}  options
         */
        onWindowResize : function(fn, c, d){
            if(!F){
                F = new  Roo.util.Event();
                G = new  Roo.util.DelayedTask(function(){
                    F.fire(D.getViewWidth(), D.getViewHeight());
                });
                E.on(window, "resize", function(){
                    if(Roo.isIE){
                        G.delay(50);
                    }else {
                        F.fire(D.getViewWidth(), D.getViewHeight());
                    }
                });
            }

            F.addListener(fn, c, d);
        },

        /**
         * Fires when the user changes the active text size. Handler gets called with 2 params, the old size and the new size.
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    An object that becomes the scope of the handler
         * @param {boolean}  options
         */
        onTextResize : function(fn, f, g){
            if(!H){
                H = new  Roo.util.Event();
                var  textEl = new  Roo.Element(document.createElement('div'));
                textEl.dom.className = 'x-text-resize';
                textEl.dom.innerHTML = 'X';
                textEl.appendTo(document.body);
                I = textEl.dom.offsetHeight;
                setInterval(function(){
                    if(textEl.dom.offsetHeight != I){
                        H.fire(I, I = textEl.dom.offsetHeight);
                    }
                }, this.textResizeInterval);
            }

            H.addListener(fn, f, g);
        },

        /**
         * Removes the passed window resize listener.
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    The scope of handler
         */
        removeResizeListener : function(fn, j){
            if(F){
                F.removeListener(fn, j);
            }
        },

        // private
        fireResize : function(){
            if(F){
                F.fire(D.getViewWidth(), D.getViewHeight());
            }   
        },
        /**
         * Url used for onDocumentReady with using SSL (defaults to Roo.SSL_SECURE_URL)
         */
        ieDeferSrc : false,
        /**
         * The frequency, in milliseconds, to check for text resize events (defaults to 50)
         */
        textResizeInterval : 50
    };
    
    /**
     * Fix for doc tools
     * @scopeAlias pub=Roo.EventManager
     */
    
     /**
     * Appends an event handler to an element (shorthand for addListener)
     * @param {String/HTMLElement}   element        The html element or id to assign the
     * @param {String}   eventName The type of event to listen for
     * @param {Function} handler The method the event invokes
     * @param {Object}   scope (optional) The scope in which to execute the handler
     * function. The handler function's "this" context.
     * @param {Object}   options (optional) An object containing handler configuration
     * properties. This may contain any of the following properties:<ul>
     * <li>scope {Object} The scope in which to execute the handler function. The handler function's "this" context.</li>
     * <li>delegate {String} A simple selector to filter the target or look for a descendant of the target</li>
     * <li>stopEvent {Boolean} True to stop the event. That is stop propagation, and prevent the default action.</li>
     * <li>preventDefault {Boolean} True to prevent the default action</li>
     * <li>stopPropagation {Boolean} True to prevent event propagation</li>
     * <li>normalized {Boolean} False to pass a browser event to the handler function instead of an Roo.EventObject</li>
     * <li>delay {Number} The number of milliseconds to delay the invocation of the handler after te event fires.</li>
     * <li>single {Boolean} True to add a handler to handle just the next firing of the event, and then remove itself.</li>
     * <li>buffer {Number} Causes the handler to be scheduled to run in an {@link Roo.util.DelayedTask} delayed
     * by the specified number of milliseconds. If the event fires again within that time, the original
     * handler is <em>not</em> invoked, but the new handler is scheduled in its place.</li>
     * </ul><br>
     * <p>
     * <b>Combining Options</b><br>
     * Using the options argument, it is possible to combine different types of listeners:<br>
     * <br>
     * A normalized, delayed, one-time listener that auto stops the event and passes a custom argument (forumId)<div style="margin: 5px 20px 20px;">
     * Code:<pre><code>
el.on('click', this.onClick, this, {
    single: true,
    delay: 100,
    stopEvent : true,
    forumId: 4
});</code></pre>
     * <p>
     * <b>Attaching multiple handlers in 1 call</b><br>
      * The method also allows for a single argument to be passed which is a config object containing properties
     * which specify multiple handlers.
     * <p>
     * Code:<pre><code>
el.on({
    'click' : {
        fn: this.onClick
        scope: this,
        delay: 100
    },
    'mouseover' : {
        fn: this.onMouseOver
        scope: this
    },
    'mouseout' : {
        fn: this.onMouseOut
        scope: this
    }
});</code></pre>
     * <p>
     * Or a shorthand syntax:<br>
     * Code:<pre><code>
el.on({
    'click' : this.onClick,
    'mouseover' : this.onMouseOver,
    'mouseout' : this.onMouseOut
    scope: this
});</code></pre>
     */
    R.on = R.addListener;
    R.un = R.removeListener;

    R.stoppedMouseDownEvent = new  Roo.util.Event();
    return  R;
}();
/**
  * Fires when the document is ready (before onload and before images are loaded).  Shorthand of {@link Roo.EventManager#onDocumentReady}.
  * @param {Function} fn        The method the event invokes
  * @param {Object}   scope    An  object that becomes the scope of the handler
  * @param {boolean}  override If true, the obj passed in becomes
  *                             the execution scope of the listener
  * @member Roo
  * @method onReady
 */
Roo.onReady = Roo.EventManager.onDocumentReady;

Roo.onReady(function(){
    var  bd = Roo.get(document.body);
    if(!bd){ return; }

    var  S = [
            Roo.isIE ? "roo-ie"
            : Roo.isGecko ? "roo-gecko"
            : Roo.isOpera ? "roo-opera"
            : Roo.isSafari ? "roo-safari" : ""];

    if(Roo.isMac){
        S.push("roo-mac");
    }
    if(Roo.isLinux){
        S.push("roo-linux");
    }
    if(Roo.isBorderBox){
        S.push('roo-border-box');
    }
    if(Roo.isStrict){ // add to the parent to allow for selectors like ".ext-strict .ext-ie"
        var  p = bd.dom.parentNode;
        if(p){
            p.className += ' roo-strict';
        }
    }

    bd.addClass(S.join(' '));
});

/**
 * @class Roo.EventObject
 * EventObject exposes the Yahoo! UI Event functionality directly on the object
 * passed to your event handler. It exists mostly for convenience. It also fixes the annoying null checks automatically to cleanup your code 
 * Example:
 * <pre><code>
 function handleClick(e){ // e is not a standard event object, it is a Roo.EventObject
    e.preventDefault();
    var target = e.getTarget();
    ...
 }
 var myDiv = Roo.get("myDiv");
 myDiv.on("click", handleClick);
 //or
 Roo.EventManager.on("myDiv", 'click', handleClick);
 Roo.EventManager.addListener("myDiv", 'click', handleClick);
 </code></pre>
 * @singleton
 */
Roo.EventObject = function(){
    
    var  E = Roo.lib.Event;
    
    // safari keypress events for special keys return bad keycodes
    var  T = {
        63234 : 37, // left
        63235 : 39, // right
        63232 : 38, // up
        63233 : 40, // down
        63276 : 33, // page up
        63277 : 34, // page down
        63272 : 46, // delete
        63273 : 36, // home
        63275 : 35  // end
    };

    // normalize button clicks
    var  U = Roo.isIE ? {1:0,4:1,2:2} :
                (Roo.isSafari ? {1:0,2:1,3:2} : {0:0,1:1,2:2});

    Roo.EventObjectImpl = function(e){
        if(e){
            this.setEvent(e.browserEvent || e);
        }
    };
    Roo.EventObjectImpl.prototype = {
        /**
         * Used to fix doc tools.
         * @scope Roo.EventObject.prototype
         */
            

        
        
        /** The normal browser event */
        browserEvent : null,
        /** The button pressed in a mouse event */
        button : -1,
        /** True if the shift key was down during the event */
        shiftKey : false,
        /** True if the control key was down during the event */
        ctrlKey : false,
        /** True if the alt key was down during the event */
        altKey : false,

        /** Key constant 
        * @type Number */
        BACKSPACE : 8,
        /** Key constant 
        * @type Number */
        TAB : 9,
        /** Key constant 
        * @type Number */
        RETURN  : 13,
        /** Key constant 
        * @type Number */
        ENTER : 13,
        /** Key constant 
        * @type Number */
        SHIFT : 16,
        /** Key constant 
        * @type Number */
        CONTROL : 17,
        /** Key constant 
        * @type Number */
        ESC : 27,
        /** Key constant 
        * @type Number */
        SPACE : 32,
        /** Key constant 
        * @type Number */
        PAGEUP : 33,
        /** Key constant 
        * @type Number */
        PAGEDOWN : 34,
        /** Key constant 
        * @type Number */
        END : 35,
        /** Key constant 
        * @type Number */
        HOME : 36,
        /** Key constant 
        * @type Number */
        LEFT : 37,
        /** Key constant 
        * @type Number */
        UP : 38,
        /** Key constant 
        * @type Number */
        RIGHT : 39,
        /** Key constant 
        * @type Number */
        DOWN : 40,
        /** Key constant 
        * @type Number */
        DELETE  : 46,
        /** Key constant 
        * @type Number */
        F5 : 116,

           /** @private */
        setEvent : function(e){
            if(e == this || (e && e.browserEvent)){ // already wrapped
                return  e;
            }

            this.browserEvent = e;
            if(e){
                // normalize buttons
                this.button = e.button ? U[e.button] : (e.which ? e.which-1 : -1);
                if(e.type == 'click' && this.button == -1){
                    this.button = 0;
                }

                this.type = e.type;
                this.shiftKey = e.shiftKey;
                // mac metaKey behaves like ctrlKey
                this.ctrlKey = e.ctrlKey || e.metaKey;
                this.altKey = e.altKey;
                // in getKey these will be normalized for the mac
                this.keyCode = e.keyCode;
                // keyup warnings on firefox.
                this.charCode = (e.type == 'keyup' || e.type == 'keydown') ? 0 : e.charCode;
                // cache the target for the delayed and or buffered events
                this.target = E.getTarget(e);
                // same for XY
                this.xy = E.getXY(e);
            }else {
                this.button = -1;
                this.shiftKey = false;
                this.ctrlKey = false;
                this.altKey = false;
                this.keyCode = 0;
                this.charCode =0;
                this.target = null;
                this.xy = [0, 0];
            }
            return  this;
        },

        /**
         * Stop the event (preventDefault and stopPropagation)
         */
        stopEvent : function(){
            if(this.browserEvent){
                if(this.browserEvent.type == 'mousedown'){
                    Roo.EventManager.stoppedMouseDownEvent.fire(this);
                }

                E.stopEvent(this.browserEvent);
            }
        },

        /**
         * Prevents the browsers default handling of the event.
         */
        preventDefault : function(){
            if(this.browserEvent){
                E.preventDefault(this.browserEvent);
            }
        },

        /** @private */
        isNavKeyPress : function(){
            var  k = this.keyCode;
            k = Roo.isSafari ? (T[k] || k) : k;
            return  (k >= 33 && k <= 40) || k == this.RETURN  || k == this.TAB || k == this.ESC;
        },

        isSpecialKey : function(){
            var  k = this.keyCode;
            return  (this.type == 'keypress' && this.ctrlKey) || k == 9 || k == 13  || k == 40 || k == 27 ||
            (k == 16) || (k == 17) ||
            (k >= 18 && k <= 20) ||
            (k >= 33 && k <= 35) ||
            (k >= 36 && k <= 39) ||
            (k >= 44 && k <= 45);
        },
        /**
         * Cancels bubbling of the event.
         */
        stopPropagation : function(){
            if(this.browserEvent){
                if(this.type == 'mousedown'){
                    Roo.EventManager.stoppedMouseDownEvent.fire(this);
                }

                E.stopPropagation(this.browserEvent);
            }
        },

        /**
         * Gets the key code for the event.
         * @return {Number}
         */
        getCharCode : function(){
            return  this.charCode || this.keyCode;
        },

        /**
         * Returns a normalized keyCode for the event.
         * @return {Number} The key code
         */
        getKey : function(){
            var  k = this.keyCode || this.charCode;
            return  Roo.isSafari ? (T[k] || k) : k;
        },

        /**
         * Gets the x coordinate of the event.
         * @return {Number}
         */
        getPageX : function(){
            return  this.xy[0];
        },

        /**
         * Gets the y coordinate of the event.
         * @return {Number}
         */
        getPageY : function(){
            return  this.xy[1];
        },

        /**
         * Gets the time of the event.
         * @return {Number}
         */
        getTime : function(){
            if(this.browserEvent){
                return  E.getTime(this.browserEvent);
            }
            return  null;
        },

        /**
         * Gets the page coordinates of the event.
         * @return {Array} The xy values like [x, y]
         */
        getXY : function(){
            return  this.xy;
        },

        /**
         * Gets the target for the event.
         * @param {String} selector (optional) A simple selector to filter the target or look for an ancestor of the target
         * @param {Number/String/HTMLElement/Element} maxDepth (optional) The max depth to
                search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Roo.Element object instead of DOM node
         * @return {HTMLelement}
         */
        getTarget : function(V, W, X){
            return  V ? Roo.fly(this.target).findParent(V, W, X) : this.target;
        },
        /**
         * Gets the related target.
         * @return {HTMLElement}
         */
        getRelatedTarget : function(){
            if(this.browserEvent){
                return  E.getRelatedTarget(this.browserEvent);
            }
            return  null;
        },

        /**
         * Normalizes mouse wheel delta across browsers
         * @return {Number} The delta
         */
        getWheelDelta : function(){
            var  e = this.browserEvent;
            var  Y = 0;
            if(e.wheelDelta){ /* IE/Opera. */
                Y = e.wheelDelta/120;
            }else  if(e.detail){ /* Mozilla case. */
                Y = -e.detail/3;
            }
            return  Y;
        },

        /**
         * Returns true if the control, meta, shift or alt key was pressed during this event.
         * @return {Boolean}
         */
        hasModifier : function(){
            return  !!((this.ctrlKey || this.altKey) || this.shiftKey);
        },

        /**
         * Returns true if the target of this event equals el or is a child of el
         * @param {String/HTMLElement/Element} el
         * @param {Boolean} related (optional) true to test if the related target is within el instead of the target
         * @return {Boolean}
         */
        within : function(el, Z){
            var  t = this[Z ? "getRelatedTarget" : "getTarget"]();
            return  t && Roo.fly(el).contains(t);
        },

        getPoint : function(){
            return  new  Roo.lib.Point(this.xy[0], this.xy[1]);
        }
    };

    return  new  Roo.EventObjectImpl();
}();
            
    
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
// was in Composite Element!??!?!
 
(function(){
    var  D = Roo.lib.Dom;
    var  E = Roo.lib.Event;
    var  A = Roo.lib.Anim;

    // local style camelizing for speed
    var  B = {};
    var  C = /(-[a-z])/gi;
    var  F = function(m, a){ return  a.charAt(1).toUpperCase(); };
    var  G = document.defaultView;

/**
 * @class Roo.Element
 * Represents an Element in the DOM.<br><br>
 * Usage:<br>
<pre><code>
var el = Roo.get("my-div");

// or with getEl
var el = getEl("my-div");

// or with a DOM element
var el = Roo.get(myDivElement);
</code></pre>
 * Using Roo.get() or getEl() instead of calling the constructor directly ensures you get the same object
 * each call instead of constructing a new one.<br><br>
 * <b>Animations</b><br />
 * Many of the functions for manipulating an element have an optional "animate" parameter. The animate parameter
 * should either be a boolean (true) or an object literal with animation options. The animation options are:
<pre>
Option    Default   Description
--------- --------  ---------------------------------------------
duration  .35       The duration of the animation in seconds
easing    easeOut   The YUI easing method
callback  none      A function to execute when the anim completes
scope     this      The scope (this) of the callback function
</pre>
* Also, the Anim object being used for the animation will be set on your options object as "anim", which allows you to stop or
* manipulate the animation. Here's an example:
<pre><code>
var el = Roo.get("my-div");

// no animation
el.setWidth(100);

// default animation
el.setWidth(100, true);

// animation with some options set
el.setWidth(100, {
    duration: 1,
    callback: this.foo,
    scope: this
});

// using the "anim" property to get the Anim object
var opt = {
    duration: 1,
    callback: this.foo,
    scope: this
};
el.setWidth(100, opt);
...
if(opt.anim.isAnimated()){
    opt.anim.stop();
}
</code></pre>
* <b> Composite (Collections of) Elements</b><br />
 * For working with collections of Elements, see <a href="Roo.CompositeElement.html">Roo.CompositeElement</a>
 * @constructor Create a new Element directly.
 * @param {String/HTMLElement} element
 * @param {Boolean} forceNew (optional) By default the constructor checks to see if there is already an instance of this element in the cache and if there is it returns the same instance. This will skip that check (useful for extending this class).
 */
    Roo.Element = function(J, K){
        var  L = typeof  J == "string" ?
                document.getElementById(J) : J;
        if(!L){ // invalid id/element
            return  null;
        }
        var  id = L.id;
        if(K !== true && id && Roo.Element.cache[id]){ // element object already exists
            return  Roo.Element.cache[id];
        }


        /**
         * The DOM element
         * @type HTMLElement
         */
        this.dom = L;

        /**
         * The DOM element ID
         * @type String
         */
        this.id = id || Roo.id(L);
    };

    var  El = Roo.Element;

    El.prototype = {
        /**
         * The element's default display mode  (defaults to "")
         * @type String
         */
        originalDisplay : "",

        visibilityMode : 1,
        /**
         * The default unit to append to CSS values where a unit isn't provided (defaults to px).
         * @type String
         */
        defaultUnit : "px",
        /**
         * Sets the element's visibility mode. When setVisible() is called it
         * will use this to determine whether to set the visibility or the display property.
         * @param visMode Element.VISIBILITY or Element.DISPLAY
         * @return {Roo.Element} this
         */
        setVisibilityMode : function(J){
            this.visibilityMode = J;
            return  this;
        },
        /**
         * Convenience method for setVisibilityMode(Element.DISPLAY)
         * @param {String} display (optional) What to set display to when visible
         * @return {Roo.Element} this
         */
        enableDisplayMode : function(K){
            this.setVisibilityMode(El.DISPLAY);
            if(typeof  K != "undefined") this.originalDisplay = K;
            return  this;
        },

        /**
         * Looks at this node and then at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Element} maxDepth (optional) The max depth to
                search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Roo.Element object instead of DOM node
         * @return {HTMLElement} The matching DOM node (or null if no match was found)
         */
        findParent : function(L, M, N){
            var  p = this.dom, b = document.body, O = 0, dq = Roo.DomQuery, P;
            M = M || 50;
            if(typeof  M != "number"){
                P = Roo.getDom(M);
                M = 10;
            }
            while(p && p.nodeType == 1 && O < M && p != b && p != P){
                if(dq.is(p, L)){
                    return  N ? Roo.get(p) : p;
                }

                O++;
                p = p.parentNode;
            }
            return  null;
        },


        /**
         * Looks at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Element} maxDepth (optional) The max depth to
                search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Roo.Element object instead of DOM node
         * @return {HTMLElement} The matching DOM node (or null if no match was found)
         */
        findParentNode : function(Q, R, S){
            var  p = Roo.fly(this.dom.parentNode, '_internal');
            return  p ? p.findParent(Q, R, S) : null;
        },

        /**
         * Walks up the dom looking for a parent node that matches the passed simple selector (e.g. div.some-class or span:first-child).
         * This is a shortcut for findParentNode() that always returns an Roo.Element.
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Element} maxDepth (optional) The max depth to
                search as a number or element (defaults to 10 || document.body)
         * @return {Roo.Element} The matching DOM node (or null if no match was found)
         */
        up : function(T, U){
            return  this.findParentNode(T, U, true);
        },



        /**
         * Returns true if this element matches the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @return {Boolean} True if this element matches the selector, else false
         */
        is : function(V){
            return  Roo.DomQuery.is(this.dom, V);
        },

        /**
         * Perform animation on this element.
         * @param {Object} args The YUI animation control args
         * @param {Float} duration (optional) How long the animation lasts in seconds (defaults to .35)
         * @param {Function} onComplete (optional) Function to call when animation completes
         * @param {String} easing (optional) Easing method to use (defaults to 'easeOut')
         * @param {String} animType (optional) 'run' is the default. Can also be 'color', 'motion', or 'scroll'
         * @return {Roo.Element} this
         */
        animate : function(W, X, Y, Z, c){
            this.anim(W, {duration: X, callback: Y, easing: Z}, c);
            return  this;
        },

        /*
         * @private Internal animation call
         */
        anim : function(e, g, h, j, k, cb){
            h = h || 'run';
            g = g || {};
            var  l = Roo.lib.Anim[h](
                this.dom, e,
                (g.duration || j) || .35,
                (g.easing || k) || 'easeOut',
                function(){
                    Roo.callback(cb, this);
                    Roo.callback(g.callback, g.scope || this, [this, g]);
                },
                this
            );
            g.anim = l;
            return  l;
        },

        // private legacy anim prep
        preanim : function(a, i){
            return  !a[i] ? false : (typeof  a[i] == "object" ? a[i]: {duration: a[i+1], callback: a[i+2], easing: a[i+3]});
        },

        /**
         * Removes worthless text nodes
         * @param {Boolean} forceReclean (optional) By default the element
         * keeps track if it has been cleaned already so
         * you can call this over and over. However, if you update the element and
         * need to force a reclean, you can pass true.
         */
        clean : function(o){
            if(this.isCleaned && o !== true){
                return  this;
            }
            var  ns = /\S/;
            var  d = this.dom, n = d.firstChild, ni = -1;
            while(n){
                var  nx = n.nextSibling;
                if(n.nodeType == 3 && !ns.test(n.nodeValue)){
                    d.removeChild(n);
                }else {
                    n.nodeIndex = ++ni;
                }

                n = nx;
            }

            this.isCleaned = true;
            return  this;
        },

        // private
        calcOffsetsTo : function(el){
            el = Roo.get(el);
            var  d = el.dom;
            var  q = false;
            if(el.getStyle('position') == 'static'){
                el.position('relative');
                q = true;
            }
            var  x = 0, y =0;
            var  op = this.dom;
            while(op && op != d && op.tagName != 'HTML'){
                x+= op.offsetLeft;
                y+= op.offsetTop;
                op = op.offsetParent;
            }
            if(q){
                el.position('static');
            }
            return  [x, y];
        },

        /**
         * Scrolls this element into view within the passed container.
         * @param {String/HTMLElement/Element} container (optional) The container element to scroll (defaults to document.body)
         * @param {Boolean} hscroll (optional) False to disable horizontal scroll (defaults to true)
         * @return {Roo.Element} this
         */
        scrollIntoView : function(u, v){
            var  c = Roo.getDom(u) || document.body;
            var  el = this.dom;

            var  o = this.calcOffsetsTo(c),
                l = o[0],
                t = o[1],
                b = t+el.offsetHeight,
                r = l+el.offsetWidth;

            var  ch = c.clientHeight;
            var  ct = parseInt(c.scrollTop, 10);
            var  cl = parseInt(c.scrollLeft, 10);
            var  cb = ct + ch;
            var  cr = cl + c.clientWidth;

            if(t < ct){
                c.scrollTop = t;
            }else  if(b > cb){
                c.scrollTop = b-ch;
            }

            if(v !== false){
                if(l < cl){
                    c.scrollLeft = l;
                }else  if(r > cr){
                    c.scrollLeft = r-c.clientWidth;
                }
            }
            return  this;
        },

        // private
        scrollChildIntoView : function(w, z){
            Roo.fly(w, '_scrollChildIntoView').scrollIntoView(this, z);
        },

        /**
         * Measures the element's content height and updates height to match. Note: this function uses setTimeout so
         * the new height may not be available immediately.
         * @param {Boolean} animate (optional) Animate the transition (defaults to false)
         * @param {Float} duration (optional) Length of the animation in seconds (defaults to .35)
         * @param {Function} onComplete (optional) Function to call when animation completes
         * @param {String} easing (optional) Easing method to use (defaults to easeOut)
         * @return {Roo.Element} this
         */
        autoHeight : function(AA, AB, AC, AD){
            var  AE = this.getHeight();
            this.clip();
            this.setHeight(1); // force clipping
            setTimeout(function(){
                var  AG = parseInt(this.dom.scrollHeight, 10); // parseInt for Safari
                if(!AA){
                    this.setHeight(AG);
                    this.unclip();
                    if(typeof  AC == "function"){
                        AC();
                    }
                }else {
                    this.setHeight(AE); // restore original height
                    this.setHeight(AG, AA, AB, function(){
                        this.unclip();
                        if(typeof  AC == "function") AC();
                    }.createDelegate(this), AD);
                }
            }.createDelegate(this), 0);
            return  this;
        },

        /**
         * Returns true if this element is an ancestor of the passed element
         * @param {HTMLElement/String} el The element to check
         * @return {Boolean} True if this element is an ancestor of el, else false
         */
        contains : function(el){
            if(!el){return  false;}
            return  D.isAncestor(this.dom, el.dom ? el.dom : el);
        },

        /**
         * Checks whether the element is currently visible using both visibility and display properties.
         * @param {Boolean} deep (optional) True to walk the dom and see if parent elements are hidden (defaults to false)
         * @return {Boolean} True if the element is currently visible, else false
         */
        isVisible : function(AF) {
            var  AG = !(this.getStyle("visibility") == "hidden" || this.getStyle("display") == "none");
            if(AF !== true || !AG){
                return  AG;
            }
            var  p = this.dom.parentNode;
            while(p && p.tagName.toLowerCase() != "body"){
                if(!Roo.fly(p, '_isVisible').isVisible()){
                    return  false;
                }

                p = p.parentNode;
            }
            return  true;
        },

        /**
         * Creates a {@link Roo.CompositeElement} for child nodes based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} unique (optional) True to create a unique Roo.Element for each child (defaults to false, which creates a single shared flyweight object)
         * @return {CompositeElement/CompositeElementLite} The composite element
         */
        select : function(AH, AI){
            return  El.select(AH, AI, this.dom);
        },

        /**
         * Selects child nodes based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @return {Array} An array of the matched nodes
         */
        query : function(AJ, AK){
            return  Roo.DomQuery.select(AJ, this.dom);
        },

        /**
         * Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} returnDom (optional) True to return the DOM node instead of Roo.Element (defaults to false)
         * @return {HTMLElement/Roo.Element} The child Roo.Element (or DOM node if returnDom = true)
         */
        child : function(AL, AM){
            var  n = Roo.DomQuery.selectNode(AL, this.dom);
            return  AM ? n : Roo.get(n);
        },

        /**
         * Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} returnDom (optional) True to return the DOM node instead of Roo.Element (defaults to false)
         * @return {HTMLElement/Roo.Element} The child Roo.Element (or DOM node if returnDom = true)
         */
        down : function(AN, AO){
            var  n = Roo.DomQuery.selectNode(" > " + AN, this.dom);
            return  AO ? n : Roo.get(n);
        },

        /**
         * Initializes a {@link Roo.dd.DD} drag drop object for this element.
         * @param {String} group The group the DD object is member of
         * @param {Object} config The DD config object
         * @param {Object} overrides An object containing methods to override/implement on the DD object
         * @return {Roo.dd.DD} The DD object
         */
        initDD : function(AP, AQ, AR){
            var  dd = new  Roo.dd.DD(Roo.id(this.dom), AP, AQ);
            return  Roo.apply(dd, AR);
        },

        /**
         * Initializes a {@link Roo.dd.DDProxy} object for this element.
         * @param {String} group The group the DDProxy object is member of
         * @param {Object} config The DDProxy config object
         * @param {Object} overrides An object containing methods to override/implement on the DDProxy object
         * @return {Roo.dd.DDProxy} The DDProxy object
         */
        initDDProxy : function(AS, AT, AU){
            var  dd = new  Roo.dd.DDProxy(Roo.id(this.dom), AS, AT);
            return  Roo.apply(dd, AU);
        },

        /**
         * Initializes a {@link Roo.dd.DDTarget} object for this element.
         * @param {String} group The group the DDTarget object is member of
         * @param {Object} config The DDTarget config object
         * @param {Object} overrides An object containing methods to override/implement on the DDTarget object
         * @return {Roo.dd.DDTarget} The DDTarget object
         */
        initDDTarget : function(AV, AW, AX){
            var  dd = new  Roo.dd.DDTarget(Roo.id(this.dom), AV, AW);
            return  Roo.apply(dd, AX);
        },

        /**
         * Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
         * the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.
         * @param {Boolean} visible Whether the element is visible
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
         setVisible : function(AY, AZ){
            if(!AZ || !A){
                if(this.visibilityMode == El.DISPLAY){
                    this.setDisplayed(AY);
                }else {
                    this.fixDisplay();
                    this.dom.style.visibility = AY ? "visible" : "hidden";
                }
            }else {
                // closure for composites
                var  dom = this.dom;
                var  J = this.visibilityMode;
                if(AY){
                    this.setOpacity(.01);
                    this.setVisible(true);
                }

                this.anim({opacity: { to: (AY?1:0) }},
                      this.preanim(arguments, 1),
                      null, .35, 'easeIn', function(){
                         if(!AY){
                             if(J == El.DISPLAY){
                                 dom.style.display = "none";
                             }else {
                                 dom.style.visibility = "hidden";
                             }

                             Roo.get(dom).setOpacity(1);
                         }
                     });
            }
            return  this;
        },

        /**
         * Returns true if display is not "none"
         * @return {Boolean}
         */
        isDisplayed : function() {
            return  this.getStyle("display") != "none";
        },

        /**
         * Toggles the element's visibility or display, depending on visibility mode.
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        toggle : function(Aa){
            this.setVisible(!this.isVisible(), this.preanim(arguments, 0));
            return  this;
        },

        /**
         * Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.
         * @param {Boolean} value Boolean value to display the element using its default display, or a string to set the display directly
         * @return {Roo.Element} this
         */
        setDisplayed : function(Ab) {
            if(typeof  Ab == "boolean"){
               Ab = Ab ? this.originalDisplay : "none";
            }

            this.setStyle("display", Ab);
            return  this;
        },

        /**
         * Tries to focus the element. Any exceptions are caught and ignored.
         * @return {Roo.Element} this
         */
        focus : function() {
            try{
                this.dom.focus();
            }catch(e){}
            return  this;
        },

        /**
         * Tries to blur the element. Any exceptions are caught and ignored.
         * @return {Roo.Element} this
         */
        blur : function() {
            try{
                this.dom.blur();
            }catch(e){}
            return  this;
        },

        /**
         * Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.
         * @param {String/Array} className The CSS class to add, or an array of classes
         * @return {Roo.Element} this
         */
        addClass : function(Ac){
            if(Ac  instanceof  Array){
                for(var  i = 0, len = Ac.length; i < len; i++) {
                    this.addClass(Ac[i]);
                }
            }else {
                if(Ac && !this.hasClass(Ac)){
                    this.dom.className = this.dom.className + " " + Ac;
                }
            }
            return  this;
        },

        /**
         * Adds one or more CSS classes to this element and removes the same class(es) from all siblings.
         * @param {String/Array} className The CSS class to add, or an array of classes
         * @return {Roo.Element} this
         */
        radioClass : function(Ad){
            var  Ae = this.dom.parentNode.childNodes;
            for(var  i = 0; i < Ae.length; i++) {
                var  s = Ae[i];
                if(s.nodeType == 1){
                    Roo.get(s).removeClass(Ad);
                }
            }

            this.addClass(Ad);
            return  this;
        },

        /**
         * Removes one or more CSS classes from the element.
         * @param {String/Array} className The CSS class to remove, or an array of classes
         * @return {Roo.Element} this
         */
        removeClass : function(Af){
            if(!Af || !this.dom.className){
                return  this;
            }
            if(Af  instanceof  Array){
                for(var  i = 0, len = Af.length; i < len; i++) {
                    this.removeClass(Af[i]);
                }
            }else {
                if(this.hasClass(Af)){
                    var  re = this.classReCache[Af];
                    if (!re) {
                       re = new  RegExp('(?:^|\\s+)' + Af + '(?:\\s+|$)', "g");
                       this.classReCache[Af] = re;
                    }

                    this.dom.className =
                        this.dom.className.replace(re, " ");
                }
            }
            return  this;
        },

        // private
        classReCache: {},

        /**
         * Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).
         * @param {String} className The CSS class to toggle
         * @return {Roo.Element} this
         */
        toggleClass : function(Ag){
            if(this.hasClass(Ag)){
                this.removeClass(Ag);
            }else {
                this.addClass(Ag);
            }
            return  this;
        },

        /**
         * Checks if the specified CSS class exists on this element's DOM node.
         * @param {String} className The CSS class to check for
         * @return {Boolean} True if the class exists, else false
         */
        hasClass : function(Ah){
            return  Ah && (' '+this.dom.className+' ').indexOf(' '+Ah+' ') != -1;
        },

        /**
         * Replaces a CSS class on the element with another.  If the old name does not exist, the new name will simply be added.
         * @param {String} oldClassName The CSS class to replace
         * @param {String} newClassName The replacement CSS class
         * @return {Roo.Element} this
         */
        replaceClass : function(Ai, Aj){
            this.removeClass(Ai);
            this.addClass(Aj);
            return  this;
        },

        /**
         * Returns an object with properties matching the styles requested.
         * For example, el.getStyles('color', 'font-size', 'width') might return
         * {'color': '#FFFFFF', 'font-size': '13px', 'width': '100px'}.
         * @param {String} style1 A style name
         * @param {String} style2 A style name
         * @param {String} etc.
         * @return {Object} The style object
         */
        getStyles : function(){
            var  a = arguments, Ak = a.length, r = {};
            for(var  i = 0; i < Ak; i++){
                r[a[i]] = this.getStyle(a[i]);
            }
            return  r;
        },

        /**
         * Normalizes currentStyle and computedStyle. This is not YUI getStyle, it is an optimised version.
         * @param {String} property The style property whose value is returned.
         * @return {String} The current value of the style property for this element.
         */
        getStyle : function(){
            return  G && G.getComputedStyle ?
                function(Al){
                    var  el = this.dom, v, cs, Am;
                    if(Al == 'float'){
                        Al = "cssFloat";
                    }
                    if(el.style && (v = el.style[Al])){
                        return  v;
                    }
                    if(cs = G.getComputedStyle(el, "")){
                        if(!(Am = B[Al])){
                            Am = B[Al] = Al.replace(C, F);
                        }
                        return  cs[Am];
                    }
                    return  null;
                } :
                function(Al){
                    var  el = this.dom, v, cs, Am;
                    if(Al == 'opacity'){
                        if(typeof  el.style.filter == 'string'){
                            var  m = el.style.filter.match(/alpha\(opacity=(.*)\)/i);
                            if(m){
                                var  fv = parseFloat(m[1]);
                                if(!isNaN(fv)){
                                    return  fv ? fv / 100 : 0;
                                }
                            }
                        }
                        return  1;
                    }else  if(Al == 'float'){
                        Al = "styleFloat";
                    }
                    if(!(Am = B[Al])){
                        Am = B[Al] = Al.replace(C, F);
                    }
                    if(v = el.style[Am]){
                        return  v;
                    }
                    if(cs = el.currentStyle){
                        return  cs[Am];
                    }
                    return  null;
                };
        }(),

        /**
         * Wrapper for setting style properties, also takes single object parameter of multiple styles.
         * @param {String/Object} property The style property to be set, or an object of multiple styles.
         * @param {String} value (optional) The value to apply to the given property, or null if an object was passed.
         * @return {Roo.Element} this
         */
        setStyle : function(Al, Am){
            if(typeof  Al == "string"){
                var  camel;
                if(!(camel = B[Al])){
                    camel = B[Al] = Al.replace(C, F);
                }
                if(camel == 'opacity') {
                    this.setOpacity(Am);
                }else {
                    this.dom.style[camel] = Am;
                }
            }else {
                for(var  style  in  Al){
                    if(typeof  Al[style] != "function"){
                       this.setStyle(style, Al[style]);
                    }
                }
            }
            return  this;
        },

        /**
         * More flexible version of {@link #setStyle} for setting style properties.
         * @param {String/Object/Function} styles A style specification string, e.g. "width:100px", or object in the form {width:"100px"}, or
         * a function which returns such a specification.
         * @return {Roo.Element} this
         */
        applyStyles : function(An){
            Roo.DomHelper.applyStyles(this.dom, An);
            return  this;
        },

        /**
          * Gets the current X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
          * @return {Number} The X position of the element
          */
        getX : function(){
            return  D.getX(this.dom);
        },

        /**
          * Gets the current Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
          * @return {Number} The Y position of the element
          */
        getY : function(){
            return  D.getY(this.dom);
        },

        /**
          * Gets the current position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
          * @return {Array} The XY position of the element
          */
        getXY : function(){
            return  D.getXY(this.dom);
        },

        /**
         * Sets the X position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @param {Number} The X position of the element
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setX : function(x, Ao){
            if(!Ao || !A){
                D.setX(this.dom, x);
            }else {
                this.setXY([x, this.getY()], this.preanim(arguments, 1));
            }
            return  this;
        },

        /**
         * Sets the Y position of the element based on page coordinates.  Element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @param {Number} The Y position of the element
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setY : function(y, Ap){
            if(!Ap || !A){
                D.setY(this.dom, y);
            }else {
                this.setXY([this.getX(), y], this.preanim(arguments, 1));
            }
            return  this;
        },

        /**
         * Sets the element's left position directly using CSS style (instead of {@link #setX}).
         * @param {String} left The left CSS property value
         * @return {Roo.Element} this
         */
        setLeft : function(Aq){
            this.setStyle("left", this.addUnits(Aq));
            return  this;
        },

        /**
         * Sets the element's top position directly using CSS style (instead of {@link #setY}).
         * @param {String} top The top CSS property value
         * @return {Roo.Element} this
         */
        setTop : function(Ar){
            this.setStyle("top", this.addUnits(Ar));
            return  this;
        },

        /**
         * Sets the element's CSS right style.
         * @param {String} right The right CSS property value
         * @return {Roo.Element} this
         */
        setRight : function(As){
            this.setStyle("right", this.addUnits(As));
            return  this;
        },

        /**
         * Sets the element's CSS bottom style.
         * @param {String} bottom The bottom CSS property value
         * @return {Roo.Element} this
         */
        setBottom : function(At){
            this.setStyle("bottom", this.addUnits(At));
            return  this;
        },

        /**
         * Sets the position of the element in page coordinates, regardless of how the element is positioned.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @param {Array} pos Contains X & Y [x, y] values for new position (coordinates are page-based)
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setXY : function(Au, Av){
            if(!Av || !A){
                D.setXY(this.dom, Au);
            }else {
                this.anim({points: {to: Au}}, this.preanim(arguments, 1), 'motion');
            }
            return  this;
        },

        /**
         * Sets the position of the element in page coordinates, regardless of how the element is positioned.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @param {Number} x X value for new position (coordinates are page-based)
         * @param {Number} y Y value for new position (coordinates are page-based)
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setLocation : function(x, y, Aw){
            this.setXY([x, y], this.preanim(arguments, 2));
            return  this;
        },

        /**
         * Sets the position of the element in page coordinates, regardless of how the element is positioned.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @param {Number} x X value for new position (coordinates are page-based)
         * @param {Number} y Y value for new position (coordinates are page-based)
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Roo.Element} this
         */
        moveTo : function(x, y, Ax){
            this.setXY([x, y], this.preanim(arguments, 2));
            return  this;
        },

        /**
         * Returns the region of the given element.
         * The element must be part of the DOM tree to have a region (display:none or elements not appended return false).
         * @return {Region} A Roo.lib.Region containing "top, left, bottom, right" member data.
         */
        getRegion : function(){
            return  D.getRegion(this.dom);
        },

        /**
         * Returns the offset height of the element
         * @param {Boolean} contentHeight (optional) true to get the height minus borders and padding
         * @return {Number} The element's height
         */
        getHeight : function(Ay){
            var  h = this.dom.offsetHeight || 0;
            return  Ay !== true ? h : h-this.getBorderWidth("tb")-this.getPadding("tb");
        },

        /**
         * Returns the offset width of the element
         * @param {Boolean} contentWidth (optional) true to get the width minus borders and padding
         * @return {Number} The element's width
         */
        getWidth : function(Az){
            var  w = this.dom.offsetWidth || 0;
            return  Az !== true ? w : w-this.getBorderWidth("lr")-this.getPadding("lr");
        },

        /**
         * Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders
         * when needed to simulate offsetHeight when offsets aren't available. This may not work on display:none elements
         * if a height has not been set using CSS.
         * @return {Number}
         */
        getComputedHeight : function(){
            var  h = Math.max(this.dom.offsetHeight, this.dom.clientHeight);
            if(!h){
                h = parseInt(this.getStyle('height'), 10) || 0;
                if(!this.isBorderBox()){
                    h += this.getFrameWidth('tb');
                }
            }
            return  h;
        },

        /**
         * Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders
         * when needed to simulate offsetWidth when offsets aren't available. This may not work on display:none elements
         * if a width has not been set using CSS.
         * @return {Number}
         */
        getComputedWidth : function(){
            var  w = Math.max(this.dom.offsetWidth, this.dom.clientWidth);
            if(!w){
                w = parseInt(this.getStyle('width'), 10) || 0;
                if(!this.isBorderBox()){
                    w += this.getFrameWidth('lr');
                }
            }
            return  w;
        },

        /**
         * Returns the size of the element.
         * @param {Boolean} contentSize (optional) true to get the width/size minus borders and padding
         * @return {Object} An object containing the element's size {width: (element width), height: (element height)}
         */
        getSize : function(A0){
            return  {width: this.getWidth(A0), height: this.getHeight(A0)};
        },

        /**
         * Returns the width and height of the viewport.
         * @return {Object} An object containing the viewport's size {width: (viewport width), height: (viewport height)}
         */
        getViewSize : function(){
            var  d = this.dom, A1 = document, aw = 0, ah = 0;
            if(d == A1 || d == A1.body){
                return  {width : D.getViewWidth(), height: D.getViewHeight()};
            }else {
                return  {
                    width : d.clientWidth,
                    height: d.clientHeight
                };
            }
        },

        /**
         * Returns the value of the "value" attribute
         * @param {Boolean} asNumber true to parse the value as a number
         * @return {String/Number}
         */
        getValue : function(A2){
            return  A2 ? parseInt(this.dom.value, 10) : this.dom.value;
        },

        // private
        adjustWidth : function(A3){
            if(typeof  A3 == "number"){
                if(this.autoBoxAdjust && !this.isBorderBox()){
                   A3 -= (this.getBorderWidth("lr") + this.getPadding("lr"));
                }
                if(A3 < 0){
                    A3 = 0;
                }
            }
            return  A3;
        },

        // private
        adjustHeight : function(A4){
            if(typeof  A4 == "number"){
               if(this.autoBoxAdjust && !this.isBorderBox()){
                   A4 -= (this.getBorderWidth("tb") + this.getPadding("tb"));
               }
               if(A4 < 0){
                   A4 = 0;
               }
            }
            return  A4;
        },

        /**
         * Set the width of the element
         * @param {Number} width The new width
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setWidth : function(A5, A6){
            A5 = this.adjustWidth(A5);
            if(!A6 || !A){
                this.dom.style.width = this.addUnits(A5);
            }else {
                this.anim({width: {to: A5}}, this.preanim(arguments, 1));
            }
            return  this;
        },

        /**
         * Set the height of the element
         * @param {Number} height The new height
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
         setHeight : function(A7, A8){
            A7 = this.adjustHeight(A7);
            if(!A8 || !A){
                this.dom.style.height = this.addUnits(A7);
            }else {
                this.anim({height: {to: A7}}, this.preanim(arguments, 1));
            }
            return  this;
        },

        /**
         * Set the size of the element. If animation is true, both width an height will be animated concurrently.
         * @param {Number} width The new width
         * @param {Number} height The new height
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
         setSize : function(A9, BA, BB){
            if(typeof  A9 == "object"){ // in case of object from getSize()
                BA = A9.height; A9 = A9.width;
            }

            A9 = this.adjustWidth(A9); BA = this.adjustHeight(BA);
            if(!BB || !A){
                this.dom.style.width = this.addUnits(A9);
                this.dom.style.height = this.addUnits(BA);
            }else {
                this.anim({width: {to: A9}, height: {to: BA}}, this.preanim(arguments, 2));
            }
            return  this;
        },

        /**
         * Sets the element's position and size in one shot. If animation is true then width, height, x and y will be animated concurrently.
         * @param {Number} x X value for new position (coordinates are page-based)
         * @param {Number} y Y value for new position (coordinates are page-based)
         * @param {Number} width The new width
         * @param {Number} height The new height
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setBounds : function(x, y, BC, BD, BE){
            if(!BE || !A){
                this.setSize(BC, BD);
                this.setLocation(x, y);
            }else {
                BC = this.adjustWidth(BC); BD = this.adjustHeight(BD);
                this.anim({points: {to: [x, y]}, width: {to: BC}, height: {to: BD}},
                              this.preanim(arguments, 4), 'motion');
            }
            return  this;
        },

        /**
         * Sets the element's position and size the the specified region. If animation is true then width, height, x and y will be animated concurrently.
         * @param {Roo.lib.Region} region The region to fill
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setRegion : function(BF, BG){
            this.setBounds(BF.left, BF.top, BF.right-BF.left, BF.bottom-BF.top, this.preanim(arguments, 1));
            return  this;
        },

        /**
         * Appends an event handler
         *
         * @param {String}   eventName     The type of event to append
         * @param {Function} fn        The method the event invokes
         * @param {Object} scope       (optional) The scope (this object) of the fn
         * @param {Object}   options   (optional)An object with standard {@link Roo.EventManager#addListener} options
         */
        addListener : function(BH, fn, BI, BJ){
            Roo.EventManager.on(this.dom,  BH, fn, BI || this, BJ);
        },

        /**
         * Removes an event handler from this element
         * @param {String} eventName the type of event to remove
         * @param {Function} fn the method the event invokes
         * @return {Roo.Element} this
         */
        removeListener : function(BK, fn){
            Roo.EventManager.removeListener(this.dom,  BK, fn);
            return  this;
        },

        /**
         * Removes all previous added listeners from this element
         * @return {Roo.Element} this
         */
        removeAllListeners : function(){
            E.purgeElement(this.dom);
            return  this;
        },

        relayEvent : function(BL, BM){
            this.on(BL, function(e){
                BM.fireEvent(BL, e);
            });
        },

        /**
         * Set the opacity of the element
         * @param {Float} opacity The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
         setOpacity : function(BN, BO){
            if(!BO || !A){
                var  s = this.dom.style;
                if(Roo.isIE){
                    s.zoom = 1;
                    s.filter = (s.filter || '').replace(/alpha\([^\)]*\)/gi,"") +
                               (BN == 1 ? "" : "alpha(opacity=" + BN * 100 + ")");
                }else {
                    s.opacity = BN;
                }
            }else {
                this.anim({opacity: {to: BN}}, this.preanim(arguments, 1), null, .35, 'easeIn');
            }
            return  this;
        },

        /**
         * Gets the left X coordinate
         * @param {Boolean} local True to get the local css position instead of page coordinate
         * @return {Number}
         */
        getLeft : function(BP){
            if(!BP){
                return  this.getX();
            }else {
                return  parseInt(this.getStyle("left"), 10) || 0;
            }
        },

        /**
         * Gets the right X coordinate of the element (element X position + element width)
         * @param {Boolean} local True to get the local css position instead of page coordinate
         * @return {Number}
         */
        getRight : function(BQ){
            if(!BQ){
                return  this.getX() + this.getWidth();
            }else {
                return  (this.getLeft(true) + this.getWidth()) || 0;
            }
        },

        /**
         * Gets the top Y coordinate
         * @param {Boolean} local True to get the local css position instead of page coordinate
         * @return {Number}
         */
        getTop : function(BR) {
            if(!BR){
                return  this.getY();
            }else {
                return  parseInt(this.getStyle("top"), 10) || 0;
            }
        },

        /**
         * Gets the bottom Y coordinate of the element (element Y position + element height)
         * @param {Boolean} local True to get the local css position instead of page coordinate
         * @return {Number}
         */
        getBottom : function(BS){
            if(!BS){
                return  this.getY() + this.getHeight();
            }else {
                return  (this.getTop(true) + this.getHeight()) || 0;
            }
        },

        /**
        * Initializes positioning on this element. If a desired position is not passed, it will make the
        * the element positioned relative IF it is not already positioned.
        * @param {String} pos (optional) Positioning to use "relative", "absolute" or "fixed"
        * @param {Number} zIndex (optional) The zIndex to apply
        * @param {Number} x (optional) Set the page X position
        * @param {Number} y (optional) Set the page Y position
        */
        position : function(BT, BU, x, y){
            if(!BT){
               if(this.getStyle('position') == 'static'){
                   this.setStyle('position', 'relative');
               }
            }else {
                this.setStyle("position", BT);
            }
            if(BU){
                this.setStyle("z-index", BU);
            }
            if(x !== undefined && y !== undefined){
                this.setXY([x, y]);
            }else  if(x !== undefined){
                this.setX(x);
            }else  if(y !== undefined){
                this.setY(y);
            }
        },

        /**
        * Clear positioning back to the default when the document was loaded
        * @param {String} value (optional) The value to use for the left,right,top,bottom, defaults to '' (empty string). You could use 'auto'.
        * @return {Roo.Element} this
         */
        clearPositioning : function(BV){
            BV = BV ||'';
            this.setStyle({
                "left": BV,
                "right": BV,
                "top": BV,
                "bottom": BV,
                "z-index": "",
                "position" : "static"
            });
            return  this;
        },

        /**
        * Gets an object with all CSS positioning properties. Useful along with setPostioning to get
        * snapshot before performing an update and then restoring the element.
        * @return {Object}
        */
        getPositioning : function(){
            var  l = this.getStyle("left");
            var  t = this.getStyle("top");
            return  {
                "position" : this.getStyle("position"),
                "left" : l,
                "right" : l ? "" : this.getStyle("right"),
                "top" : t,
                "bottom" : t ? "" : this.getStyle("bottom"),
                "z-index" : this.getStyle("z-index")
            };
        },

        /**
         * Gets the width of the border(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing lr would get the border (l)eft width + the border (r)ight width.
         * @return {Number} The width of the sides passed added together
         */
        getBorderWidth : function(BW){
            return  this.addStyles(BW, El.borders);
        },

        /**
         * Gets the width of the padding(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing lr would get the padding (l)eft + the padding (r)ight.
         * @return {Number} The padding of the sides passed added together
         */
        getPadding : function(BX){
            return  this.addStyles(BX, El.paddings);
        },

        /**
        * Set positioning with an object returned by getPositioning().
        * @param {Object} posCfg
        * @return {Roo.Element} this
         */
        setPositioning : function(pc){
            this.applyStyles(pc);
            if(pc.right == "auto"){
                this.dom.style.right = "";
            }
            if(pc.bottom == "auto"){
                this.dom.style.bottom = "";
            }
            return  this;
        },

        // private
        fixDisplay : function(){
            if(this.getStyle("display") == "none"){
                this.setStyle("visibility", "hidden");
                this.setStyle("display", this.originalDisplay); // first try reverting to default
                if(this.getStyle("display") == "none"){ // if that fails, default to block
                    this.setStyle("display", "block");
                }
            }
        },

        /**
         * Quick set left and top adding default units
         * @param {String} left The left CSS property value
         * @param {String} top The top CSS property value
         * @return {Roo.Element} this
         */
         setLeftTop : function(BY, BZ){
            this.dom.style.left = this.addUnits(BY);
            this.dom.style.top = this.addUnits(BZ);
            return  this;
        },

        /**
         * Move this element relative to its current position.
         * @param {String} direction Possible values are: "l","left" - "r","right" - "t","top","up" - "b","bottom","down".
         * @param {Number} distance How far to move the element in pixels
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
         move : function(Ba, Bb, Bc){
            var  xy = this.getXY();
            Ba = Ba.toLowerCase();
            switch(Ba){
                case  "l":
                case  "left":
                    this.moveTo(xy[0]-Bb, xy[1], this.preanim(arguments, 2));
                    break;
               case  "r":
               case  "right":
                    this.moveTo(xy[0]+Bb, xy[1], this.preanim(arguments, 2));
                    break;
               case  "t":
               case  "top":
               case  "up":
                    this.moveTo(xy[0], xy[1]-Bb, this.preanim(arguments, 2));
                    break;
               case  "b":
               case  "bottom":
               case  "down":
                    this.moveTo(xy[0], xy[1]+Bb, this.preanim(arguments, 2));
                    break;
            }
            return  this;
        },

        /**
         *  Store the current overflow setting and clip overflow on the element - use {@link #unclip} to remove
         * @return {Roo.Element} this
         */
        clip : function(){
            if(!this.isClipped){
               this.isClipped = true;
               this.originalClip = {
                   "o": this.getStyle("overflow"),
                   "x": this.getStyle("overflow-x"),
                   "y": this.getStyle("overflow-y")
               };
               this.setStyle("overflow", "hidden");
               this.setStyle("overflow-x", "hidden");
               this.setStyle("overflow-y", "hidden");
            }
            return  this;
        },

        /**
         *  Return clipping (overflow) to original clipping before clip() was called
         * @return {Roo.Element} this
         */
        unclip : function(){
            if(this.isClipped){
                this.isClipped = false;
                var  o = this.originalClip;
                if(o.o){this.setStyle("overflow", o.o);}
                if(o.x){this.setStyle("overflow-x", o.x);}
                if(o.y){this.setStyle("overflow-y", o.y);}
            }
            return  this;
        },


        /**
         * Gets the x,y coordinates specified by the anchor position on the element.
         * @param {String} anchor (optional) The specified anchor position (defaults to "c").  See {@link #alignTo} for details on supported anchor positions.
         * @param {Object} size (optional) An object containing the size to use for calculating anchor position
         *                       {width: (target width), height: (target height)} (defaults to the element's current size)
         * @param {Boolean} local (optional) True to get the local (element top/left-relative) anchor position instead of page coordinates
         * @return {Array} [x, y] An array containing the element's x and y coordinates
         */
        getAnchorXY : function(Bd, Be, s){
            //Passing a different size is useful for pre-calculating anchors,
            //especially for anchored animations that change the el size.

            var  w, h, vp = false;
            if(!s){
                var  d = this.dom;
                if(d == document.body || d == document){
                    vp = true;
                    w = D.getViewWidth(); h = D.getViewHeight();
                }else {
                    w = this.getWidth(); h = this.getHeight();
                }
            }else {
                w = s.width;  h = s.height;
            }
            var  x = 0, y = 0, r = Math.round;
            switch((Bd || "tl").toLowerCase()){
                case  "c":
                    x = r(w*.5);
                    y = r(h*.5);
                break;
                case  "t":
                    x = r(w*.5);
                    y = 0;
                break;
                case  "l":
                    x = 0;
                    y = r(h*.5);
                break;
                case  "r":
                    x = w;
                    y = r(h*.5);
                break;
                case  "b":
                    x = r(w*.5);
                    y = h;
                break;
                case  "tl":
                    x = 0;
                    y = 0;
                break;
                case  "bl":
                    x = 0;
                    y = h;
                break;
                case  "br":
                    x = w;
                    y = h;
                break;
                case  "tr":
                    x = w;
                    y = 0;
                break;
            }
            if(Be === true){
                return  [x, y];
            }
            if(vp){
                var  sc = this.getScroll();
                return  [x + sc.left, y + sc.top];
            }
            //Add the element's offset xy
            var  o = this.getXY();
            return  [x+o[0], y+o[1]];
        },

        /**
         * Gets the x,y coordinates to align this element with another element. See {@link #alignTo} for more info on the
         * supported position values.
         * @param {String/HTMLElement/Roo.Element} element The element to align to.
         * @param {String} position The position to align to.
         * @param {Array} offsets (optional) Offset the positioning by [x, y]
         * @return {Array} [x, y]
         */
        getAlignToXY : function(el, p, o){
            el = Roo.get(el);
            var  d = this.dom;
            if(!el.dom){
                throw  "Element.alignTo with an element that doesn't exist";
            }
            var  c = false; //constrain to viewport
            var  p1 = "", p2 = "";
            o = o || [0,0];

            if(!p){
                p = "tl-bl";
            }else  if(p == "?"){
                p = "tl-bl?";
            }else  if(p.indexOf("-") == -1){
                p = "tl-" + p;
            }

            p = p.toLowerCase();
            var  m = p.match(/^([a-z]+)-([a-z]+)(\?)?$/);
            if(!m){
               throw  "Element.alignTo with an invalid alignment " + p;
            }

            p1 = m[1]; p2 = m[2]; c = !!m[3];

            //Subtract the aligned el's internal xy from the target's offset xy
            //plus custom offset to get the aligned el's new offset xy
            var  a1 = this.getAnchorXY(p1, true);
            var  a2 = el.getAnchorXY(p2, false);
            var  x = a2[0] - a1[0] + o[0];
            var  y = a2[1] - a1[1] + o[1];
            if(c){
                //constrain the aligned el to viewport if necessary
                var  w = this.getWidth(), h = this.getHeight(), r = el.getRegion();
                // 5px of margin for ie
                var  dw = D.getViewWidth()-5, dh = D.getViewHeight()-5;

                //If we are at a viewport boundary and the aligned el is anchored on a target border that is
                //perpendicular to the vp border, allow the aligned el to slide on that border,
                //otherwise swap the aligned el to the opposite border of the target.
                var  p1y = p1.charAt(0), p1x = p1.charAt(p1.length-1);
               var  p2y = p2.charAt(0), p2x = p2.charAt(p2.length-1);
               var  swapY = ((p1y=="t" && p2y=="b") || (p1y=="b" && p2y=="t"));
               var  swapX = ((p1x=="r" && p2x=="l") || (p1x=="l" && p2x=="r"));

               var  A1 = document;
               var  scrollX = (A1.documentElement.scrollLeft || A1.body.scrollLeft || 0)+5;
               var  scrollY = (A1.documentElement.scrollTop || A1.body.scrollTop || 0)+5;

               if((x+w) > dw + scrollX){
                    x = swapX ? r.left-w : dw+scrollX-w;
                }
               if(x < scrollX){
                   x = swapX ? r.right : scrollX;
               }
               if((y+h) > dh + scrollY){
                    y = swapY ? r.top-h : dh+scrollY-h;
                }
               if (y < scrollY){
                   y = swapY ? r.bottom : scrollY;
               }
            }
            return  [x,y];
        },

        // private
        getConstrainToXY : function(){
            var  os = {top:0, left:0, bottom:0, right: 0};

            return  function(el, Bf, Bg, Bh){
                el = Roo.get(el);
                Bg = Bg ? Roo.applyIf(Bg, os) : os;

                var  vw, vh, vx = 0, vy = 0;
                if(el.dom == document.body || el.dom == document){
                    vw = Roo.lib.Dom.getViewWidth();
                    vh = Roo.lib.Dom.getViewHeight();
                }else {
                    vw = el.dom.clientWidth;
                    vh = el.dom.clientHeight;
                    if(!Bf){
                        var  vxy = el.getXY();
                        vx = vxy[0];
                        vy = vxy[1];
                    }
                }

                var  s = el.getScroll();

                vx += Bg.left + s.left;
                vy += Bg.top + s.top;

                vw -= Bg.right;
                vh -= Bg.bottom;

                var  vr = vx+vw;
                var  vb = vy+vh;

                var  xy = Bh || (!Bf ? this.getXY() : [this.getLeft(true), this.getTop(true)]);
                var  x = xy[0], y = xy[1];
                var  w = this.dom.offsetWidth, h = this.dom.offsetHeight;

                // only move it if it needs it
                var  Bi = false;

                // first validate right/bottom
                if((x + w) > vr){
                    x = vr - w;
                    Bi = true;
                }
                if((y + h) > vb){
                    y = vb - h;
                    Bi = true;
                }
                // then make sure top/left isn't negative
                if(x < vx){
                    x = vx;
                    Bi = true;
                }
                if(y < vy){
                    y = vy;
                    Bi = true;
                }
                return  Bi ? [x, y] : false;
            };
        }(),

        // private
        adjustForConstraints : function(xy, Bf, Bg){
            return  this.getConstrainToXY(Bf || document, false, Bg, xy) ||  xy;
        },

        /**
         * Aligns this element with another element relative to the specified anchor points. If the other element is the
         * document it aligns it to the viewport.
         * The position parameter is optional, and can be specified in any one of the following formats:
         * <ul>
         *   <li><b>Blank</b>: Defaults to aligning the element's top-left corner to the target's bottom-left corner ("tl-bl").</li>
         *   <li><b>One anchor (deprecated)</b>: The passed anchor position is used as the target element's anchor point.
         *       The element being aligned will position its top-left corner (tl) to that point.  <i>This method has been
         *       deprecated in favor of the newer two anchor syntax below</i>.</li>
         *   <li><b>Two anchors</b>: If two values from the table below are passed separated by a dash, the first value is used as the
         *       element's anchor point, and the second value is used as the target's anchor point.</li>
         * </ul>
         * In addition to the anchor points, the position parameter also supports the "?" character.  If "?" is passed at the end of
         * the position string, the element will attempt to align as specified, but the position will be adjusted to constrain to
         * the viewport if necessary.  Note that the element being aligned might be swapped to align to a different position than
         * that specified in order to enforce the viewport constraints.
         * Following are all of the supported anchor positions:
    <pre>
    Value  Description
    -----  -----------------------------
    tl     The top left corner (default)
    t      The center of the top edge
    tr     The top right corner
    l      The center of the left edge
    c      In the center of the element
    r      The center of the right edge
    bl     The bottom left corner
    b      The center of the bottom edge
    br     The bottom right corner
    </pre>
    Example Usage:
    <pre><code>
    // align el to other-el using the default positioning ("tl-bl", non-constrained)
    el.alignTo("other-el");

    // align the top left corner of el with the top right corner of other-el (constrained to viewport)
    el.alignTo("other-el", "tr?");

    // align the bottom right corner of el with the center left edge of other-el
    el.alignTo("other-el", "br-l?");

    // align the center of el with the bottom left corner of other-el and
    // adjust the x position by -6 pixels (and the y position by 0)
    el.alignTo("other-el", "c-bl", [-6, 0]);
    </code></pre>
         * @param {String/HTMLElement/Roo.Element} element The element to align to.
         * @param {String} position The position to align to.
         * @param {Array} offsets (optional) Offset the positioning by [x, y]
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        alignTo : function(Bh, Bi, Bj, Bk){
            var  xy = this.getAlignToXY(Bh, Bi, Bj);
            this.setXY(xy, this.preanim(arguments, 3));
            return  this;
        },

        /**
         * Anchors an element to another element and realigns it when the window is resized.
         * @param {String/HTMLElement/Roo.Element} element The element to align to.
         * @param {String} position The position to align to.
         * @param {Array} offsets (optional) Offset the positioning by [x, y]
         * @param {Boolean/Object} animate (optional) True for the default animation or a standard Element animation config object
         * @param {Boolean/Number} monitorScroll (optional) True to monitor body scroll and reposition. If this parameter
         * is a number, it is used as the buffer delay (defaults to 50ms).
         * @param {Function} callback The function to call after the animation finishes
         * @return {Roo.Element} this
         */
        anchorTo : function(el, Bl, Bm, Bn, Bo, Bp){
            var  Bq = function(){
                this.alignTo(el, Bl, Bm, Bn);
                Roo.callback(Bp, this);
            };
            Roo.EventManager.onWindowResize(Bq, this);
            var  tm = typeof  Bo;
            if(tm != 'undefined'){
                Roo.EventManager.on(window, 'scroll', Bq, this,
                    {buffer: tm == 'number' ? Bo : 50});
            }

            Bq.call(this); // align immediately
            return  this;
        },
        /**
         * Clears any opacity settings from this element. Required in some cases for IE.
         * @return {Roo.Element} this
         */
        clearOpacity : function(){
            if (window.ActiveXObject) {
                if(typeof  this.dom.style.filter == 'string' && (/alpha/i).test(this.dom.style.filter)){
                    this.dom.style.filter = "";
                }
            } else  {
                this.dom.style.opacity = "";
                this.dom.style["-moz-opacity"] = "";
                this.dom.style["-khtml-opacity"] = "";
            }
            return  this;
        },

        /**
         * Hide this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        hide : function(Br){
            this.setVisible(false, this.preanim(arguments, 0));
            return  this;
        },

        /**
        * Show this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
        * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        show : function(Bs){
            this.setVisible(true, this.preanim(arguments, 0));
            return  this;
        },

        /**
         * @private Test if size has a unit, otherwise appends the default
         */
        addUnits : function(Bt){
            return  Roo.Element.addUnits(Bt, this.defaultUnit);
        },

        /**
         * Temporarily enables offsets (width,height,x,y) for an element with display:none, use endMeasure() when done.
         * @return {Roo.Element} this
         */
        beginMeasure : function(){
            var  el = this.dom;
            if(el.offsetWidth || el.offsetHeight){
                return  this; // offsets work already
            }
            var  Bu = [];
            var  p = this.dom, b = document.body; // start with this element
            while((!el.offsetWidth && !el.offsetHeight) && p && p.tagName && p != b){
                var  pe = Roo.get(p);
                if(pe.getStyle('display') == 'none'){
                    Bu.push({el: p, visibility: pe.getStyle("visibility")});
                    p.style.visibility = "hidden";
                    p.style.display = "block";
                }

                p = p.parentNode;
            }

            this._measureChanged = Bu;
            return  this;

        },

        /**
         * Restores displays to before beginMeasure was called
         * @return {Roo.Element} this
         */
        endMeasure : function(){
            var  Bv = this._measureChanged;
            if(Bv){
                for(var  i = 0, Ak = Bv.length; i < Ak; i++) {
                    var  r = Bv[i];
                    r.el.style.visibility = r.visibility;
                    r.el.style.display = "none";
                }

                this._measureChanged = null;
            }
            return  this;
        },

        /**
        * Update the innerHTML of this element, optionally searching for and processing scripts
        * @param {String} html The new HTML
        * @param {Boolean} loadScripts (optional) true to look for and process scripts
        * @param {Function} callback For async script loading you can be noticed when the update completes
        * @return {Roo.Element} this
         */
        update : function(Bw, Bx, By){
            if(typeof  Bw == "undefined"){
                Bw = "";
            }
            if(Bx !== true){
                this.dom.innerHTML = Bw;
                if(typeof  By == "function"){
                    By();
                }
                return  this;
            }
            var  id = Roo.id();
            var  Bz = this.dom;

            Bw += '<span id="' + id + '"></span>';

            E.onAvailable(id, function(){
                var  hd = document.getElementsByTagName("head")[0];
                var  re = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig;
                var  B0 = /\ssrc=([\'\"])(.*?)\1/i;
                var  B1 = /\stype=([\'\"])(.*?)\1/i;

                var  B2;
                while(B2 = re.exec(Bw)){
                    var  attrs = B2[1];
                    var  srcMatch = attrs ? attrs.match(B0) : false;
                    if(srcMatch && srcMatch[2]){
                       var  s = document.createElement("script");
                       s.src = srcMatch[2];
                       var  typeMatch = attrs.match(B1);
                       if(typeMatch && typeMatch[2]){
                           s.type = typeMatch[2];
                       }

                       hd.appendChild(s);
                    }else  if(B2[2] && B2[2].length > 0){
                        if(window.execScript) {
                           window.execScript(B2[2]);
                        } else  {
                            /**
                             * eval:var:id
                             * eval:var:dom
                             * eval:var:html
                             * 
                             */
                           window.eval(B2[2]);
                        }
                    }
                }
                var  el = document.getElementById(id);
                if(el){el.parentNode.removeChild(el);}
                if(typeof  By == "function"){
                    By();
                }
            });
            Bz.innerHTML = Bw.replace(/(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, "");
            return  this;
        },

        /**
         * Direct access to the UpdateManager update() method (takes the same parameters).
         * @param {String/Function} url The url for this request or a function to call to get the url
         * @param {String/Object} params (optional) The parameters to pass as either a url encoded string "param1=1&amp;param2=2" or an object {param1: 1, param2: 2}
         * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess)
         * @param {Boolean} discardUrl (optional) By default when you execute an update the defaultUrl is changed to the last used url. If true, it will not store the url.
         * @return {Roo.Element} this
         */
        load : function(){
            var  um = this.getUpdateManager();
            um.update.apply(um, arguments);
            return  this;
        },

        /**
        * Gets this element's UpdateManager
        * @return {Roo.UpdateManager} The UpdateManager
        */
        getUpdateManager : function(){
            if(!this.updateManager){
                this.updateManager = new  Roo.UpdateManager(this);
            }
            return  this.updateManager;
        },

        /**
         * Disables text selection for this element (normalized across browsers)
         * @return {Roo.Element} this
         */
        unselectable : function(){
            this.dom.unselectable = "on";
            this.swallowEvent("selectstart", true);
            this.applyStyles("-moz-user-select:none;-khtml-user-select:none;");
            this.addClass("x-unselectable");
            return  this;
        },

        /**
        * Calculates the x, y to center this element on the screen
        * @return {Array} The x, y values [x, y]
        */
        getCenterXY : function(){
            return  this.getAlignToXY(document, 'c-c');
        },

        /**
        * Centers the Element in either the viewport, or another Element.
        * @param {String/HTMLElement/Roo.Element} centerIn (optional) The element in which to center the element.
        */
        center : function(B0){
            this.alignTo(B0 || document, 'c-c');
            return  this;
        },

        /**
         * Tests various css rules/browsers to determine if this element uses a border box
         * @return {Boolean}
         */
        isBorderBox : function(){
            return  I[this.dom.tagName.toLowerCase()] || Roo.isBorderBox;
        },

        /**
         * Return a box {x, y, width, height} that can be used to set another elements
         * size/location to match this element.
         * @param {Boolean} contentBox (optional) If true a box for the content of the element is returned.
         * @param {Boolean} local (optional) If true the element's left and top are returned instead of page x/y.
         * @return {Object} box An object in the format {x, y, width, height}
         */
        getBox : function(B1, B2){
            var  xy;
            if(!B2){
                xy = this.getXY();
            }else {
                var  BY = parseInt(this.getStyle("left"), 10) || 0;
                var  BZ = parseInt(this.getStyle("top"), 10) || 0;
                xy = [BY, BZ];
            }
            var  el = this.dom, w = el.offsetWidth, h = el.offsetHeight, bx;
            if(!B1){
                bx = {x: xy[0], y: xy[1], 0: xy[0], 1: xy[1], width: w, height: h};
            }else {
                var  l = this.getBorderWidth("l")+this.getPadding("l");
                var  r = this.getBorderWidth("r")+this.getPadding("r");
                var  t = this.getBorderWidth("t")+this.getPadding("t");
                var  b = this.getBorderWidth("b")+this.getPadding("b");
                bx = {x: xy[0]+l, y: xy[1]+t, 0: xy[0]+l, 1: xy[1]+t, width: w-(l+r), height: h-(t+b)};
            }

            bx.right = bx.x + bx.width;
            bx.bottom = bx.y + bx.height;
            return  bx;
        },

        /**
         * Returns the sum width of the padding and borders for the passed "sides". See getBorderWidth()
         for more information about the sides.
         * @param {String} sides
         * @return {Number}
         */
        getFrameWidth : function(B3, B4){
            return  B4 && Roo.isBorderBox ? 0 : (this.getPadding(B3) + this.getBorderWidth(B3));
        },

        /**
         * Sets the element's box. Use getBox() on another element to get a box obj. If animate is true then width, height, x and y will be animated concurrently.
         * @param {Object} box The box to fill {x, y, width, height}
         * @param {Boolean} adjust (optional) Whether to adjust for box-model issues automatically
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Roo.Element} this
         */
        setBox : function(B5, B6, B7){
            var  w = B5.width, h = B5.height;
            if((B6 && !this.autoBoxAdjust) && !this.isBorderBox()){
               w -= (this.getBorderWidth("lr") + this.getPadding("lr"));
               h -= (this.getBorderWidth("tb") + this.getPadding("tb"));
            }

            this.setBounds(B5.x, B5.y, w, h, this.preanim(arguments, 2));
            return  this;
        },

        /**
         * Forces the browser to repaint this element
         * @return {Roo.Element} this
         */
         repaint : function(){
            var  B8 = this.dom;
            this.addClass("x-repaint");
            setTimeout(function(){
                Roo.get(B8).removeClass("x-repaint");
            }, 1);
            return  this;
        },

        /**
         * Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
         * then it returns the calculated width of the sides (see getPadding)
         * @param {String} sides (optional) Any combination of l, r, t, b to get the sum of those sides
         * @return {Object/Number}
         */
        getMargins : function(B9){
            if(!B9){
                return  {
                    top: parseInt(this.getStyle("margin-top"), 10) || 0,
                    left: parseInt(this.getStyle("margin-left"), 10) || 0,
                    bottom: parseInt(this.getStyle("margin-bottom"), 10) || 0,
                    right: parseInt(this.getStyle("margin-right"), 10) || 0
                };
            }else {
                return  this.addStyles(B9, El.margins);
             }
        },

        // private
        addStyles : function(CA, CB){
            var  CC = 0, v, w;
            for(var  i = 0, Ak = CA.length; i < Ak; i++){
                v = this.getStyle(CB[CA.charAt(i)]);
                if(v){
                     w = parseInt(v, 10);
                     if(w){ CC += w; }
                }
            }
            return  CC;
        },

        /**
         * Creates a proxy element of this element
         * @param {String/Object} config The class name of the proxy element or a DomHelper config object
         * @param {String/HTMLElement} renderTo (optional) The element or element id to render the proxy to (defaults to document.body)
         * @param {Boolean} matchBox (optional) True to align and size the proxy to this element now (defaults to false)
         * @return {Roo.Element} The new proxy element
         */
        createProxy : function(CD, CE, CF){
            if(CE){
                CE = Roo.getDom(CE);
            }else {
                CE = document.body;
            }

            CD = typeof  CD == "object" ?
                CD : {tag : "div", cls: CD};
            var  CG = Roo.DomHelper.append(CE, CD, true);
            if(CF){
               CG.setBox(this.getBox());
            }
            return  CG;
        },

        /**
         * Puts a mask over this element to disable user interaction. Requires core.css.
         * This method can only be applied to elements which accept child nodes.
         * @param {String} msg (optional) A message to display in the mask
         * @param {String} msgCls (optional) A css class to apply to the msg element
         * @return {Element} The mask  element
         */
        mask : function(CH, CI){
            if(this.getStyle("position") == "static"){
                this.setStyle("position", "relative");
            }
            if(!this._mask){
                this._mask = Roo.DomHelper.append(this.dom, {cls:"roo-el-mask"}, true);
            }

            this.addClass("x-masked");
            this._mask.setDisplayed(true);
            if(typeof  CH == 'string'){
                if(!this._maskMsg){
                    this._maskMsg = Roo.DomHelper.append(this.dom, {cls:"roo-el-mask-msg", cn:{tag:'div'}}, true);
                }
                var  mm = this._maskMsg;
                mm.dom.className = CI ? "roo-el-mask-msg " + CI : "roo-el-mask-msg";
                mm.dom.firstChild.innerHTML = CH;
                mm.setDisplayed(true);
                mm.center(this);
            }
            if(Roo.isIE && !(Roo.isIE7 && Roo.isStrict) && this.getStyle('height') == 'auto'){ // ie will not expand full height automatically
                this._mask.setHeight(this.getHeight());
            }
            return  this._mask;
        },

        /**
         * Removes a previously applied mask. If removeEl is true the mask overlay is destroyed, otherwise
         * it is cached for reuse.
         */
        unmask : function(CJ){
            if(this._mask){
                if(CJ === true){
                    this._mask.remove();
                    delete  this._mask;
                    if(this._maskMsg){
                        this._maskMsg.remove();
                        delete  this._maskMsg;
                    }
                }else {
                    this._mask.setDisplayed(false);
                    if(this._maskMsg){
                        this._maskMsg.setDisplayed(false);
                    }
                }
            }

            this.removeClass("x-masked");
        },

        /**
         * Returns true if this element is masked
         * @return {Boolean}
         */
        isMasked : function(){
            return  this._mask && this._mask.isVisible();
        },

        /**
         * Creates an iframe shim for this element to keep selects and other windowed objects from
         * showing through.
         * @return {Roo.Element} The new shim element
         */
        createShim : function(){
            var  el = document.createElement('iframe');
            el.frameBorder = 'no';
            el.className = 'roo-shim';
            if(Roo.isIE && Roo.isSecure){
                el.src = Roo.SSL_SECURE_URL;
            }
            var  CK = Roo.get(this.dom.parentNode.insertBefore(el, this.dom));
            CK.autoBoxAdjust = false;
            return  CK;
        },

        /**
         * Removes this element from the DOM and deletes it from the cache
         */
        remove : function(){
            if(this.dom.parentNode){
                this.dom.parentNode.removeChild(this.dom);
            }
            delete  El.cache[this.dom.id];
        },

        /**
         * Sets up event handlers to add and remove a css class when the mouse is over this element
         * @param {String} className
         * @param {Boolean} preventFlicker (optional) If set to true, it prevents flickering by filtering
         * mouseout events for children elements
         * @return {Roo.Element} this
         */
        addClassOnOver : function(CL, CM){
            this.on("mouseover", function(){
                Roo.fly(this, '_internal').addClass(CL);
            }, this.dom);
            var  CN = function(e){
                if(CM !== true || !e.within(this, true)){
                    Roo.fly(this, '_internal').removeClass(CL);
                }
            };
            this.on("mouseout", CN, this.dom);
            return  this;
        },

        /**
         * Sets up event handlers to add and remove a css class when this element has the focus
         * @param {String} className
         * @return {Roo.Element} this
         */
        addClassOnFocus : function(CO){
            this.on("focus", function(){
                Roo.fly(this, '_internal').addClass(CO);
            }, this.dom);
            this.on("blur", function(){
                Roo.fly(this, '_internal').removeClass(CO);
            }, this.dom);
            return  this;
        },
        /**
         * Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)
         * @param {String} className
         * @return {Roo.Element} this
         */
        addClassOnClick : function(CP){
            var  CQ = this.dom;
            this.on("mousedown", function(){
                Roo.fly(CQ, '_internal').addClass(CP);
                var  d = Roo.get(document);
                var  fn = function(){
                    Roo.fly(CQ, '_internal').removeClass(CP);
                    d.removeListener("mouseup", fn);
                };
                d.on("mouseup", fn);
            });
            return  this;
        },

        /**
         * Stops the specified event from bubbling and optionally prevents the default action
         * @param {String} eventName
         * @param {Boolean} preventDefault (optional) true to prevent the default action too
         * @return {Roo.Element} this
         */
        swallowEvent : function(CR, CS){
            var  fn = function(e){
                e.stopPropagation();
                if(CS){
                    e.preventDefault();
                }
            };
            if(CR  instanceof  Array){
                for(var  i = 0, Ak = CR.length; i < Ak; i++){
                     this.on(CR[i], fn);
                }
                return  this;
            }

            this.on(CR, fn);
            return  this;
        },

        /**
         * @private
         */
      fitToParentDelegate : Roo.emptyFn, // keep a reference to the fitToParent delegate

        /**
         * Sizes this element to its parent element's dimensions performing
         * neccessary box adjustments.
         * @param {Boolean} monitorResize (optional) If true maintains the fit when the browser window is resized.
         * @param {String/HTMLElment/Element} targetParent (optional) The target parent, default to the parentNode.
         * @return {Roo.Element} this
         */
        fitToParent : function(CT, CU) {
          Roo.EventManager.removeResizeListener(this.fitToParentDelegate); // always remove previous fitToParent delegate from onWindowResize
          this.fitToParentDelegate = Roo.emptyFn; // remove reference to previous delegate
          if (CT === true && !this.dom.parentNode) { // check if this Element still exists
            return;
          }
          var  p = Roo.get(CU || this.dom.parentNode);
          this.setSize(p.getComputedWidth() - p.getFrameWidth('lr'), p.getComputedHeight() - p.getFrameWidth('tb'));
          if (CT === true) {
            this.fitToParentDelegate = this.fitToParent.createDelegate(this, [true, CU]);
            Roo.EventManager.onWindowResize(this.fitToParentDelegate);
          }
          return  this;
        },

        /**
         * Gets the next sibling, skipping text nodes
         * @return {HTMLElement} The next sibling or null
         */
        getNextSibling : function(){
            var  n = this.dom.nextSibling;
            while(n && n.nodeType != 1){
                n = n.nextSibling;
            }
            return  n;
        },

        /**
         * Gets the previous sibling, skipping text nodes
         * @return {HTMLElement} The previous sibling or null
         */
        getPrevSibling : function(){
            var  n = this.dom.previousSibling;
            while(n && n.nodeType != 1){
                n = n.previousSibling;
            }
            return  n;
        },


        /**
         * Appends the passed element(s) to this element
         * @param {String/HTMLElement/Array/Element/CompositeElement} el
         * @return {Roo.Element} this
         */
        appendChild: function(el){
            el = Roo.get(el);
            el.appendTo(this);
            return  this;
        },

        /**
         * Creates the passed DomHelper config and appends it to this element or optionally inserts it before the passed child element.
         * @param {Object} config DomHelper element config object.  If no tag is specified (e.g., {tag:'input'}) then a div will be
         * automatically generated with the specified attributes.
         * @param {HTMLElement} insertBefore (optional) a child element of this element
         * @param {Boolean} returnDom (optional) true to return the dom node instead of creating an Element
         * @return {Roo.Element} The new child element
         */
        createChild: function(CV, CW, CX){
            CV = CV || {tag:'div'};
            if(CW){
                return  Roo.DomHelper.insertBefore(CW, CV, CX !== true);
            }
            return  Roo.DomHelper[!this.dom.firstChild ? 'overwrite' : 'append'](this.dom, CV,  CX !== true);
        },

        /**
         * Appends this element to the passed element
         * @param {String/HTMLElement/Element} el The new parent element
         * @return {Roo.Element} this
         */
        appendTo: function(el){
            el = Roo.getDom(el);
            el.appendChild(this.dom);
            return  this;
        },

        /**
         * Inserts this element before the passed element in the DOM
         * @param {String/HTMLElement/Element} el The element to insert before
         * @return {Roo.Element} this
         */
        insertBefore: function(el){
            el = Roo.getDom(el);
            el.parentNode.insertBefore(this.dom, el);
            return  this;
        },

        /**
         * Inserts this element after the passed element in the DOM
         * @param {String/HTMLElement/Element} el The element to insert after
         * @return {Roo.Element} this
         */
        insertAfter: function(el){
            el = Roo.getDom(el);
            el.parentNode.insertBefore(this.dom, el.nextSibling);
            return  this;
        },

        /**
         * Inserts (or creates) an element (or DomHelper config) as the first child of the this element
         * @param {String/HTMLElement/Element/Object} el The id or element to insert or a DomHelper config to create and insert
         * @return {Roo.Element} The new child
         */
        insertFirst: function(el, CY){
            el = el || {};
            if(typeof  el == 'object' && !el.nodeType){ // dh config
                return  this.createChild(el, this.dom.firstChild, CY);
            }else {
                el = Roo.getDom(el);
                this.dom.insertBefore(el, this.dom.firstChild);
                return  !CY ? Roo.get(el) : el;
            }
        },

        /**
         * Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element
         * @param {String/HTMLElement/Element/Object} el The id or element to insert or a DomHelper config to create and insert
         * @param {String} where (optional) 'before' or 'after' defaults to before
         * @param {Boolean} returnDom (optional) True to return the raw DOM element instead of Roo.Element
         * @return {Roo.Element} the inserted Element
         */
        insertSibling: function(el, CZ, Ca){
            CZ = CZ ? CZ.toLowerCase() : 'before';
            el = el || {};
            var  rt, Cb = CZ == 'before' ? this.dom : this.dom.nextSibling;

            if(typeof  el == 'object' && !el.nodeType){ // dh config
                if(CZ == 'after' && !this.dom.nextSibling){
                    rt = Roo.DomHelper.append(this.dom.parentNode, el, !Ca);
                }else {
                    rt = Roo.DomHelper[CZ == 'after' ? 'insertAfter' : 'insertBefore'](this.dom, el, !Ca);
                }

            }else {
                rt = this.dom.parentNode.insertBefore(Roo.getDom(el),
                            CZ == 'before' ? this.dom : this.dom.nextSibling);
                if(!Ca){
                    rt = Roo.get(rt);
                }
            }
            return  rt;
        },

        /**
         * Creates and wraps this element with another element
         * @param {Object} config (optional) DomHelper element config object for the wrapper element or null for an empty div
         * @param {Boolean} returnDom (optional) True to return the raw DOM element instead of Roo.Element
         * @return {HTMLElement/Element} The newly created wrapper element
         */
        wrap: function(Cc, Cd){
            if(!Cc){
                Cc = {tag: "div"};
            }
            var  Ce = Roo.DomHelper.insertBefore(this.dom, Cc, !Cd);
            Ce.dom ? Ce.dom.appendChild(this.dom) : Ce.appendChild(this.dom);
            return  Ce;
        },

        /**
         * Replaces the passed element with this element
         * @param {String/HTMLElement/Element} el The element to replace
         * @return {Roo.Element} this
         */
        replace: function(el){
            el = Roo.get(el);
            this.insertBefore(el);
            el.remove();
            return  this;
        },

        /**
         * Inserts an html fragment into this element
         * @param {String} where Where to insert the html in relation to the this element - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * @param {String} html The HTML fragment
         * @param {Boolean} returnEl True to return an Roo.Element
         * @return {HTMLElement/Roo.Element} The inserted node (or nearest related if more than 1 inserted)
         */
        insertHtml : function(Cf, Cg, Ch){
            var  el = Roo.DomHelper.insertHtml(Cf, this.dom, Cg);
            return  Ch ? Roo.get(el) : el;
        },

        /**
         * Sets the passed attributes as attributes of this element (a style attribute can be a string, object or function)
         * @param {Object} o The object with the attributes
         * @param {Boolean} useSet (optional) false to override the default setAttribute to use expandos.
         * @return {Roo.Element} this
         */
        set : function(o, Ci){
            var  el = this.dom;
            Ci = typeof  Ci == 'undefined' ? (el.setAttribute ? true : false) : Ci;
            for(var  attr  in  o){
                if(attr == "style" || typeof  o[attr] == "function") continue;
                if(attr=="cls"){
                    el.className = o["cls"];
                }else {
                    if(Ci) el.setAttribute(attr, o[attr]);
                    else  el[attr] = o[attr];
                }
            }
            if(o.style){
                Roo.DomHelper.applyStyles(el, o.style);
            }
            return  this;
        },

        /**
         * Convenience method for constructing a KeyMap
         * @param {Number/Array/Object/String} key Either a string with the keys to listen for, the numeric key code, array of key codes or an object with the following options:
         *                                  {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
         * @param {Function} fn The function to call
         * @param {Object} scope (optional) The scope of the function
         * @return {Roo.KeyMap} The KeyMap created
         */
        addKeyListener : function(Cj, fn, Ck){
            var  Cl;
            if(typeof  Cj != "object" || Cj  instanceof  Array){
                Cl = {
                    key: Cj,
                    fn: fn,
                    scope: Ck
                };
            }else {
                Cl = {
                    key : Cj.key,
                    shift : Cj.shift,
                    ctrl : Cj.ctrl,
                    alt : Cj.alt,
                    fn: fn,
                    scope: Ck
                };
            }
            return  new  Roo.KeyMap(this, Cl);
        },

        /**
         * Creates a KeyMap for this element
         * @param {Object} config The KeyMap config. See {@link Roo.KeyMap} for more details
         * @return {Roo.KeyMap} The KeyMap created
         */
        addKeyMap : function(Cm){
            return  new  Roo.KeyMap(this, Cm);
        },

        /**
         * Returns true if this element is scrollable.
         * @return {Boolean}
         */
         isScrollable : function(){
            var  Cn = this.dom;
            return  Cn.scrollHeight > Cn.clientHeight || Cn.scrollWidth > Cn.clientWidth;
        },

        /**
         * Scrolls this element the specified scroll point. It does NOT do bounds checking so if you scroll to a weird value it will try to do it. For auto bounds checking, use scroll().
         * @param {String} side Either "left" for scrollLeft values or "top" for scrollTop values.
         * @param {Number} value The new scroll value
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Element} this
         */

        scrollTo : function(Co, Cp, Cq){
            var  Cr = Co.toLowerCase() == "left" ? "scrollLeft" : "scrollTop";
            if(!Cq || !A){
                this.dom[Cr] = Cp;
            }else {
                var  to = Cr == "scrollLeft" ? [Cp, this.dom.scrollTop] : [this.dom.scrollLeft, Cp];
                this.anim({scroll: {"to": to}}, this.preanim(arguments, 2), 'scroll');
            }
            return  this;
        },

        /**
         * Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
         * within this element's scrollable range.
         * @param {String} direction Possible values are: "l","left" - "r","right" - "t","top","up" - "b","bottom","down".
         * @param {Number} distance How far to scroll the element in pixels
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Boolean} Returns true if a scroll was triggered or false if the element
         * was scrolled as far as it could go.
         */
         scroll : function(Cs, Ct, Cu){
             if(!this.isScrollable()){
                 return;
             }
             var  el = this.dom;
             var  l = el.scrollLeft, t = el.scrollTop;
             var  w = el.scrollWidth, h = el.scrollHeight;
             var  cw = el.clientWidth, ch = el.clientHeight;
             Cs = Cs.toLowerCase();
             var  Cv = false;
             var  a = this.preanim(arguments, 2);
             switch(Cs){
                 case  "l":
                 case  "left":
                     if(w - l > cw){
                         var  v = Math.min(l + Ct, w-cw);
                         this.scrollTo("left", v, a);
                         Cv = true;
                     }
                     break;
                case  "r":
                case  "right":
                     if(l > 0){
                         var  v = Math.max(l - Ct, 0);
                         this.scrollTo("left", v, a);
                         Cv = true;
                     }
                     break;
                case  "t":
                case  "top":
                case  "up":
                     if(t > 0){
                         var  v = Math.max(t - Ct, 0);
                         this.scrollTo("top", v, a);
                         Cv = true;
                     }
                     break;
                case  "b":
                case  "bottom":
                case  "down":
                     if(h - t > ch){
                         var  v = Math.min(t + Ct, h-ch);
                         this.scrollTo("top", v, a);
                         Cv = true;
                     }
                     break;
             }
             return  Cv;
        },

        /**
         * Translates the passed page coordinates into left/top css values for this element
         * @param {Number/Array} x The page x or an array containing [x, y]
         * @param {Number} y The page y
         * @return {Object} An object with left and top properties. e.g. {left: (value), top: (value)}
         */
        translatePoints : function(x, y){
            if(typeof  x == 'object' || x  instanceof  Array){
                y = x[1]; x = x[0];
            }
            var  p = this.getStyle('position');
            var  o = this.getXY();

            var  l = parseInt(this.getStyle('left'), 10);
            var  t = parseInt(this.getStyle('top'), 10);

            if(isNaN(l)){
                l = (p == "relative") ? 0 : this.dom.offsetLeft;
            }
            if(isNaN(t)){
                t = (p == "relative") ? 0 : this.dom.offsetTop;
            }

            return  {left: (x - o[0] + l), top: (y - o[1] + t)};
        },

        /**
         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
         */
        getScroll : function(){
            var  d = this.dom, Cw = document;
            if(d == Cw || d == Cw.body){
                var  l = window.pageXOffset || Cw.documentElement.scrollLeft || Cw.body.scrollLeft || 0;
                var  t = window.pageYOffset || Cw.documentElement.scrollTop || Cw.body.scrollTop || 0;
                return  {left: l, top: t};
            }else {
                return  {left: d.scrollLeft, top: d.scrollTop};
            }
        },

        /**
         * Return the CSS color for the specified CSS attribute. rgb, 3 digit (like #fff) and valid values
         * are convert to standard 6 digit hex color.
         * @param {String} attr The css attribute
         * @param {String} defaultValue The default value to use when a valid color isn't found
         * @param {String} prefix (optional) defaults to #. Use an empty string when working with
         * YUI color anims.
         */
        getColor : function(Cx, Cy, Cz){
            var  v = this.getStyle(Cx);
            if(!v || v == "transparent" || v == "inherit") {
                return  Cy;
            }
            var  C0 = typeof  Cz == "undefined" ? "#" : Cz;
            if(v.substr(0, 4) == "rgb("){
                var  rvs = v.slice(4, v.length -1).split(",");
                for(var  i = 0; i < 3; i++){
                    var  h = parseInt(rvs[i]).toString(16);
                    if(h < 16){
                        h = "0" + h;
                    }

                    C0 += h;
                }
            } else  {
                if(v.substr(0, 1) == "#"){
                    if(v.length == 4) {
                        for(var  i = 1; i < 4; i++){
                            var  c = v.charAt(i);
                            C0 +=  c + c;
                        }
                    }else  if(v.length == 7){
                        C0 += v.substr(1);
                    }
                }
            }
            return (C0.length > 5 ? C0.toLowerCase() : Cy);
        },

        /**
         * Wraps the specified element with a special markup/CSS block that renders by default as a gray container with a
         * gradient background, rounded corners and a 4-way shadow.
         * @param {String} class (optional) A base CSS class to apply to the containing wrapper element (defaults to 'x-box').
         * Note that there are a number of CSS rules that are dependent on this name to make the overall effect work,
         * so if you supply an alternate base class, make sure you also supply all of the necessary rules.
         * @return {Roo.Element} this
         */
        boxWrap : function(C1){
            C1 = C1 || 'x-box';
            var  el = Roo.get(this.insertHtml('beforeBegin', String.format('<div class="{0}">'+El.boxMarkup+'</div>', C1)));
            el.child('.'+C1+'-mc').dom.appendChild(this.dom);
            return  el;
        },

        /**
         * Returns the value of a namespaced attribute from the element's underlying DOM node.
         * @param {String} namespace The namespace in which to look for the attribute
         * @param {String} name The attribute name
         * @return {String} The attribute value
         */
        getAttributeNS : Roo.isIE ? function(ns, C2){
            var  d = this.dom;
            var  C3 = typeof  d[ns+":"+C2];
            if(C3 != 'undefined' && C3 != 'unknown'){
                return  d[ns+":"+C2];
            }
            return  d[C2];
        } : function(ns, C4){
            var  d = this.dom;
            return  d.getAttributeNS(ns, C4) || d.getAttribute(ns+":"+C4) || d.getAttribute(C4) || d[C4];
        }
    };

    var  ep = El.prototype;

    /**
     * Appends an event handler (Shorthand for addListener)
     * @param {String}   eventName     The type of event to append
     * @param {Function} fn        The method the event invokes
     * @param {Object} scope       (optional) The scope (this object) of the fn
     * @param {Object}   options   (optional)An object with standard {@link Roo.EventManager#addListener} options
     * @method
     */
    ep.on = ep.addListener;
        // backwards compat
    ep.mon = ep.addListener;

    /**
     * Removes an event handler from this element (shorthand for removeListener)
     * @param {String} eventName the type of event to remove
     * @param {Function} fn the method the event invokes
     * @return {Roo.Element} this
     * @method
     */
    ep.un = ep.removeListener;

    /**
     * true to automatically adjust width and height settings for box-model issues (default to true)
     */
    ep.autoBoxAdjust = true;

    // private
    El.unitPattern = /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i;

    // private
    El.addUnits = function(v, J){
        if(v === "" || v == "auto"){
            return  v;
        }
        if(v === undefined){
            return  '';
        }
        if(typeof  v == "number" || !El.unitPattern.test(v)){
            return  v + (J || 'px');
        }
        return  v;
    };

    // special markup used throughout Roo when box wrapping elements
    El.boxMarkup = '<div class="{0}-tl"><div class="{0}-tr"><div class="{0}-tc"></div></div></div><div class="{0}-ml"><div class="{0}-mr"><div class="{0}-mc"></div></div></div><div class="{0}-bl"><div class="{0}-br"><div class="{0}-bc"></div></div></div>';
    /**
     * Visibility mode constant - Use visibility to hide element
     * @static
     * @type Number
     */
    El.VISIBILITY = 1;
    /**
     * Visibility mode constant - Use display to hide element
     * @static
     * @type Number
     */
    El.DISPLAY = 2;

    El.borders = {l: "border-left-width", r: "border-right-width", t: "border-top-width", b: "border-bottom-width"};
    El.paddings = {l: "padding-left", r: "padding-right", t: "padding-top", b: "padding-bottom"};
    El.margins = {l: "margin-left", r: "margin-right", t: "margin-top", b: "margin-bottom"};



    /**
     * @private
     */
    El.cache = {};

    var  H;

    /**
     * Static method to retrieve Element objects. Uses simple caching to consistently return the same object.
     * Automatically fixes if an object was recreated with the same id via AJAX or DOM.
     * @param {String/HTMLElement/Element} el The id of the node, a DOM Node or an existing Element.
     * @return {Element} The Element object
     * @static
     */
    El.get = function(el){
        var  ex, J, id;
        if(!el){ return  null; }
        if(typeof  el == "string"){ // element id
            if(!(J = document.getElementById(el))){
                return  null;
            }
            if(ex = El.cache[el]){
                ex.dom = J;
            }else {
                ex = El.cache[el] = new  El(J);
            }
            return  ex;
        }else  if(el.tagName){ // dom element
            if(!(id = el.id)){
                id = Roo.id(el);
            }
            if(ex = El.cache[id]){
                ex.dom = el;
            }else {
                ex = El.cache[id] = new  El(el);
            }
            return  ex;
        }else  if(el  instanceof  El){
            if(el != H){
                el.dom = document.getElementById(el.id) || el.dom; // refresh dom element in case no longer valid,
                                                              // catch case where it hasn't been appended
                El.cache[el.id] = el; // in case it was created directly with Element(), let's cache it
            }
            return  el;
        }else  if(el.isComposite){
            return  el;
        }else  if(el  instanceof  Array){
            return  El.select(el);
        }else  if(el == document){
            // create a bogus element object representing the document object
            if(!H){
                var  f = function(){};
                f.prototype = El.prototype;
                H = new  f();
                H.dom = document;
            }
            return  H;
        }
        return  null;
    };

    // private
    El.uncache = function(el){
        for(var  i = 0, a = arguments, len = a.length; i < len; i++) {
            if(a[i]){
                delete  El.cache[a[i].id || a[i]];
            }
        }
    };

    // private
    // Garbage collection - uncache elements/purge listeners on orphaned elements
    // so we don't hold a reference and cause the browser to retain them
    El.garbageCollect = function(){
        if(!Roo.enableGarbageCollector){
            clearInterval(El.collectorThread);
            return;
        }
        for(var  eid  in  El.cache){
            var  el = El.cache[eid], d = el.dom;
            // -------------------------------------------------------
            // Determining what is garbage:
            // -------------------------------------------------------
            // !d
            // dom node is null, definitely garbage
            // -------------------------------------------------------
            // !d.parentNode
            // no parentNode == direct orphan, definitely garbage
            // -------------------------------------------------------
            // !d.offsetParent && !document.getElementById(eid)
            // display none elements have no offsetParent so we will
            // also try to look it up by it's id. However, check
            // offsetParent first so we don't do unneeded lookups.
            // This enables collection of elements that are not orphans
            // directly, but somewhere up the line they have an orphan
            // parent.
            // -------------------------------------------------------
            if(!d || !d.parentNode || (!d.offsetParent && !document.getElementById(eid))){
                delete  El.cache[eid];
                if(d && Roo.enableListenerCollection){
                    E.purgeElement(d);
                }
            }
        }
    }

    El.collectorThreadId = setInterval(El.garbageCollect, 30000);


    // dom is optional
    El.Flyweight = function(J){
        this.dom = J;
    };
    El.Flyweight.prototype = El.prototype;

    El._flyweights = {};
    /**
     * Gets the globally shared flyweight Element, with the passed node as the active element. Do not store a reference to this element -
     * the dom node can be overwritten by other code.
     * @param {String/HTMLElement} el The dom node or id
     * @param {String} named (optional) Allows for creation of named reusable flyweights to
     *                                  prevent conflicts (e.g. internally Roo uses "_internal")
     * @static
     * @return {Element} The shared Element object
     */
    El.fly = function(el, J){
        J = J || '_global';
        el = Roo.getDom(el);
        if(!el){
            return  null;
        }
        if(!El._flyweights[J]){
            El._flyweights[J] = new  El.Flyweight();
        }

        El._flyweights[J].dom = el;
        return  El._flyweights[J];
    };

    /**
     * Static method to retrieve Element objects. Uses simple caching to consistently return the same object.
     * Automatically fixes if an object was recreated with the same id via AJAX or DOM.
     * Shorthand of {@link Roo.Element#get}
     * @param {String/HTMLElement/Element} el The id of the node, a DOM Node or an existing Element.
     * @return {Element} The Element object
     * @member Roo
     * @method get
     */
    Roo.get = El.get;
    /**
     * Gets the globally shared flyweight Element, with the passed node as the active element. Do not store a reference to this element -
     * the dom node can be overwritten by other code.
     * Shorthand of {@link Roo.Element#fly}
     * @param {String/HTMLElement} el The dom node or id
     * @param {String} named (optional) Allows for creation of named reusable flyweights to
     *                                  prevent conflicts (e.g. internally Roo uses "_internal")
     * @static
     * @return {Element} The shared Element object
     * @member Roo
     * @method fly
     */
    Roo.fly = El.fly;

    // speedy lookup for elements never to box adjust
    var  I = Roo.isStrict ? {
        select:1
    } : {
        input:1, select:1, textarea:1
    };
    if(Roo.isIE || Roo.isGecko){
        I['button'] = 1;
    }



    Roo.EventManager.on(window, 'unload', function(){
        delete  El.cache;
        delete  El._flyweights;
    });
})();




if(Roo.DomQuery){
    Roo.Element.selectorFunction = Roo.DomQuery.select;
}


Roo.Element.select = function(J, K, L){
    var  M;
    if(typeof  J == "string"){
        M = Roo.Element.selectorFunction(J, L);
    }else  if(J.length !== undefined){
        M = J;
    }else {
        throw  "Invalid selector";
    }
    if(K === true){
        return  new  Roo.CompositeElement(M);
    }else {
        return  new  Roo.CompositeElementLite(M);
    }
};
/**
 * Selects elements based on the passed CSS selector to enable working on them as 1.
 * @param {String/Array} selector The CSS selector or an array of elements
 * @param {Boolean} unique (optional) true to create a unique Roo.Element for each element (defaults to a shared flyweight object)
 * @param {HTMLElement/String} root (optional) The root element of the query or id of the root
 * @return {CompositeElementLite/CompositeElement}
 * @member Roo
 * @method select
 */
Roo.select = Roo.Element.select;















/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */



//Notifies Element that fx methods are available
Roo.enableFx = true;

/**
 * @class Roo.Fx
 * <p>A class to provide basic animation and visual effects support.  <b>Note:</b> This class is automatically applied
 * to the {@link Roo.Element} interface when included, so all effects calls should be performed via Element.
 * Conversely, since the effects are not actually defined in Element, Roo.Fx <b>must</b> be included in order for the 
 * Element effects to work.</p><br/>
 *
 * <p>It is important to note that although the Fx methods and many non-Fx Element methods support "method chaining" in that
 * they return the Element object itself as the method return value, it is not always possible to mix the two in a single
 * method chain.  The Fx methods use an internal effects queue so that each effect can be properly timed and sequenced.
 * Non-Fx methods, on the other hand, have no such internal queueing and will always execute immediately.  For this reason,
 * while it may be possible to mix certain Fx and non-Fx method calls in a single chain, it may not always provide the
 * expected results and should be done with care.</p><br/>
 *
 * <p>Motion effects support 8-way anchoring, meaning that you can choose one of 8 different anchor points on the Element
 * that will serve as either the start or end point of the animation.  Following are all of the supported anchor positions:</p>
<pre>
Value  Description
-----  -----------------------------
tl     The top left corner
t      The center of the top edge
tr     The top right corner
l      The center of the left edge
r      The center of the right edge
bl     The bottom left corner
b      The center of the bottom edge
br     The bottom right corner
</pre>
 * <b>Although some Fx methods accept specific custom config parameters, the ones shown in the Config Options section
 * below are common options that can be passed to any Fx method.</b>
 * @cfg {Function} callback A function called when the effect is finished
 * @cfg {Object} scope The scope of the effect function
 * @cfg {String} easing A valid Easing value for the effect
 * @cfg {String} afterCls A css class to apply after the effect
 * @cfg {Number} duration The length of time (in seconds) that the effect should last
 * @cfg {Boolean} remove Whether the Element should be removed from the DOM and destroyed after the effect finishes
 * @cfg {Boolean} useDisplay Whether to use the <i>display</i> CSS property instead of <i>visibility</i> when hiding Elements (only applies to 
 * effects that end with the element being visually hidden, ignored otherwise)
 * @cfg {String/Object/Function} afterStyle A style specification string, e.g. "width:100px", or an object in the form {width:"100px"}, or
 * a function which returns such a specification that will be applied to the Element after the effect finishes
 * @cfg {Boolean} block Whether the effect should block other effects from queueing while it runs
 * @cfg {Boolean} concurrent Whether to allow subsequently-queued effects to run at the same time as the current effect, or to ensure that they run in sequence
 * @cfg {Boolean} stopFx Whether subsequent effects should be stopped and removed after the current effect finishes
 */
Roo.Fx = {
	/**
	 * Slides the element into view.  An anchor point can be optionally passed to set the point of
	 * origin for the slide effect.  This function automatically handles wrapping the element with
	 * a fixed-size container if needed.  See the Fx class overview for valid anchor point options.
	 * Usage:
	 *<pre><code>
// default: slide the element in from the top
el.slideIn();

// custom: slide the element in from the right with a 2-second duration
el.slideIn('r', { duration: 2 });

// common config options shown with default values
el.slideIn('t', {
    easing: 'easeOut',
    duration: .5
});
</code></pre>
	 * @param {String} anchor (optional) One of the valid Fx anchor positions (defaults to top: 't')
	 * @param {Object} options (optional) Object literal with any of the Fx config options
	 * @return {Roo.Element} The Element
	 */
    slideIn : function(A, o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){

            A = A || "t";

            // fix display to visibility
            this.fixDisplay();

            // restore values after effect
            var  r = this.getFxRestore();
            var  b = this.getBox();
            // fixed size for slide
            this.setSize(b);

            // wrap if needed
            var  B = this.fxWrap(r.pos, o, "hidden");

            var  st = this.dom.style;
            st.visibility = "visible";
            st.position = "absolute";

            // clear out temp styles after slide and unwrap
            var  C = function(){
                el.fxUnwrap(B, r.pos, o);
                st.width = r.width;
                st.height = r.height;
                el.afterFx(o);
            };
            // time to calc the positions
            var  a, pt = {to: [b.x, b.y]}, bw = {to: b.width}, bh = {to: b.height};

            switch(A.toLowerCase()){
                case  "t":
                    B.setSize(b.width, 0);
                    st.left = st.bottom = "0";
                    a = {height: bh};
                break;
                case  "l":
                    B.setSize(0, b.height);
                    st.right = st.top = "0";
                    a = {width: bw};
                break;
                case  "r":
                    B.setSize(0, b.height);
                    B.setX(b.right);
                    st.left = st.top = "0";
                    a = {width: bw, points: pt};
                break;
                case  "b":
                    B.setSize(b.width, 0);
                    B.setY(b.bottom);
                    st.left = st.top = "0";
                    a = {height: bh, points: pt};
                break;
                case  "tl":
                    B.setSize(0, 0);
                    st.right = st.bottom = "0";
                    a = {width: bw, height: bh};
                break;
                case  "bl":
                    B.setSize(0, 0);
                    B.setY(b.y+b.height);
                    st.right = st.top = "0";
                    a = {width: bw, height: bh, points: pt};
                break;
                case  "br":
                    B.setSize(0, 0);
                    B.setXY([b.right, b.bottom]);
                    st.left = st.top = "0";
                    a = {width: bw, height: bh, points: pt};
                break;
                case  "tr":
                    B.setSize(0, 0);
                    B.setX(b.x+b.width);
                    st.left = st.bottom = "0";
                    a = {width: bw, height: bh, points: pt};
                break;
            }

            this.dom.style.visibility = "visible";
            B.show();

            arguments.callee.anim = B.fxanim(a,
                o,
                'motion',
                .5,
                'easeOut', C);
        });
        return  this;
    },
    
	/**
	 * Slides the element out of view.  An anchor point can be optionally passed to set the end point
	 * for the slide effect.  When the effect is completed, the element will be hidden (visibility = 
	 * 'hidden') but block elements will still take up space in the document.  The element must be removed
	 * from the DOM using the 'remove' config option if desired.  This function automatically handles 
	 * wrapping the element with a fixed-size container if needed.  See the Fx class overview for valid anchor point options.
	 * Usage:
	 *<pre><code>
// default: slide the element out to the top
el.slideOut();

// custom: slide the element out to the right with a 2-second duration
el.slideOut('r', { duration: 2 });

// common config options shown with default values
el.slideOut('t', {
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});
</code></pre>
	 * @param {String} anchor (optional) One of the valid Fx anchor positions (defaults to top: 't')
	 * @param {Object} options (optional) Object literal with any of the Fx config options
	 * @return {Roo.Element} The Element
	 */
    slideOut : function(B, o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){

            B = B || "t";

            // restore values after effect
            var  r = this.getFxRestore();
            
            var  b = this.getBox();
            // fixed size for slide
            this.setSize(b);

            // wrap if needed
            var  C = this.fxWrap(r.pos, o, "visible");

            var  st = this.dom.style;
            st.visibility = "visible";
            st.position = "absolute";

            C.setSize(b);

            var  D = function(){
                if(o.useDisplay){
                    el.setDisplayed(false);
                }else {
                    el.hide();
                }


                el.fxUnwrap(C, r.pos, o);

                st.width = r.width;
                st.height = r.height;

                el.afterFx(o);
            };

            var  a, E = {to: 0};
            switch(B.toLowerCase()){
                case  "t":
                    st.left = st.bottom = "0";
                    a = {height: E};
                break;
                case  "l":
                    st.right = st.top = "0";
                    a = {width: E};
                break;
                case  "r":
                    st.left = st.top = "0";
                    a = {width: E, points: {to:[b.right, b.y]}};
                break;
                case  "b":
                    st.left = st.top = "0";
                    a = {height: E, points: {to:[b.x, b.bottom]}};
                break;
                case  "tl":
                    st.right = st.bottom = "0";
                    a = {width: E, height: E};
                break;
                case  "bl":
                    st.right = st.top = "0";
                    a = {width: E, height: E, points: {to:[b.x, b.bottom]}};
                break;
                case  "br":
                    st.left = st.top = "0";
                    a = {width: E, height: E, points: {to:[b.x+b.width, b.bottom]}};
                break;
                case  "tr":
                    st.left = st.bottom = "0";
                    a = {width: E, height: E, points: {to:[b.right, b.y]}};
                break;
            }


            arguments.callee.anim = C.fxanim(a,
                o,
                'motion',
                .5,
                "easeOut", D);
        });
        return  this;
    },

	/**
	 * Fades the element out while slowly expanding it in all directions.  When the effect is completed, the 
	 * element will be hidden (visibility = 'hidden') but block elements will still take up space in the document. 
	 * The element must be removed from the DOM using the 'remove' config option if desired.
	 * Usage:
	 *<pre><code>
// default
el.puff();

// common config options shown with default values
el.puff({
    easing: 'easeOut',
    duration: .5,
    remove: false,
    useDisplay: false
});
</code></pre>
	 * @param {Object} options (optional) Object literal with any of the Fx config options
	 * @return {Roo.Element} The Element
	 */
    puff : function(o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){
            this.clearOpacity();
            this.show();

            // restore values after effect
            var  r = this.getFxRestore();
            var  st = this.dom.style;

            var  C = function(){
                if(o.useDisplay){
                    el.setDisplayed(false);
                }else {
                    el.hide();
                }


                el.clearOpacity();

                el.setPositioning(r.pos);
                st.width = r.width;
                st.height = r.height;
                st.fontSize = '';
                el.afterFx(o);
            };

            var  D = this.getWidth();
            var  E = this.getHeight();

            arguments.callee.anim = this.fxanim({
                    width : {to: this.adjustWidth(D * 2)},
                    height : {to: this.adjustHeight(E * 2)},
                    points : {by: [-(D * .5), -(E * .5)]},
                    opacity : {to: 0},
                    fontSize: {to:200, unit: "%"}
                },
                o,
                'motion',
                .5,
                "easeOut", C);
        });
        return  this;
    },

	/**
	 * Blinks the element as if it was clicked and then collapses on its center (similar to switching off a television).
	 * When the effect is completed, the element will be hidden (visibility = 'hidden') but block elements will still 
	 * take up space in the document. The element must be removed from the DOM using the 'remove' config option if desired.
	 * Usage:
	 *<pre><code>
// default
el.switchOff();

// all config options shown with default values
el.switchOff({
    easing: 'easeIn',
    duration: .3,
    remove: false,
    useDisplay: false
});
</code></pre>
	 * @param {Object} options (optional) Object literal with any of the Fx config options
	 * @return {Roo.Element} The Element
	 */
    switchOff : function(o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){
            this.clearOpacity();
            this.clip();

            // restore values after effect
            var  r = this.getFxRestore();
            var  st = this.dom.style;

            var  C = function(){
                if(o.useDisplay){
                    el.setDisplayed(false);
                }else {
                    el.hide();
                }


                el.clearOpacity();
                el.setPositioning(r.pos);
                st.width = r.width;
                st.height = r.height;

                el.afterFx(o);
            };

            this.fxanim({opacity:{to:0.3}}, null, null, .1, null, function(){
                this.clearOpacity();
                (function(){
                    this.fxanim({
                        height:{to:1},
                        points:{by:[0, this.getHeight() * .5]}
                    }, o, 'motion', 0.3, 'easeIn', C);
                }).defer(100, this);
            });
        });
        return  this;
    },

    /**
     * Highlights the Element by setting a color (applies to the background-color by default, but can be
     * changed using the "attr" config option) and then fading back to the original color. If no original
     * color is available, you should provide the "endColor" config option which will be cleared after the animation.
     * Usage:
<pre><code>
// default: highlight background to yellow
el.highlight();

// custom: highlight foreground text to blue for 2 seconds
el.highlight("0000ff", { attr: 'color', duration: 2 });

// common config options shown with default values
el.highlight("ffff9c", {
    attr: "background-color", //can be any valid CSS property (attribute) that supports a color value
    endColor: (current color) or "ffffff",
    easing: 'easeIn',
    duration: 1
});
</code></pre>
     * @param {String} color (optional) The highlight color. Should be a 6 char hex color without the leading # (defaults to yellow: 'ffff9c')
     * @param {Object} options (optional) Object literal with any of the Fx config options
     * @return {Roo.Element} The Element
     */	
    highlight : function(C, o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){
            C = C || "ffff9c";
            attr = o.attr || "backgroundColor";

            this.clearOpacity();
            this.show();

            var  D = this.getColor(attr);
            var  E = this.dom.style[attr];
            endColor = (o.endColor || D) || "ffffff";

            var  F = function(){
                el.dom.style[attr] = E;
                el.afterFx(o);
            };

            var  a = {};
            a[attr] = {from: C, to: endColor};
            arguments.callee.anim = this.fxanim(a,
                o,
                'color',
                1,
                'easeIn', F);
        });
        return  this;
    },

   /**
    * Shows a ripple of exploding, attenuating borders to draw attention to an Element.
    * Usage:
<pre><code>
// default: a single light blue ripple
el.frame();

// custom: 3 red ripples lasting 3 seconds total
el.frame("ff0000", 3, { duration: 3 });

// common config options shown with default values
el.frame("C3DAF9", 1, {
    duration: 1 //duration of entire animation (not each individual ripple)
    // Note: Easing is not configurable and will be ignored if included
});
</code></pre>
    * @param {String} color (optional) The color of the border.  Should be a 6 char hex color without the leading # (defaults to light blue: 'C3DAF9').
    * @param {Number} count (optional) The number of ripples to display (defaults to 1)
    * @param {Object} options (optional) Object literal with any of the Fx config options
    * @return {Roo.Element} The Element
    */
    frame : function(D, E, o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){
            D = D || "#C3DAF9";
            if(D.length == 6){
                D = "#" + D;
            }

            E = E || 1;
            duration = o.duration || 1;
            this.show();

            var  b = this.getBox();
            var  F = function(){
                var  G = this.createProxy({

                     style:{
                        visbility:"hidden",
                        position:"absolute",
                        "z-index":"35000", // yee haw
                        border:"0px solid " + D
                     }
                  });
                var  H = Roo.isBorderBox ? 2 : 1;
                G.animate({
                    top:{from:b.y, to:b.y - 20},
                    left:{from:b.x, to:b.x - 20},
                    borderWidth:{from:0, to:10},
                    opacity:{from:1, to:0},
                    height:{from:b.height, to:(b.height + (20*H))},
                    width:{from:b.width, to:(b.width + (20*H))}
                }, duration, function(){
                    G.remove();
                });
                if(--E > 0){
                     F.defer((duration/2)*1000, this);
                }else {
                    el.afterFx(o);
                }
            };
            F.call(this);
        });
        return  this;
    },

   /**
    * Creates a pause before any subsequent queued effects begin.  If there are
    * no effects queued after the pause it will have no effect.
    * Usage:
<pre><code>
el.pause(1);
</code></pre>
    * @param {Number} seconds The length of time to pause (in seconds)
    * @return {Roo.Element} The Element
    */
    pause : function(F){
        var  el = this.getFxEl();
        var  o = {};

        el.queueFx(o, function(){
            setTimeout(function(){
                el.afterFx(o);
            }, F * 1000);
        });
        return  this;
    },

   /**
    * Fade an element in (from transparent to opaque).  The ending opacity can be specified
    * using the "endOpacity" config option.
    * Usage:
<pre><code>
// default: fade in from opacity 0 to 100%
el.fadeIn();

// custom: fade in from opacity 0 to 75% over 2 seconds
el.fadeIn({ endOpacity: .75, duration: 2});

// common config options shown with default values
el.fadeIn({
    endOpacity: 1, //can be any value between 0 and 1 (e.g. .5)
    easing: 'easeOut',
    duration: .5
});
</code></pre>
    * @param {Object} options (optional) Object literal with any of the Fx config options
    * @return {Roo.Element} The Element
    */
    fadeIn : function(o){
        var  el = this.getFxEl();
        o = o || {};
        el.queueFx(o, function(){
            this.setOpacity(0);
            this.fixDisplay();
            this.dom.style.visibility = 'visible';
            var  to = o.endOpacity || 1;
            arguments.callee.anim = this.fxanim({opacity:{to:to}},
                o, null, .5, "easeOut", function(){
                if(to == 1){
                    this.clearOpacity();
                }

                el.afterFx(o);
            });
        });
        return  this;
    },

   /**
    * Fade an element out (from opaque to transparent).  The ending opacity can be specified
    * using the "endOpacity" config option.
    * Usage:
<pre><code>
// default: fade out from the element's current opacity to 0
el.fadeOut();

// custom: fade out from the element's current opacity to 25% over 2 seconds
el.fadeOut({ endOpacity: .25, duration: 2});

// common config options shown with default values
el.fadeOut({
    endOpacity: 0, //can be any value between 0 and 1 (e.g. .5)
    easing: 'easeOut',
    duration: .5
    remove: false,
    useDisplay: false
});
</code></pre>
    * @param {Object} options (optional) Object literal with any of the Fx config options
    * @return {Roo.Element} The Element
    */
    fadeOut : function(o){
        var  el = this.getFxEl();
        o = o || {};
        el.queueFx(o, function(){
            arguments.callee.anim = this.fxanim({opacity:{to:o.endOpacity || 0}},
                o, null, .5, "easeOut", function(){
                if(this.visibilityMode == Roo.Element.DISPLAY || o.useDisplay){
                     this.dom.style.display = "none";
                }else {
                     this.dom.style.visibility = "hidden";
                }

                this.clearOpacity();
                el.afterFx(o);
            });
        });
        return  this;
    },

   /**
    * Animates the transition of an element's dimensions from a starting height/width
    * to an ending height/width.
    * Usage:
<pre><code>
// change height and width to 100x100 pixels
el.scale(100, 100);

// common config options shown with default values.  The height and width will default to
// the element's existing values if passed as null.
el.scale(
    [element's width],
    [element's height], {
    easing: 'easeOut',
    duration: .35
});
</code></pre>
    * @param {Number} width  The new width (pass undefined to keep the original width)
    * @param {Number} height  The new height (pass undefined to keep the original height)
    * @param {Object} options (optional) Object literal with any of the Fx config options
    * @return {Roo.Element} The Element
    */
    scale : function(w, h, o){
        this.shift(Roo.apply({}, o, {
            width: w,
            height: h
        }));
        return  this;
    },

   /**
    * Animates the transition of any combination of an element's dimensions, xy position and/or opacity.
    * Any of these properties not specified in the config object will not be changed.  This effect 
    * requires that at least one new dimension, position or opacity setting must be passed in on
    * the config object in order for the function to have any effect.
    * Usage:
<pre><code>
// slide the element horizontally to x position 200 while changing the height and opacity
el.shift({ x: 200, height: 50, opacity: .8 });

// common config options shown with default values.
el.shift({
    width: [element's width],
    height: [element's height],
    x: [element's x position],
    y: [element's y position],
    opacity: [element's opacity],
    easing: 'easeOut',
    duration: .35
});
</code></pre>
    * @param {Object} options  Object literal with any of the Fx config options
    * @return {Roo.Element} The Element
    */
    shift : function(o){
        var  el = this.getFxEl();
        o = o || {};
        el.queueFx(o, function(){
            var  a = {}, w = o.width, h = o.height, x = o.x, y = o.y,  op = o.opacity;
            if(w !== undefined){
                a.width = {to: this.adjustWidth(w)};
            }
            if(h !== undefined){
                a.height = {to: this.adjustHeight(h)};
            }
            if(x !== undefined || y !== undefined){
                a.points = {to: [
                    x !== undefined ? x : this.getX(),
                    y !== undefined ? y : this.getY()
                ]};
            }
            if(op !== undefined){
                a.opacity = {to: op};
            }
            if(o.xy !== undefined){
                a.points = {to: o.xy};
            }

            arguments.callee.anim = this.fxanim(a,
                o, 'motion', .35, "easeOut", function(){
                el.afterFx(o);
            });
        });
        return  this;
    },

	/**
	 * Slides the element while fading it out of view.  An anchor point can be optionally passed to set the 
	 * ending point of the effect.
	 * Usage:
	 *<pre><code>
// default: slide the element downward while fading out
el.ghost();

// custom: slide the element out to the right with a 2-second duration
el.ghost('r', { duration: 2 });

// common config options shown with default values
el.ghost('b', {
    easing: 'easeOut',
    duration: .5
    remove: false,
    useDisplay: false
});
</code></pre>
	 * @param {String} anchor (optional) One of the valid Fx anchor positions (defaults to bottom: 'b')
	 * @param {Object} options (optional) Object literal with any of the Fx config options
	 * @return {Roo.Element} The Element
	 */
    ghost : function(G, o){
        var  el = this.getFxEl();
        o = o || {};

        el.queueFx(o, function(){
            G = G || "b";

            // restore values after effect
            var  r = this.getFxRestore();
            var  w = this.getWidth(),
                h = this.getHeight();

            var  st = this.dom.style;

            var  H = function(){
                if(o.useDisplay){
                    el.setDisplayed(false);
                }else {
                    el.hide();
                }


                el.clearOpacity();
                el.setPositioning(r.pos);
                st.width = r.width;
                st.height = r.height;

                el.afterFx(o);
            };

            var  a = {opacity: {to: 0}, points: {}}, pt = a.points;
            switch(G.toLowerCase()){
                case  "t":
                    pt.by = [0, -h];
                break;
                case  "l":
                    pt.by = [-w, 0];
                break;
                case  "r":
                    pt.by = [w, 0];
                break;
                case  "b":
                    pt.by = [0, h];
                break;
                case  "tl":
                    pt.by = [-w, -h];
                break;
                case  "bl":
                    pt.by = [-w, h];
                break;
                case  "br":
                    pt.by = [w, h];
                break;
                case  "tr":
                    pt.by = [w, -h];
                break;
            }


            arguments.callee.anim = this.fxanim(a,
                o,
                'motion',
                .5,
                "easeOut", H);
        });
        return  this;
    },

	/**
	 * Ensures that all effects queued after syncFx is called on the element are
	 * run concurrently.  This is the opposite of {@link #sequenceFx}.
	 * @return {Roo.Element} The Element
	 */
    syncFx : function(){
        this.fxDefaults = Roo.apply(this.fxDefaults || {}, {
            block : false,
            concurrent : true,
            stopFx : false
        });
        return  this;
    },

	/**
	 * Ensures that all effects queued after sequenceFx is called on the element are
	 * run in sequence.  This is the opposite of {@link #syncFx}.
	 * @return {Roo.Element} The Element
	 */
    sequenceFx : function(){
        this.fxDefaults = Roo.apply(this.fxDefaults || {}, {
            block : false,
            concurrent : false,
            stopFx : false
        });
        return  this;
    },

	/* @private */
    nextFx : function(){
        var  ef = this.fxQueue[0];
        if(ef){
            ef.call(this);
        }
    },

	/**
	 * Returns true if the element has any effects actively running or queued, else returns false.
	 * @return {Boolean} True if element has active effects, else false
	 */
    hasActiveFx : function(){
        return  this.fxQueue && this.fxQueue[0];
    },

	/**
	 * Stops any running effects and clears the element's internal effects queue if it contains
	 * any additional effects that haven't started yet.
	 * @return {Roo.Element} The Element
	 */
    stopFx : function(){
        if(this.hasActiveFx()){
            var  cur = this.fxQueue[0];
            if(cur && cur.anim && cur.anim.isAnimated()){
                this.fxQueue = [cur]; // clear out others
                cur.anim.stop(true);
            }
        }
        return  this;
    },

	/* @private */
    beforeFx : function(o){
        if(this.hasActiveFx() && !o.concurrent){
           if(o.stopFx){
               this.stopFx();
               return  true;
           }
           return  false;
        }
        return  true;
    },

	/**
	 * Returns true if the element is currently blocking so that no other effect can be queued
	 * until this effect is finished, else returns false if blocking is not set.  This is commonly
	 * used to ensure that an effect initiated by a user action runs to completion prior to the
	 * same effect being restarted (e.g., firing only one effect even if the user clicks several times).
	 * @return {Boolean} True if blocking, else false
	 */
    hasFxBlock : function(){
        var  q = this.fxQueue;
        return  q && q[0] && q[0].block;
    },

	/* @private */
    queueFx : function(o, fn){
        if(!this.fxQueue){
            this.fxQueue = [];
        }
        if(!this.hasFxBlock()){
            Roo.applyIf(o, this.fxDefaults);
            if(!o.concurrent){
                var  run = this.beforeFx(o);
                fn.block = o.block;
                this.fxQueue.push(fn);
                if(run){
                    this.nextFx();
                }
            }else {
                fn.call(this);
            }
        }
        return  this;
    },

	/* @private */
    fxWrap : function(H, o, I){
        var  J;
        if(!o.wrap || !(J = Roo.get(o.wrap))){
            var  wrapXY;
            if(o.fixPosition){
                wrapXY = this.getXY();
            }
            var  div = document.createElement("div");
            div.style.visibility = I;
            J = Roo.get(this.dom.parentNode.insertBefore(div, this.dom));
            J.setPositioning(H);
            if(J.getStyle("position") == "static"){
                J.position("relative");
            }

            this.clearPositioning('auto');
            J.clip();
            J.dom.appendChild(this.dom);
            if(wrapXY){
                J.setXY(wrapXY);
            }
        }
        return  J;
    },

	/* @private */
    fxUnwrap : function(K, L, o){
        this.clearPositioning();
        this.setPositioning(L);
        if(!o.wrap){
            K.dom.parentNode.insertBefore(this.dom, K.dom);
            K.remove();
        }
    },

	/* @private */
    getFxRestore : function(){
        var  st = this.dom.style;
        return  {pos: this.getPositioning(), width: st.width, height : st.height};
    },

	/* @private */
    afterFx : function(o){
        if(o.afterStyle){
            this.applyStyles(o.afterStyle);
        }
        if(o.afterCls){
            this.addClass(o.afterCls);
        }
        if(o.remove === true){
            this.remove();
        }

        Roo.callback(o.callback, o.scope, [this]);
        if(!o.concurrent){
            this.fxQueue.shift();
            this.nextFx();
        }
    },

	/* @private */
    getFxEl : function(){ // support for composite element fx
        return  Roo.get(this.dom);
    },

	/* @private */
    fxanim : function(M, N, O, P, Q, cb){
        O = O || 'run';
        N = N || {};
        var  R = Roo.lib.Anim[O](
            this.dom, M,
            (N.duration || P) || .35,
            (N.easing || Q) || 'easeOut',
            function(){
                Roo.callback(cb, this);
            },
            this
        );
        N.anim = R;
        return  R;
    }
};

// backwords compat
Roo.Fx.resize = Roo.Fx.scale;

//When included, Roo.Fx is automatically applied to Element so that all basic
//effects are available directly via the Element API
Roo.apply(Roo.Element.prototype, Roo.Fx);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.CompositeElement
 * Standard composite class. Creates a Roo.Element for every element in the collection.
 * <br><br>
 * <b>NOTE: Although they are not listed, this class supports all of the set/update methods of Roo.Element. All Roo.Element
 * actions will be performed on all the elements in this collection.</b>
 * <br><br>
 * All methods return <i>this</i> and can be chained.
 <pre><code>
 var els = Roo.select("#some-el div.some-class", true);
 // or select directly from an existing element
 var el = Roo.get('some-el');
 el.select('div.some-class', true);

 els.setWidth(100); // all elements become 100 width
 els.hide(true); // all elements fade out and hide
 // or
 els.setWidth(100).hide(true);
 </code></pre>
 */
Roo.CompositeElement = function(A){
    this.elements = [];
    this.addElements(A);
};
Roo.CompositeElement.prototype = {
    isComposite: true,
    addElements : function(B){
        if(!B) return  this;
        if(typeof  B == "string"){
            B = Roo.Element.selectorFunction(B);
        }
        var  C = this.elements;
        var  D = C.length-1;
        for(var  i = 0, len = B.length; i < len; i++) {
        	C[++D] = Roo.get(B[i]);
        }
        return  this;
    },

    /**
    * Clears this composite and adds the elements returned by the passed selector.
    * @param {String/Array} els A string CSS selector, an array of elements or an element
    * @return {CompositeElement} this
    */
    fill : function(E){
        this.elements = [];
        this.add(E);
        return  this;
    },

    /**
    * Filters this composite to only elements that match the passed selector.
    * @param {String} selector A string CSS selector
    * @return {CompositeElement} this
    */
    filter : function(F){
        var  G = [];
        this.each(function(el){
            if(el.is(F)){
                G[G.length] = el.dom;
            }
        });
        this.fill(G);
        return  this;
    },

    invoke : function(fn, H){
        var  I = this.elements;
        for(var  i = 0, len = I.length; i < len; i++) {
        	Roo.Element.prototype[fn].apply(I[i], H);
        }
        return  this;
    },
    /**
    * Adds elements to this composite.
    * @param {String/Array} els A string CSS selector, an array of elements or an element
    * @return {CompositeElement} this
    */
    add : function(J){
        if(typeof  J == "string"){
            this.addElements(Roo.Element.selectorFunction(J));
        }else  if(J.length !== undefined){
            this.addElements(J);
        }else {
            this.addElements([J]);
        }
        return  this;
    },
    /**
    * Calls the passed function passing (el, this, index) for each element in this composite.
    * @param {Function} fn The function to call
    * @param {Object} scope (optional) The <i>this</i> object (defaults to the element)
    * @return {CompositeElement} this
    */
    each : function(fn, K){
        var  L = this.elements;
        for(var  i = 0, len = L.length; i < len; i++){
            if(fn.call(K || L[i], L[i], this, i) === false) {
                break;
            }
        }
        return  this;
    },

    /**
     * Returns the Element object at the specified index
     * @param {Number} index
     * @return {Roo.Element}
     */
    item : function(M){
        return  this.elements[M] || null;
    },

    /**
     * Returns the first Element
     * @return {Roo.Element}
     */
    first : function(){
        return  this.item(0);
    },

    /**
     * Returns the last Element
     * @return {Roo.Element}
     */
    last : function(){
        return  this.item(this.elements.length-1);
    },

    /**
     * Returns the number of elements in this composite
     * @return Number
     */
    getCount : function(){
        return  this.elements.length;
    },

    /**
     * Returns true if this composite contains the passed element
     * @return Boolean
     */
    contains : function(el){
        return  this.indexOf(el) !== -1;
    },

    /**
     * Returns true if this composite contains the passed element
     * @return Boolean
     */
    indexOf : function(el){
        return  this.elements.indexOf(Roo.get(el));
    },


    /**
    * Removes the specified element(s).
    * @param {Mixed} el The id of an element, the Element itself, the index of the element in this composite
    * or an array of any of those.
    * @param {Boolean} removeDom (optional) True to also remove the element from the document
    * @return {CompositeElement} this
    */
    removeElement : function(el, N){
        if(el  instanceof  Array){
            for(var  i = 0, len = el.length; i < len; i++){
                this.removeElement(el[i]);
            }
            return  this;
        }
        var  O = typeof  el == 'number' ? el : this.indexOf(el);
        if(O !== -1){
            if(N){
                var  d = this.elements[O];
                if(d.dom){
                    d.remove();
                }else {
                    d.parentNode.removeChild(d);
                }
            }

            this.elements.splice(O, 1);
        }
        return  this;
    },

    /**
    * Replaces the specified element with the passed element.
    * @param {String/HTMLElement/Element/Number} el The id of an element, the Element itself, the index of the element in this composite
    * to replace.
    * @param {String/HTMLElement/Element} replacement The id of an element or the Element itself.
    * @param {Boolean} domReplace (Optional) True to remove and replace the element in the document too.
    * @return {CompositeElement} this
    */
    replaceElement : function(el, P, Q){
        var  R = typeof  el == 'number' ? el : this.indexOf(el);
        if(R !== -1){
            if(Q){
                this.elements[R].replaceWith(P);
            }else {
                this.elements.splice(R, 1, Roo.get(P))
            }
        }
        return  this;
    },

    /**
     * Removes all elements.
     */
    clear : function(){
        this.elements = [];
    }
};
(function(){
    Roo.CompositeElement.createCall = function(S, T){
        if(!S[T]){
            S[T] = function(){
                return  this.invoke(T, arguments);
            };
        }
    };
    for(var  fnName  in  Roo.Element.prototype){
        if(typeof  Roo.Element.prototype[fnName] == "function"){
            Roo.CompositeElement.createCall(Roo.CompositeElement.prototype, fnName);
        }
    };
})();

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.CompositeElementLite
 * @extends Roo.CompositeElement
 * Flyweight composite class. Reuses the same Roo.Element for element operations.
 <pre><code>
 var els = Roo.select("#some-el div.some-class");
 // or select directly from an existing element
 var el = Roo.get('some-el');
 el.select('div.some-class');

 els.setWidth(100); // all elements become 100 width
 els.hide(true); // all elements fade out and hide
 // or
 els.setWidth(100).hide(true);
 </code></pre><br><br>
 * <b>NOTE: Although they are not listed, this class supports all of the set/update methods of Roo.Element. All Roo.Element
 * actions will be performed on all the elements in this collection.</b>
 */
Roo.CompositeElementLite = function(A){
    Roo.CompositeElementLite.superclass.constructor.call(this, A);
    this.el = new  Roo.Element.Flyweight();
};
Roo.extend(Roo.CompositeElementLite, Roo.CompositeElement, {
    addElements : function(B){
        if(B){
            if(B  instanceof  Array){
                this.elements = this.elements.concat(B);
            }else {
                var  yels = this.elements;
                var  index = yels.length-1;
                for(var  i = 0, len = B.length; i < len; i++) {
                    yels[++index] = B[i];
                }
            }
        }
        return  this;
    },
    invoke : function(fn, C){
        var  D = this.elements;
        var  el = this.el;
        for(var  i = 0, len = D.length; i < len; i++) {
            el.dom = D[i];
        	Roo.Element.prototype[fn].apply(el, C);
        }
        return  this;
    },
    /**
     * Returns a flyweight Element of the dom element object at the specified index
     * @param {Number} index
     * @return {Roo.Element}
     */
    item : function(E){
        if(!this.elements[E]){
            return  null;
        }

        this.el.dom = this.elements[E];
        return  this.el;
    },

    // fixes scope with flyweight
    addListener : function(F, G, H, I){
        var  J = this.elements;
        for(var  i = 0, len = J.length; i < len; i++) {
            Roo.EventManager.on(J[i], F, G, H || J[i], I);
        }
        return  this;
    },

    /**
    * Calls the passed function passing (el, this, index) for each element in this composite. <b>The element
    * passed is the flyweight (shared) Roo.Element instance, so if you require a
    * a reference to the dom node, use el.dom.</b>
    * @param {Function} fn The function to call
    * @param {Object} scope (optional) The <i>this</i> object (defaults to the element)
    * @return {CompositeElement} this
    */
    each : function(fn, K){
        var  L = this.elements;
        var  el = this.el;
        for(var  i = 0, len = L.length; i < len; i++){
            el.dom = L[i];
        	if(fn.call(K || el, el, this, i) === false){
                break;
            }
        }
        return  this;
    },

    indexOf : function(el){
        return  this.elements.indexOf(Roo.getDom(el));
    },

    replaceElement : function(el, M, N){
        var  O = typeof  el == 'number' ? el : this.indexOf(el);
        if(O !== -1){
            M = Roo.getDom(M);
            if(N){
                var  d = this.elements[O];
                d.parentNode.insertBefore(M, d);
                d.parentNode.removeChild(d);
            }

            this.elements.splice(O, 1, M);
        }
        return  this;
    }
});
Roo.CompositeElementLite.prototype.on = Roo.CompositeElementLite.prototype.addListener;


/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 

/**
 * @class Roo.data.Connection
 * @extends Roo.util.Observable
 * The class encapsulates a connection to the page's originating domain, allowing requests to be made
 * either to a configured URL, or to a URL specified at request time.<br><br>
 * <p>
 * Requests made by this class are asynchronous, and will return immediately. No data from
 * the server will be available to the statement immediately following the {@link #request} call.
 * To process returned data, use a callback in the request options object, or an event listener.</p><br>
 * <p>
 * Note: If you are doing a file upload, you will not get a normal response object sent back to
 * your callback or event handler.  Since the upload is handled via in IFRAME, there is no XMLHttpRequest.
 * The response object is created using the innerHTML of the IFRAME's document as the responseText
 * property and, if present, the IFRAME's XML document as the responseXML property.</p><br>
 * This means that a valid XML or HTML document must be returned. If JSON data is required, it is suggested
 * that it be placed either inside a &lt;textarea> in an HTML document and retrieved from the responseText
 * using a regex, or inside a CDATA section in an XML document and retrieved from the responseXML using
 * standard DOM methods.
 * @constructor
 * @param {Object} config a configuration object.
 */
Roo.data.Connection = function(A){
    Roo.apply(this, A);
    this.addEvents({
        /**
         * @event beforerequest
         * Fires before a network request is made to retrieve a data object.
         * @param {Connection} conn This Connection object.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        "beforerequest" : true,
        /**
         * @event requestcomplete
         * Fires if the request was successfully completed.
         * @param {Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See {@link http://www.w3.org/TR/XMLHttpRequest/} for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        "requestcomplete" : true,
        /**
         * @event requestexception
         * Fires if an error HTTP status was returned from the server.
         * See {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html} for details of HTTP status codes.
         * @param {Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See {@link http://www.w3.org/TR/XMLHttpRequest/} for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        "requestexception" : true
    });
    Roo.data.Connection.superclass.constructor.call(this);
};

Roo.extend(Roo.data.Connection, Roo.util.Observable, {
    /**
     * @cfg {String} url (Optional) The default URL to be used for requests to the server. (defaults to undefined)
     */
    /**
     * @cfg {Object} extraParams (Optional) An object containing properties which are used as
     * extra parameters to each request made by this object. (defaults to undefined)
     */
    /**
     * @cfg {Object} defaultHeaders (Optional) An object containing request headers which are added
     *  to each request made by this object. (defaults to undefined)
     */
    /**
     * @cfg {String} method (Optional) The default HTTP method to be used for requests. (defaults to undefined; if not set but parms are present will use POST, otherwise GET)
     */
    /**
     * @cfg {Number} timeout (Optional) The timeout in milliseconds to be used for requests. (defaults to 30000)
     */
    timeout : 30000,
    /**
     * @cfg {Boolean} autoAbort (Optional) Whether this request should abort any pending requests. (defaults to false)
     * @type Boolean
     */
    autoAbort:false,

    /**
     * @cfg {Boolean} disableCaching (Optional) True to add a unique cache-buster param to GET requests. (defaults to true)
     * @type Boolean
     */
    disableCaching: true,

    /**
     * Sends an HTTP request to a remote server.
     * @param {Object} options An object which may contain the following properties:<ul>
     * <li><b>url</b> {String} (Optional) The URL to which to send the request. Defaults to configured URL</li>
     * <li><b>params</b> {Object/String/Function} (Optional) An object containing properties which are used as parameters to the
     * request, a url encoded string or a function to call to get either.</li>
     * <li><b>method</b> {String} (Optional) The HTTP method to use for the request. Defaults to the configured method, or
     * if no method was configured, "GET" if no parameters are being sent, and "POST" if parameters are being sent.</li>
     * <li><b>callback</b> {Function} (Optional) The function to be called upon receipt of the HTTP response.
     * The callback is called regardless of success or failure and is passed the following parameters:<ul>
     * <li>options {Object} The parameter to the request call.</li>
     * <li>success {Boolean} True if the request succeeded.</li>
     * <li>response {Object} The XMLHttpRequest object containing the response data.</li>
     * </ul></li>
     * <li><b>success</b> {Function} (Optional) The function to be called upon success of the request.
     * The callback is passed the following parameters:<ul>
     * <li>response {Object} The XMLHttpRequest object containing the response data.</li>
     * <li>options {Object} The parameter to the request call.</li>
     * </ul></li>
     * <li><b>failure</b> {Function} (Optional) The function to be called upon failure of the request.
     * The callback is passed the following parameters:<ul>
     * <li>response {Object} The XMLHttpRequest object containing the response data.</li>
     * <li>options {Object} The parameter to the request call.</li>
     * </ul></li>
     * <li><b>scope</b> {Object} (Optional) The scope in which to execute the callbacks: The "this" object
     * for the callback function. Defaults to the browser window.</li>
     * <li><b>form</b> {Object/String} (Optional) A form object or id to pull parameters from.</li>
     * <li><b>isUpload</b> {Boolean} (Optional) True if the form object is a file upload (will usually be automatically detected).</li>
     * <li><b>headers</b> {Object} (Optional) Request headers to set for the request.</li>
     * <li><b>xmlData</b> {Object} (Optional) XML document to use for the post. Note: This will be used instead of
     * params for the post data. Any params will be appended to the URL.</li>
     * <li><b>disableCaching</b> {Boolean} (Optional) True to add a unique cache-buster param to GET requests.</li>
     * </ul>
     * @return {Number} transactionId
     */
    request : function(o){
        if(this.fireEvent("beforerequest", this, o) !== false){
            var  p = o.params;

            if(typeof  p == "function"){
                p = p.call(o.scope||window, o);
            }
            if(typeof  p == "object"){
                p = Roo.urlEncode(o.params);
            }
            if(this.extraParams){
                var  extras = Roo.urlEncode(this.extraParams);
                p = p ? (p + '&' + extras) : extras;
            }

            var  url = o.url || this.url;
            if(typeof  url == 'function'){
                url = url.call(o.scope||window, o);
            }

            if(o.form){
                var  form = Roo.getDom(o.form);
                url = url || form.action;

                var  enctype = form.getAttribute("enctype");
                if(o.isUpload || (enctype && enctype.toLowerCase() == 'multipart/form-data')){
                    return  this.doFormUpload(o, p, url);
                }
                var  f = Roo.lib.Ajax.serializeForm(form);
                p = p ? (p + '&' + f) : f;
            }

            var  hs = o.headers;
            if(this.defaultHeaders){
                hs = Roo.apply(hs || {}, this.defaultHeaders);
                if(!o.headers){
                    o.headers = hs;
                }
            }

            var  cb = {
                success: this.handleResponse,
                failure: this.handleFailure,
                scope: this,
                argument: {options: o},
                timeout : this.timeout
            };

            var  method = o.method||this.method||(p ? "POST" : "GET");

            if(method == 'GET' && (this.disableCaching && o.disableCaching !== false) || o.disableCaching === true){
                url += (url.indexOf('?') != -1 ? '&' : '?') + '_dc=' + (new  Date().getTime());
            }

            if(typeof  o.autoAbort == 'boolean'){ // options gets top priority
                if(o.autoAbort){
                    this.abort();
                }
            }else  if(this.autoAbort !== false){
                this.abort();
            }

            if((method == 'GET' && p) || o.xmlData){
                url += (url.indexOf('?') != -1 ? '&' : '?') + p;
                p = '';
            }

            this.transId = Roo.lib.Ajax.request(method, url, cb, p, o);
            return  this.transId;
        }else {
            Roo.callback(o.callback, o.scope, [o, null, null]);
            return  null;
        }
    },

    /**
     * Determine whether this object has a request outstanding.
     * @param {Number} transactionId (Optional) defaults to the last transaction
     * @return {Boolean} True if there is an outstanding request.
     */
    isLoading : function(B){
        if(B){
            return  Roo.lib.Ajax.isCallInProgress(B);
        }else {
            return  this.transId ? true : false;
        }
    },

    /**
     * Aborts any outstanding request.
     * @param {Number} transactionId (Optional) defaults to the last transaction
     */
    abort : function(C){
        if(C || this.isLoading()){
            Roo.lib.Ajax.abort(C || this.transId);
        }
    },

    // private
    handleResponse : function(D){
        this.transId = false;
        var  E = D.argument.options;
        D.argument = E ? E.argument : null;
        this.fireEvent("requestcomplete", this, D, E);
        Roo.callback(E.success, E.scope, [D, E]);
        Roo.callback(E.callback, E.scope, [E, true, D]);
    },

    // private
    handleFailure : function(F, e){
        this.transId = false;
        var  G = F.argument.options;
        F.argument = G ? G.argument : null;
        this.fireEvent("requestexception", this, F, G, e);
        Roo.callback(G.failure, G.scope, [F, G]);
        Roo.callback(G.callback, G.scope, [G, false, F]);
    },

    // private
    doFormUpload : function(o, ps, H){
        var  id = Roo.id();
        var  I = document.createElement('iframe');
        I.id = id;
        I.name = id;
        I.className = 'x-hidden';
        if(Roo.isIE){
            I.src = Roo.SSL_SECURE_URL;
        }

        document.body.appendChild(I);

        if(Roo.isIE){
           document.frames[id].name = id;
        }

        var  J = Roo.getDom(o.form);
        J.target = id;
        J.method = 'POST';
        J.enctype = J.encoding = 'multipart/form-data';
        if(H){
            J.action = H;
        }

        var  K, hd;
        if(ps){ // add dynamic params
            K = [];
            ps = Roo.urlDecode(ps, false);
            for(var  k  in  ps){
                if(ps.hasOwnProperty(k)){
                    hd = document.createElement('input');
                    hd.type = 'hidden';
                    hd.name = k;
                    hd.value = ps[k];
                    J.appendChild(hd);
                    K.push(hd);
                }
            }
        }

        function  cb(){
            var  r = {  // bogus response object
                responseText : '',
                responseXML : null
            };

            r.argument = o ? o.argument : null;

            try { //
                var  doc;
                if(Roo.isIE){
                    doc = I.contentWindow.document;
                }else  {
                    doc = (I.contentDocument || window.frames[id].document);
                }
                if(doc && doc.body){
                    r.responseText = doc.body.innerHTML;
                }
                if(doc && doc.XMLDocument){
                    r.responseXML = doc.XMLDocument;
                }else  {
                    r.responseXML = doc;
                }
            }
            catch(e) {
                // ignore
            }


            Roo.EventManager.removeListener(I, 'load', cb, this);

            this.fireEvent("requestcomplete", this, r, o);
            Roo.callback(o.success, o.scope, [r, o]);
            Roo.callback(o.callback, o.scope, [o, true, r]);

            setTimeout(function(){document.body.removeChild(I);}, 100);
        }


        Roo.EventManager.on(I, 'load', cb, this);
        J.submit();

        if(K){ // remove dynamic params
            for(var  i = 0, len = K.length; i < len; i++){
                J.removeChild(K[i]);
            }
        }
    }
});

/**
 * @class Roo.Ajax
 * @extends Roo.data.Connection
 * Global Ajax request class.
 *
 * @singleton
 */
Roo.Ajax = new  Roo.data.Connection({
    // fix up the docs
   /**
     * @cfg {String} url @hide
     */
    /**
     * @cfg {Object} extraParams @hide
     */
    /**
     * @cfg {Object} defaultHeaders @hide
     */
    /**
     * @cfg {String} method (Optional) @hide
     */
    /**
     * @cfg {Number} timeout (Optional) @hide
     */
    /**
     * @cfg {Boolean} autoAbort (Optional) @hide
     */

    /**
     * @cfg {Boolean} disableCaching (Optional) @hide
     */

    /**
     * @property  disableCaching
     * True to add a unique cache-buster param to GET requests. (defaults to true)
     * @type Boolean
     */
    /**
     * @property  url
     * The default URL to be used for requests to the server. (defaults to undefined)
     * @type String
     */
    /**
     * @property  extraParams
     * An object containing properties which are used as
     * extra parameters to each request made by this object. (defaults to undefined)
     * @type Object
     */
    /**
     * @property  defaultHeaders
     * An object containing request headers which are added to each request made by this object. (defaults to undefined)
     * @type Object
     */
    /**
     * @property  method
     * The default HTTP method to be used for requests. (defaults to undefined; if not set but parms are present will use POST, otherwise GET)
     * @type String
     */
    /**
     * @property  timeout
     * The timeout in milliseconds to be used for requests. (defaults to 30000)
     * @type Number
     */

    /**
     * @property  autoAbort
     * Whether a new request should abort any pending requests. (defaults to false)
     * @type Boolean
     */
    autoAbort : false,

    /**
     * Serialize the passed form into a url encoded string
     * @param {String/HTMLElement} form
     * @return {String}
     */
    serializeForm : function(L){
        return  Roo.lib.Ajax.serializeForm(L);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.Ajax
 * @extends Roo.data.Connection
 * Global Ajax request class.
 *
 * @instanceOf  Roo.data.Connection
 */
Roo.Ajax = new  Roo.data.Connection({
    // fix up the docs
    
    /**
     * fix up scoping
     * @scope Roo.Ajax
     */
    
   /**
     * @cfg {String} url @hide
     */
    /**
     * @cfg {Object} extraParams @hide
     */
    /**
     * @cfg {Object} defaultHeaders @hide
     */
    /**
     * @cfg {String} method (Optional) @hide
     */
    /**
     * @cfg {Number} timeout (Optional) @hide
     */
    /**
     * @cfg {Boolean} autoAbort (Optional) @hide
     */

    /**
     * @cfg {Boolean} disableCaching (Optional) @hide
     */

    /**
     * @property  disableCaching
     * True to add a unique cache-buster param to GET requests. (defaults to true)
     * @type Boolean
     */
    /**
     * @property  url
     * The default URL to be used for requests to the server. (defaults to undefined)
     * @type String
     */
    /**
     * @property  extraParams
     * An object containing properties which are used as
     * extra parameters to each request made by this object. (defaults to undefined)
     * @type Object
     */
    /**
     * @property  defaultHeaders
     * An object containing request headers which are added to each request made by this object. (defaults to undefined)
     * @type Object
     */
    /**
     * @property  method
     * The default HTTP method to be used for requests. (defaults to undefined; if not set but parms are present will use POST, otherwise GET)
     * @type String
     */
    /**
     * @property  timeout
     * The timeout in milliseconds to be used for requests. (defaults to 30000)
     * @type Number
     */

    /**
     * @property  autoAbort
     * Whether a new request should abort any pending requests. (defaults to false)
     * @type Boolean
     */
    autoAbort : false,

    /**
     * Serialize the passed form into a url encoded string
     * @param {String/HTMLElement} form
     * @return {String}
     */
    serializeForm : function(A){
        return  Roo.lib.Ajax.serializeForm(A);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.UpdateManager
 * @extends Roo.util.Observable
 * Provides AJAX-style update for Element object.<br><br>
 * Usage:<br>
 * <pre><code>
 * // Get it from a Roo.Element object
 * var el = Roo.get("foo");
 * var mgr = el.getUpdateManager();
 * mgr.update("http://myserver.com/index.php", "param1=1&amp;param2=2");
 * ...
 * mgr.formUpdate("myFormId", "http://myserver.com/index.php");
 * <br>
 * // or directly (returns the same UpdateManager instance)
 * var mgr = new Roo.UpdateManager("myElementId");
 * mgr.startAutoRefresh(60, "http://myserver.com/index.php");
 * mgr.on("update", myFcnNeedsToKnow);
 * <br>
   // short handed call directly from the element object
   Roo.get("foo").load({
        url: "bar.php",
        scripts:true,
        params: "for=bar",
        text: "Loading Foo..."
   });
 * </code></pre>
 * @constructor
 * Create new UpdateManager directly.
 * @param {String/HTMLElement/Roo.Element} el The element to update
 * @param {Boolean} forceNew (optional) By default the constructor checks to see if the passed element already has an UpdateManager and if it does it returns the same instance. This will skip that check (useful for extending this class).
 */
Roo.UpdateManager = function(el, A){
    el = Roo.get(el);
    if(!A && el.updateManager){
        return  el.updateManager;
    }

    /**
     * The Element object
     * @type Roo.Element
     */
    this.el = el;
    /**
     * Cached url to use for refreshes. Overwritten every time update() is called unless "discardUrl" param is set to true.
     * @type String
     */
    this.defaultUrl = null;

    this.addEvents({
        /**
         * @event beforeupdate
         * Fired before an update is made, return false from your handler and the update is cancelled.
         * @param {Roo.Element} el
         * @param {String/Object/Function} url
         * @param {String/Object} params
         */
        "beforeupdate": true,
        /**
         * @event update
         * Fired after successful update is made.
         * @param {Roo.Element} el
         * @param {Object} oResponseObject The response Object
         */
        "update": true,
        /**
         * @event failure
         * Fired on update failure.
         * @param {Roo.Element} el
         * @param {Object} oResponseObject The response Object
         */
        "failure": true
    });
    var  d = Roo.UpdateManager.defaults;
    /**
     * Blank page URL to use with SSL file uploads (Defaults to Roo.UpdateManager.defaults.sslBlankUrl or "about:blank").
     * @type String
     */
    this.sslBlankUrl = d.sslBlankUrl;
    /**
     * Whether to append unique parameter on get request to disable caching (Defaults to Roo.UpdateManager.defaults.disableCaching or false).
     * @type Boolean
     */
    this.disableCaching = d.disableCaching;
    /**
     * Text for loading indicator (Defaults to Roo.UpdateManager.defaults.indicatorText or '&lt;div class="loading-indicator"&gt;Loading...&lt;/div&gt;').
     * @type String
     */
    this.indicatorText = d.indicatorText;
    /**
     * Whether to show indicatorText when loading (Defaults to Roo.UpdateManager.defaults.showLoadIndicator or true).
     * @type String
     */
    this.showLoadIndicator = d.showLoadIndicator;
    /**
     * Timeout for requests or form posts in seconds (Defaults to Roo.UpdateManager.defaults.timeout or 30 seconds).
     * @type Number
     */
    this.timeout = d.timeout;

    /**
     * True to process scripts in the output (Defaults to Roo.UpdateManager.defaults.loadScripts (false)).
     * @type Boolean
     */
    this.loadScripts = d.loadScripts;

    /**
     * Transaction object of current executing transaction
     */
    this.transaction = null;

    /**
     * @private
     */
    this.autoRefreshProcId = null;
    /**
     * Delegate for refresh() prebound to "this", use myUpdater.refreshDelegate.createCallback(arg1, arg2) to bind arguments
     * @type Function
     */
    this.refreshDelegate = this.refresh.createDelegate(this);
    /**
     * Delegate for update() prebound to "this", use myUpdater.updateDelegate.createCallback(arg1, arg2) to bind arguments
     * @type Function
     */
    this.updateDelegate = this.update.createDelegate(this);
    /**
     * Delegate for formUpdate() prebound to "this", use myUpdater.formUpdateDelegate.createCallback(arg1, arg2) to bind arguments
     * @type Function
     */
    this.formUpdateDelegate = this.formUpdate.createDelegate(this);
    /**
     * @private
     */
    this.successDelegate = this.processSuccess.createDelegate(this);
    /**
     * @private
     */
    this.failureDelegate = this.processFailure.createDelegate(this);

    if(!this.renderer){
     /**
      * The renderer for this UpdateManager. Defaults to {@link Roo.UpdateManager.BasicRenderer}.
      */
    this.renderer = new  Roo.UpdateManager.BasicRenderer();
    }

    
    Roo.UpdateManager.superclass.constructor.call(this);
};

Roo.extend(Roo.UpdateManager, Roo.util.Observable, {
    /**
     * Get the Element this UpdateManager is bound to
     * @return {Roo.Element} The element
     */
    getEl : function(){
        return  this.el;
    },
    /**
     * Performs an async request, updating this element with the response. If params are specified it uses POST, otherwise it uses GET.
     * @param {Object/String/Function} url The url for this request or a function to call to get the url or a config object containing any of the following options:
<pre><code>
um.update({<br/>
    url: "your-url.php",<br/>
    params: {param1: "foo", param2: "bar"}, // or a URL encoded string<br/>
    callback: yourFunction,<br/>
    scope: yourObject, //(optional scope)  <br/>
    discardUrl: false, <br/>
    nocache: false,<br/>
    text: "Loading...",<br/>
    timeout: 30,<br/>
    scripts: false<br/>
});
</code></pre>
     * The only required property is url. The optional properties nocache, text and scripts
     * are shorthand for disableCaching, indicatorText and loadScripts and are used to set their associated property on this UpdateManager instance.
     * @param {String/Object} params (optional) The parameters to pass as either a url encoded string "param1=1&amp;param2=2" or an object {param1: 1, param2: 2}
     * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess, oResponse)
     * @param {Boolean} discardUrl (optional) By default when you execute an update the defaultUrl is changed to the last used url. If true, it will not store the url.
     */
    update : function(B, C, D, E){
        if(this.fireEvent("beforeupdate", this.el, B, C) !== false){
            var  method = this.method, cfg;
            if(typeof  B == "object"){ // must be config object
                cfg = B;
                B = cfg.url;
                C = C || cfg.params;
                D = D || cfg.callback;
                E = E || cfg.discardUrl;
                if(D && cfg.scope){
                    D = D.createDelegate(cfg.scope);
                }
                if(typeof  cfg.method != "undefined"){method = cfg.method;};
                if(typeof  cfg.nocache != "undefined"){this.disableCaching = cfg.nocache;};
                if(typeof  cfg.text != "undefined"){this.indicatorText = '<div class="loading-indicator">'+cfg.text+"</div>";};
                if(typeof  cfg.scripts != "undefined"){this.loadScripts = cfg.scripts;};
                if(typeof  cfg.timeout != "undefined"){this.timeout = cfg.timeout;};
            }

            this.showLoading();
            if(!E){
                this.defaultUrl = B;
            }
            if(typeof  B == "function"){
                B = B.call(this);
            }


            method = method || (C ? "POST" : "GET");
            if(method == "GET"){
                B = this.prepareUrl(B);
            }

            var  o = Roo.apply(cfg ||{}, {
                url : B,
                params: C,
                success: this.successDelegate,
                failure: this.failureDelegate,
                callback: undefined,
                timeout: (this.timeout*1000),
                argument: {"url": B, "form": null, "callback": D, "params": C}
            });

            this.transaction = Roo.Ajax.request(o);
        }
    },

    /**
     * Performs an async form post, updating this element with the response. If the form has the attribute enctype="multipart/form-data", it assumes it's a file upload.
     * Uses this.sslBlankUrl for SSL file uploads to prevent IE security warning.
     * @param {String/HTMLElement} form The form Id or form element
     * @param {String} url (optional) The url to pass the form to. If omitted the action attribute on the form will be used.
     * @param {Boolean} reset (optional) Whether to try to reset the form after the update
     * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess, oResponse)
     */
    formUpdate : function(F, G, H, I){
        if(this.fireEvent("beforeupdate", this.el, F, G) !== false){
            if(typeof  G == "function"){
                G = G.call(this);
            }

            F = Roo.getDom(F);
            this.transaction = Roo.Ajax.request({
                form: F,
                url:G,
                success: this.successDelegate,
                failure: this.failureDelegate,
                timeout: (this.timeout*1000),
                argument: {"url": G, "form": F, "callback": I, "reset": H}
            });
            this.showLoading.defer(1, this);
        }
    },

    /**
     * Refresh the element with the last used url or defaultUrl. If there is no url, it returns immediately
     * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess)
     */
    refresh : function(J){
        if(this.defaultUrl == null){
            return;
        }

        this.update(this.defaultUrl, null, J, true);
    },

    /**
     * Set this element to auto refresh.
     * @param {Number} interval How often to update (in seconds).
     * @param {String/Function} url (optional) The url for this request or a function to call to get the url (Defaults to the last used url)
     * @param {String/Object} params (optional) The parameters to pass as either a url encoded string "&param1=1&param2=2" or as an object {param1: 1, param2: 2}
     * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess)
     * @param {Boolean} refreshNow (optional) Whether to execute the refresh now, or wait the interval
     */
    startAutoRefresh : function(K, L, M, N, O){
        if(O){
            this.update(L || this.defaultUrl, M, N, true);
        }
        if(this.autoRefreshProcId){
            clearInterval(this.autoRefreshProcId);
        }

        this.autoRefreshProcId = setInterval(this.update.createDelegate(this, [L || this.defaultUrl, M, N, true]), K*1000);
    },

    /**
     * Stop auto refresh on this element.
     */
     stopAutoRefresh : function(){
        if(this.autoRefreshProcId){
            clearInterval(this.autoRefreshProcId);
            delete  this.autoRefreshProcId;
        }
    },

    isAutoRefreshing : function(){
       return  this.autoRefreshProcId ? true : false;
    },
    /**
     * Called to update the element to "Loading" state. Override to perform custom action.
     */
    showLoading : function(){
        if(this.showLoadIndicator){
            this.el.update(this.indicatorText);
        }
    },

    /**
     * Adds unique parameter to query string if disableCaching = true
     * @private
     */
    prepareUrl : function(P){
        if(this.disableCaching){
            var  append = "_dc=" + (new  Date().getTime());
            if(P.indexOf("?") !== -1){
                P += "&" + append;
            }else {
                P += "?" + append;
            }
        }
        return  P;
    },

    /**
     * @private
     */
    processSuccess : function(Q){
        this.transaction = null;
        if(Q.argument.form && Q.argument.reset){
            try{ // put in try/catch since some older FF releases had problems with this
                Q.argument.form.reset();
            }catch(e){}
        }
        if(this.loadScripts){
            this.renderer.render(this.el, Q, this,
                this.updateComplete.createDelegate(this, [Q]));
        }else {
            this.renderer.render(this.el, Q, this);
            this.updateComplete(Q);
        }
    },

    updateComplete : function(R){
        this.fireEvent("update", this.el, R);
        if(typeof  R.argument.callback == "function"){
            R.argument.callback(this.el, true, R);
        }
    },

    /**
     * @private
     */
    processFailure : function(S){
        this.transaction = null;
        this.fireEvent("failure", this.el, S);
        if(typeof  S.argument.callback == "function"){
            S.argument.callback(this.el, false, S);
        }
    },

    /**
     * Set the content renderer for this UpdateManager. See {@link Roo.UpdateManager.BasicRenderer#render} for more details.
     * @param {Object} renderer The object implementing the render() method
     */
    setRenderer : function(T){
        this.renderer = T;
    },

    getRenderer : function(){
       return  this.renderer;
    },

    /**
     * Set the defaultUrl used for updates
     * @param {String/Function} defaultUrl The url or a function to call to get the url
     */
    setDefaultUrl : function(U){
        this.defaultUrl = U;
    },

    /**
     * Aborts the executing transaction
     */
    abort : function(){
        if(this.transaction){
            Roo.Ajax.abort(this.transaction);
        }
    },

    /**
     * Returns true if an update is in progress
     * @return {Boolean}
     */
    isUpdating : function(){
        if(this.transaction){
            return  Roo.Ajax.isLoading(this.transaction);
        }
        return  false;
    }
});

/**
 * @class Roo.UpdateManager.defaults
 * @static (not really - but it helps the doc tool)
 * The defaults collection enables customizing the default properties of UpdateManager
 */
   Roo.UpdateManager.defaults = {
       /**
         * Timeout for requests or form posts in seconds (Defaults 30 seconds).
         * @type Number
         */
         timeout : 30,

         /**
         * True to process scripts by default (Defaults to false).
         * @type Boolean
         */
        loadScripts : false,

        /**
        * Blank page URL to use with SSL file uploads (Defaults to "javascript:false").
        * @type String
        */
        sslBlankUrl : (Roo.SSL_SECURE_URL || "javascript:false"),
        /**
         * Whether to append unique parameter on get request to disable caching (Defaults to false).
         * @type Boolean
         */
        disableCaching : false,
        /**
         * Whether to show indicatorText when loading (Defaults to true).
         * @type Boolean
         */
        showLoadIndicator : true,
        /**
         * Text for loading indicator (Defaults to '&lt;div class="loading-indicator"&gt;Loading...&lt;/div&gt;').
         * @type String
         */
        indicatorText : '<div class="loading-indicator">Loading...</div>'
   };

/**
 * Static convenience method. This method is deprecated in favor of el.load({url:'foo.php', ...}).
 *Usage:
 * <pre><code>Roo.UpdateManager.updateElement("my-div", "stuff.php");</code></pre>
 * @param {String/HTMLElement/Roo.Element} el The element to update
 * @param {String} url The url
 * @param {String/Object} params (optional) Url encoded param string or an object of name/value pairs
 * @param {Object} options (optional) A config object with any of the UpdateManager properties you want to set - for example: {disableCaching:true, indicatorText: "Loading data..."}
 * @static
 * @deprecated
 * @member Roo.UpdateManager
 */
Roo.UpdateManager.updateElement = function(el, V, W, X){
    var  um = Roo.get(el, true).getUpdateManager();
    Roo.apply(um, X);
    um.update(V, W, X ? X.callback : null);
};
// alias for backwards compat
Roo.UpdateManager.update = Roo.UpdateManager.updateElement;
/**
 * @class Roo.UpdateManager.BasicRenderer
 * Default Content renderer. Updates the elements innerHTML with the responseText.
 */
Roo.UpdateManager.BasicRenderer = function(){};

Roo.UpdateManager.BasicRenderer.prototype = {
    /**
     * This is called when the transaction is completed and it's time to update the element - The BasicRenderer
     * updates the elements innerHTML with the responseText - To perform a custom render (i.e. XML or JSON processing),
     * create an object with a "render(el, response)" method and pass it to setRenderer on the UpdateManager.
     * @param {Roo.Element} el The element being rendered
     * @param {Object} response The YUI Connect response object
     * @param {UpdateManager} updateManager The calling update manager
     * @param {Function} callback A callback that will need to be called if loadScripts is true on the UpdateManager
     */
     render : function(el, Y, Z, a){
        el.update(Y.responseText, Z.loadScripts, a);
    }
};

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.util.DelayedTask
 * Provides a convenient method of performing setTimeout where a new
 * timeout cancels the old timeout. An example would be performing validation on a keypress.
 * You can use this class to buffer
 * the keypress events for a certain number of milliseconds, and perform only if they stop
 * for that amount of time.
 * @constructor The parameters to this constructor serve as defaults and are not required.
 * @param {Function} fn (optional) The default function to timeout
 * @param {Object} scope (optional) The default scope of that timeout
 * @param {Array} args (optional) The default Array of arguments
 */
Roo.util.DelayedTask = function(fn, A, B){
    var  id = null, d, t;

    var  C = function(){
        var  D = new  Date().getTime();
        if(D - t >= d){
            clearInterval(id);
            id = null;
            fn.apply(A, B || []);
        }
    };
    /**
     * Cancels any pending timeout and queues a new one
     * @param {Number} delay The milliseconds to delay
     * @param {Function} newFn (optional) Overrides function passed to constructor
     * @param {Object} newScope (optional) Overrides scope passed to constructor
     * @param {Array} newArgs (optional) Overrides args passed to constructor
     */
    this.delay = function(D, E, F, G){
        if(id && D != d){
            this.cancel();
        }

        d = D;
        t = new  Date().getTime();
        fn = E || fn;
        A = F || A;
        B = G || B;
        if(!id){
            id = setInterval(C, d);
        }
    };

    /**
     * Cancel the last queued timeout
     */
    this.cancel = function(){
        if(id){
            clearInterval(id);
            id = null;
        }
    };
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
 
Roo.util.TaskRunner = function(A){
    A = A || 10;
    var  B = [], C = [];
    var  id = 0;
    var  D = false;

    var  E = function(){
        D = false;
        clearInterval(id);
        id = 0;
    };

    var  F = function(){
        if(!D){
            D = true;
            id = setInterval(H, A);
        }
    };

    var  G = function(I){
        C.push(I);
        if(I.onStop){
            I.onStop();
        }
    };

    var  H = function(){
        if(C.length > 0){
            for(var  i = 0, len = C.length; i < len; i++){
                B.remove(C[i]);
            }

            C = [];
            if(B.length < 1){
                E();
                return;
            }
        }
        var  I = new  Date().getTime();
        for(var  i = 0, len = B.length; i < len; ++i){
            var  t = B[i];
            var  itime = I - t.taskRunTime;
            if(t.interval <= itime){
                var  rt = t.run.apply(t.scope || t, t.args || [++t.taskRunCount]);
                t.taskRunTime = I;
                if(rt === false || t.taskRunCount === t.repeat){
                    G(t);
                    return;
                }
            }
            if(t.duration && t.duration <= (I - t.taskStartTime)){
                G(t);
            }
        }
    };

    /**
     * Queues a new task.
     * @param {Object} task
     */
    this.start = function(I){
        B.push(I);
        I.taskStartTime = new  Date().getTime();
        I.taskRunTime = 0;
        I.taskRunCount = 0;
        F();
        return  I;
    };

    this.stop = function(I){
        G(I);
        return  I;
    };

    this.stopAll = function(){
        E();
        for(var  i = 0, len = B.length; i < len; i++){
            if(B[i].onStop){
                B[i].onStop();
            }
        }

        B = [];
        C = [];
    };
};

Roo.TaskMgr = new  Roo.util.TaskRunner();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.util.MixedCollection
 * @extends Roo.util.Observable
 * A Collection class that maintains both numeric indexes and keys and exposes events.
 * @constructor
 * @param {Boolean} allowFunctions True if the addAll function should add function references to the
 * collection (defaults to false)
 * @param {Function} keyFn A function that can accept an item of the type(s) stored in this MixedCollection
 * and return the key value for that item.  This is used when available to look up the key on items that
 * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
 * equivalent to providing an implementation for the {@link #getKey} method.
 */
Roo.util.MixedCollection = function(A, B){
    this.items = [];
    this.map = {};
    this.keys = [];
    this.length = 0;
    this.addEvents({
        /**
         * @event clear
         * Fires when the collection is cleared.
         */
        "clear" : true,
        /**
         * @event add
         * Fires when an item is added to the collection.
         * @param {Number} index The index at which the item was added.
         * @param {Object} o The item added.
         * @param {String} key The key associated with the added item.
         */
        "add" : true,
        /**
         * @event replace
         * Fires when an item is replaced in the collection.
         * @param {String} key he key associated with the new added.
         * @param {Object} old The item being replaced.
         * @param {Object} new The new item.
         */
        "replace" : true,
        /**
         * @event remove
         * Fires when an item is removed from the collection.
         * @param {Object} o The item being removed.
         * @param {String} key (optional) The key associated with the removed item.
         */
        "remove" : true,
        "sort" : true
    });
    this.allowFunctions = A === true;
    if(B){
        this.getKey = B;
    }

    Roo.util.MixedCollection.superclass.constructor.call(this);
};

Roo.extend(Roo.util.MixedCollection, Roo.util.Observable, {
    allowFunctions : false,
    
/**
 * Adds an item to the collection.
 * @param {String} key The key to associate with the item
 * @param {Object} o The item to add.
 * @return {Object} The item added.
 */
    add : function(C, o){
        if(arguments.length == 1){
            o = arguments[0];
            C = this.getKey(o);
        }
        if(typeof  C == "undefined" || C === null){
            this.length++;
            this.items.push(o);
            this.keys.push(null);
        }else {
            var  old = this.map[C];
            if(old){
                return  this.replace(C, o);
            }

            this.length++;
            this.items.push(o);
            this.map[C] = o;
            this.keys.push(C);
        }

        this.fireEvent("add", this.length-1, o, C);
        return  o;
    },
   
/**
  * MixedCollection has a generic way to fetch keys if you implement getKey.
<pre><code>
// normal way
var mc = new Roo.util.MixedCollection();
mc.add(someEl.dom.id, someEl);
mc.add(otherEl.dom.id, otherEl);
//and so on

// using getKey
var mc = new Roo.util.MixedCollection();
mc.getKey = function(el){
   return el.dom.id;
};
mc.add(someEl);
mc.add(otherEl);

// or via the constructor
var mc = new Roo.util.MixedCollection(false, function(el){
   return el.dom.id;
});
mc.add(someEl);
mc.add(otherEl);
</code></pre>
 * @param o {Object} The item for which to find the key.
 * @return {Object} The key for the passed item.
 */
    getKey : function(o){
         return  o.id; 
    },
   
/**
 * Replaces an item in the collection.
 * @param {String} key The key associated with the item to replace, or the item to replace.
 * @param o {Object} o (optional) If the first parameter passed was a key, the item to associate with that key.
 * @return {Object}  The new item.
 */
    replace : function(D, o){
        if(arguments.length == 1){
            o = arguments[0];
            D = this.getKey(o);
        }
        var  E = this.item(D);
        if(typeof  D == "undefined" || D === null || typeof  E == "undefined"){
             return  this.add(D, o);
        }
        var  F = this.indexOfKey(D);
        this.items[F] = o;
        this.map[D] = o;
        this.fireEvent("replace", D, E, o);
        return  o;
    },
   
/**
 * Adds all elements of an Array or an Object to the collection.
 * @param {Object/Array} objs An Object containing properties which will be added to the collection, or
 * an Array of values, each of which are added to the collection.
 */
    addAll : function(G){
        if(arguments.length > 1 || G  instanceof  Array){
            var  args = arguments.length > 1 ? arguments : G;
            for(var  i = 0, len = args.length; i < len; i++){
                this.add(args[i]);
            }
        }else {
            for(var  D  in  G){
                if(this.allowFunctions || typeof  G[D] != "function"){
                    this.add(D, G[D]);
                }
            }
        }
    },
   
/**
 * Executes the specified function once for every item in the collection, passing each
 * item as the first and only parameter. returning false from the function will stop the iteration.
 * @param {Function} fn The function to execute for each item.
 * @param {Object} scope (optional) The scope in which to execute the function.
 */
    each : function(fn, H){
        var  I = [].concat(this.items); // each safe for removal
        for(var  i = 0, len = I.length; i < len; i++){
            if(fn.call(H || I[i], I[i], i, len) === false){
                break;
            }
        }
    },
   
/**
 * Executes the specified function once for every key in the collection, passing each
 * key, and its associated item as the first two parameters.
 * @param {Function} fn The function to execute for each item.
 * @param {Object} scope (optional) The scope in which to execute the function.
 */
    eachKey : function(fn, J){
        for(var  i = 0, len = this.keys.length; i < len; i++){
            fn.call(J || window, this.keys[i], this.items[i], i, len);
        }
    },
   
/**
 * Returns the first item in the collection which elicits a true return value from the
 * passed selection function.
 * @param {Function} fn The selection function to execute for each item.
 * @param {Object} scope (optional) The scope in which to execute the function.
 * @return {Object} The first item in the collection which returned true from the selection function.
 */
    find : function(fn, K){
        for(var  i = 0, len = this.items.length; i < len; i++){
            if(fn.call(K || window, this.items[i], this.keys[i])){
                return  this.items[i];
            }
        }
        return  null;
    },
   
/**
 * Inserts an item at the specified index in the collection.
 * @param {Number} index The index to insert the item at.
 * @param {String} key The key to associate with the new item, or the item itself.
 * @param {Object} o  (optional) If the second parameter was a key, the new item.
 * @return {Object} The item inserted.
 */
    insert : function(L, M, o){
        if(arguments.length == 2){
            o = arguments[1];
            M = this.getKey(o);
        }
        if(L >= this.length){
            return  this.add(M, o);
        }

        this.length++;
        this.items.splice(L, 0, o);
        if(typeof  M != "undefined" && M != null){
            this.map[M] = o;
        }

        this.keys.splice(L, 0, M);
        this.fireEvent("add", L, o, M);
        return  o;
    },
   
/**
 * Removed an item from the collection.
 * @param {Object} o The item to remove.
 * @return {Object} The item removed.
 */
    remove : function(o){
        return  this.removeAt(this.indexOf(o));
    },
   
/**
 * Remove an item from a specified index in the collection.
 * @param {Number} index The index within the collection of the item to remove.
 */
    removeAt : function(N){
        if(N < this.length && N >= 0){
            this.length--;
            var  o = this.items[N];
            this.items.splice(N, 1);
            var  M = this.keys[N];
            if(typeof  M != "undefined"){
                delete  this.map[M];
            }

            this.keys.splice(N, 1);
            this.fireEvent("remove", o, M);
        }
    },
   
/**
 * Removed an item associated with the passed key fom the collection.
 * @param {String} key The key of the item to remove.
 */
    removeKey : function(O){
        return  this.removeAt(this.indexOfKey(O));
    },
   
/**
 * Returns the number of items in the collection.
 * @return {Number} the number of items in the collection.
 */
    getCount : function(){
        return  this.length; 
    },
   
/**
 * Returns index within the collection of the passed Object.
 * @param {Object} o The item to find the index of.
 * @return {Number} index of the item.
 */
    indexOf : function(o){
        if(!this.items.indexOf){
            for(var  i = 0, len = this.items.length; i < len; i++){
                if(this.items[i] == o) return  i;
            }
            return  -1;
        }else {
            return  this.items.indexOf(o);
        }
    },
   
/**
 * Returns index within the collection of the passed key.
 * @param {String} key The key to find the index of.
 * @return {Number} index of the key.
 */
    indexOfKey : function(P){
        if(!this.keys.indexOf){
            for(var  i = 0, len = this.keys.length; i < len; i++){
                if(this.keys[i] == P) return  i;
            }
            return  -1;
        }else {
            return  this.keys.indexOf(P);
        }
    },
   
/**
 * Returns the item associated with the passed key OR index. Key has priority over index.
 * @param {String/Number} key The key or index of the item.
 * @return {Object} The item associated with the passed key.
 */
    item : function(Q){
        var  R = typeof  this.map[Q] != "undefined" ? this.map[Q] : this.items[Q];
        return  typeof  R != 'function' || this.allowFunctions ? R : null; // for prototype!
    },
    
/**
 * Returns the item at the specified index.
 * @param {Number} index The index of the item.
 * @return {Object}
 */
    itemAt : function(S){
        return  this.items[S];
    },
    
/**
 * Returns the item associated with the passed key.
 * @param {String/Number} key The key of the item.
 * @return {Object} The item associated with the passed key.
 */
    key : function(T){
        return  this.map[T];
    },
   
/**
 * Returns true if the collection contains the passed Object as an item.
 * @param {Object} o  The Object to look for in the collection.
 * @return {Boolean} True if the collection contains the Object as an item.
 */
    contains : function(o){
        return  this.indexOf(o) != -1;
    },
   
/**
 * Returns true if the collection contains the passed Object as a key.
 * @param {String} key The key to look for in the collection.
 * @return {Boolean} True if the collection contains the Object as a key.
 */
    containsKey : function(U){
        return  typeof  this.map[U] != "undefined";
    },
   
/**
 * Removes all items from the collection.
 */
    clear : function(){
        this.length = 0;
        this.items = [];
        this.keys = [];
        this.map = {};
        this.fireEvent("clear");
    },
   
/**
 * Returns the first item in the collection.
 * @return {Object} the first item in the collection..
 */
    first : function(){
        return  this.items[0]; 
    },
   
/**
 * Returns the last item in the collection.
 * @return {Object} the last item in the collection..
 */
    last : function(){
        return  this.items[this.length-1];   
    },
    
    _sort : function(V, W, fn){
        var  X = String(W).toUpperCase() == "DESC" ? -1 : 1;
        fn = fn || function(a, b){
            return  a-b;
        };
        var  c = [], k = this.keys, Y = this.items;
        for(var  i = 0, len = Y.length; i < len; i++){
            c[c.length] = {key: k[i], value: Y[i], index: i};
        }

        c.sort(function(a, b){
            var  v = fn(a[V], b[V]) * X;
            if(v == 0){
                v = (a.index < b.index ? -1 : 1);
            }
            return  v;
        });
        for(var  i = 0, len = c.length; i < len; i++){
            Y[i] = c[i].value;
            k[i] = c[i].key;
        }

        this.fireEvent("sort", this);
    },
    
    /**
     * Sorts this collection with the passed comparison function
     * @param {String} direction (optional) "ASC" or "DESC"
     * @param {Function} fn (optional) comparison function
     */
    sort : function(Z, fn){
        this._sort("value", Z, fn);
    },
    
    /**
     * Sorts this collection by keys
     * @param {String} direction (optional) "ASC" or "DESC"
     * @param {Function} fn (optional) a comparison function (defaults to case insensitive string)
     */
    keySort : function(a, fn){
        this._sort("key", a, fn || function(a, b){
            return  String(a).toUpperCase()-String(b).toUpperCase();
        });
    },
    
    /**
     * Returns a range of items in this collection
     * @param {Number} startIndex (optional) defaults to 0
     * @param {Number} endIndex (optional) default to the last item
     * @return {Array} An array of items
     */
    getRange : function(b, d){
        var  e = this.items;
        if(e.length < 1){
            return  [];
        }

        b = b || 0;
        d = Math.min(typeof  d == "undefined" ? this.length-1 : d, this.length-1);
        var  r = [];
        if(b <= d){
            for(var  i = b; i <= d; i++) {
        	    r[r.length] = e[i];
            }
        }else {
            for(var  i = b; i >= d; i--) {
        	    r[r.length] = e[i];
            }
        }
        return  r;
    },
        
    /**
     * Filter the <i>objects</i> in this collection by a specific property. 
     * Returns a new collection that has been filtered.
     * @param {String} property A property on your objects
     * @param {String/RegExp} value Either string that the property values 
     * should start with or a RegExp to test against the property
     * @return {MixedCollection} The new filtered collection
     */
    filter : function(f, g){
        if(!g.exec){ // not a regex
            g = String(g);
            if(g.length == 0){
                return  this.clone();
            }

            g = new  RegExp("^" + Roo.escapeRe(g), "i");
        }
        return  this.filterBy(function(o){
            return  o && g.test(o[f]);
        });
	},
    
    /**
     * Filter by a function. * Returns a new collection that has been filtered.
     * The passed function will be called with each 
     * object in the collection. If the function returns true, the value is included 
     * otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive the args o (the object), k (the key)
     * @param {Object} scope (optional) The scope of the function (defaults to this) 
     * @return {MixedCollection} The new filtered collection
     */
    filterBy : function(fn, h){
        var  r = new  Roo.util.MixedCollection();
        r.getKey = this.getKey;
        var  k = this.keys, it = this.items;
        for(var  i = 0, len = it.length; i < len; i++){
            if(fn.call(h||this, it[i], k[i])){
				r.add(k[i], it[i]);
			}
        }
        return  r;
    },
    
    /**
     * Creates a duplicate of this collection
     * @return {MixedCollection}
     */
    clone : function(){
        var  r = new  Roo.util.MixedCollection();
        var  k = this.keys, it = this.items;
        for(var  i = 0, len = it.length; i < len; i++){
            r.add(k[i], it[i]);
        }

        r.getKey = this.getKey;
        return  r;
    }
});
/**
 * Returns the item associated with the passed key or index.
 * @method
 * @param {String/Number} key The key or index of the item.
 * @return {Object} The item associated with the passed key.
 */
Roo.util.MixedCollection.prototype.get = Roo.util.MixedCollection.prototype.item;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.util.JSON
 * Modified version of Douglas Crockford"s json.js that doesn"t
 * mess with the Object prototype 
 * http://www.json.org/js.html
 * @singleton
 */
Roo.util.JSON = new  (function(){
    var  A = {}.hasOwnProperty ? true : false;
    
    // crashes Safari in some instances
    //var validRE = /^("(\\.|[^"\\\n\r])*?"|[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t])+?$/;
    
    var  B = function(n) {
        return  n < 10 ? "0" + n : n;
    };
    
    var  m = {
        "\b": '\\b',
        "\t": '\\t',
        "\n": '\\n',
        "\f": '\\f',
        "\r": '\\r',
        '"' : '\\"',
        "\\": '\\\\'
    };

    var  C = function(s){
        if (/["\\\x00-\x1f]/.test(s)) {
            return  '"' + s.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                var  c = m[b];
                if(c){
                    return  c;
                }

                c = b.charCodeAt();
                return  "\\u00" +
                    Math.floor(c / 16).toString(16) +
                    (c % 16).toString(16);
            }) + '"';
        }
        return  '"' + s + '"';
    };
    
    var  D = function(o){
        var  a = ["["], b, i, l = o.length, v;
            for (i = 0; i < l; i += 1) {
                v = o[i];
                switch (typeof  v) {
                    case  "undefined":
                    case  "function":
                    case  "unknown":
                        break;
                    default:
                        if (b) {
                            a.push(',');
                        }

                        a.push(v === null ? "null" : Roo.util.JSON.encode(v));
                        b = true;
                }
            }

            a.push("]");
            return  a.join("");
    };
    
    var  E = function(o){
        return  '"' + o.getFullYear() + "-" +
                B(o.getMonth() + 1) + "-" +
                B(o.getDate()) + "T" +
                B(o.getHours()) + ":" +
                B(o.getMinutes()) + ":" +
                B(o.getSeconds()) + '"';
    };
    
    /**
     * Encodes an Object, Array or other value
     * @param {Mixed} o The variable to encode
     * @return {String} The JSON string
     */
    this.encode = function(o){
        if(typeof  o == "undefined" || o === null){
            return  "null";
        }else  if(o  instanceof  Array){
            return  D(o);
        }else  if(o  instanceof  Date){
            return  E(o);
        }else  if(typeof  o == "string"){
            return  C(o);
        }else  if(typeof  o == "number"){
            return  isFinite(o) ? String(o) : "null";
        }else  if(typeof  o == "boolean"){
            return  String(o);
        }else  {
            var  a = ["{"], b, i, v;
            for (i  in  o) {
                if(!A || o.hasOwnProperty(i)) {
                    v = o[i];
                    switch (typeof  v) {
                    case  "undefined":
                    case  "function":
                    case  "unknown":
                        break;
                    default:
                        if(b){
                            a.push(',');
                        }

                        a.push(this.encode(i), ":",
                                v === null ? "null" : this.encode(v));
                        b = true;
                    }
                }
            }

            a.push("}");
            return  a.join("");
        }
    };
    
    /**
     * Decodes (parses) a JSON string to an object. If the JSON is invalid, this function throws a SyntaxError.
     * @param {String} json The JSON string
     * @return {Object} The resulting object
     */
    this.decode = function(F){
        /**
         * eval:var:json
         */
        return  eval("(" + F + ')');
    };
})();
/** 
 * Shorthand for {@link Roo.util.JSON#encode}
 * @member Roo encode 
 * @method */
Roo.encode = Roo.util.JSON.encode;
/** 
 * Shorthand for {@link Roo.util.JSON#decode}
 * @member Roo decode 
 * @method */
Roo.decode = Roo.util.JSON.decode;

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.util.Format
 * Reusable data formatting functions
 * @singleton
 */
Roo.util.Format = function(){
    var  A = /^\s+|\s+$/g;
    return  {
        /**
         * Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length
         * @param {String} value The string to truncate
         * @param {Number} length The maximum length to allow before truncating
         * @return {String} The converted text
         */
        ellipsis : function(S, T){
            if(S && S.length > T){
                return  S.substr(0, T-3)+"...";
            }
            return  S;
        },

        /**
         * Checks a reference and converts it to empty string if it is undefined
         * @param {Mixed} value Reference to check
         * @return {Mixed} Empty string if converted, otherwise the original value
         */
        undef : function(U){
            return  typeof  U != "undefined" ? U : "";
        },

        /**
         * Convert certain characters (&, <, >, and ') to their HTML character equivalents for literal display in web pages.
         * @param {String} value The string to encode
         * @return {String} The encoded text
         */
        htmlEncode : function(V){
            return  !V ? V : String(V).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
        },

        /**
         * Convert certain characters (&, <, >, and ') from their HTML character equivalents.
         * @param {String} value The string to decode
         * @return {String} The decoded text
         */
        htmlDecode : function(W){
            return  !W ? W : String(W).replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"');
        },

        /**
         * Trims any whitespace from either side of a string
         * @param {String} value The text to trim
         * @return {String} The trimmed text
         */
        trim : function(X){
            return  String(X).replace(A, "");
        },

        /**
         * Returns a substring from within an original string
         * @param {String} value The original text
         * @param {Number} start The start index of the substring
         * @param {Number} length The length of the substring
         * @return {String} The substring
         */
        substr : function(Y, Z, a){
            return  String(Y).substr(Z, a);
        },

        /**
         * Converts a string to all lower case letters
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        lowercase : function(b){
            return  String(b).toLowerCase();
        },

        /**
         * Converts a string to all upper case letters
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        uppercase : function(c){
            return  String(c).toUpperCase();
        },

        /**
         * Converts the first character only of a string to upper case
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        capitalize : function(d){
            return  !d ? d : d.charAt(0).toUpperCase() + d.substr(1).toLowerCase();
        },

        // private
        call : function(e, fn){
            if(arguments.length > 2){
                var  args = Array.prototype.slice.call(arguments, 2);
                args.unshift(e);
                 
                return  /** eval:var:value */  eval(fn).apply(window, args);
            }else {
                /** eval:var:value */
                return  /** eval:var:value */ eval(fn).call(window, e);
            }
        },

        /**
         * Format a number as US currency
         * @param {Number/String} value The numeric value to format
         * @return {String} The formatted currency string
         */
        usMoney : function(v){
            v = (Math.round((v-0)*100))/100;
            v = (v == Math.floor(v)) ? v + ".00" : ((v*10 == Math.floor(v*10)) ? v + "0" : v);
            v = String(v);
            var  ps = v.split('.');
            var  f = ps[0];
            var  g = ps[1] ? '.'+ ps[1] : '.00';
            var  r = /(\d+)(\d{3})/;
            while (r.test(f)) {
                f = f.replace(r, '$1' + ',' + '$2');
            }
            return  "$" + f + g ;
        },

        /**
         * Parse a value into a formatted date using the specified format pattern.
         * @param {Mixed} value The value to format
         * @param {String} format (optional) Any valid date format string (defaults to 'm/d/Y')
         * @return {String} The formatted date string
         */
        date : function(v, h){
            if(!v){
                return  "";
            }
            if(!(v  instanceof  Date)){
                v = new  Date(Date.parse(v));
            }
            return  v.dateFormat(h || "m/d/Y");
        },

        /**
         * Returns a date rendering function that can be reused to apply a date format multiple times efficiently
         * @param {String} format Any valid date format string
         * @return {Function} The date formatting function
         */
        dateRenderer : function(i){
            return  function(v){
                return  Roo.util.Format.date(v, i);  
            };
        },

        // private
        stripTagsRE : /<\/?[^>]+>/gi,
        
        /**
         * Strips all HTML tags
         * @param {Mixed} value The text from which to strip tags
         * @return {String} The stripped text
         */
        stripTags : function(v){
            return  !v ? v : String(v).replace(this.stripTagsRE, "");
        }
    };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


 

/**
 * @class Roo.MasterTemplate
 * @extends Roo.Template
 * Provides a template that can have child templates. The syntax is:
<pre><code>
var t = new Roo.MasterTemplate(
	'&lt;select name="{name}"&gt;',
		'&lt;tpl name="options"&gt;&lt;option value="{value:trim}"&gt;{text:ellipsis(10)}&lt;/option&gt;&lt;/tpl&gt;',
	'&lt;/select&gt;'
);
t.add('options', {value: 'foo', text: 'bar'});
// or you can add multiple child elements in one shot
t.addAll('options', [
    {value: 'foo', text: 'bar'},
    {value: 'foo2', text: 'bar2'},
    {value: 'foo3', text: 'bar3'}
]);
// then append, applying the master template values
t.append('my-form', {name: 'my-select'});
</code></pre>
* A name attribute for the child template is not required if you have only one child
* template or you want to refer to them by index.
 */
Roo.MasterTemplate = function(){
    Roo.MasterTemplate.superclass.constructor.apply(this, arguments);
    this.originalHtml = this.html;
    var  st = {};
    var  m, re = this.subTemplateRe;
    re.lastIndex = 0;
    var  A = 0;
    while(m = re.exec(this.html)){
        var  name = m[1], content = m[2];
        st[A] = {
            name: name,
            index: A,
            buffer: [],
            tpl : new  Roo.Template(content)
        };
        if(name){
            st[name] = st[A];
        }

        st[A].tpl.compile();
        st[A].tpl.call = this.call.createDelegate(this);
        A++;
    }

    this.subCount = A;
    this.subs = st;
};
Roo.extend(Roo.MasterTemplate, Roo.Template, {
    /**
    * The regular expression used to match sub templates
    * @type RegExp
    * @property
    */
    subTemplateRe : /<tpl(?:\sname="([\w-]+)")?>((?:.|\n)*?)<\/tpl>/gi,

    /**
     * Applies the passed values to a child template.
     * @param {String/Number} name (optional) The name or index of the child template
     * @param {Array/Object} values The values to be applied to the template
     * @return {MasterTemplate} this
     */
     add : function(B, C){
        if(arguments.length == 1){
            C = arguments[0];
            B = 0;
        }
        var  s = this.subs[B];
        s.buffer[s.buffer.length] = s.tpl.apply(C);
        return  this;
    },

    /**
     * Applies all the passed values to a child template.
     * @param {String/Number} name (optional) The name or index of the child template
     * @param {Array} values The values to be applied to the template, this should be an array of objects.
     * @param {Boolean} reset (optional) True to reset the template first
     * @return {MasterTemplate} this
     */
    fill : function(D, E, F){
        var  a = arguments;
        if(a.length == 1 || (a.length == 2 && typeof  a[1] == "boolean")){
            E = a[0];
            D = 0;
            F = a[1];
        }
        if(F){
            this.reset();
        }
        for(var  i = 0, len = E.length; i < len; i++){
            this.add(D, E[i]);
        }
        return  this;
    },

    /**
     * Resets the template for reuse
     * @return {MasterTemplate} this
     */
     reset : function(){
        var  s = this.subs;
        for(var  i = 0; i < this.subCount; i++){
            s[i].buffer = [];
        }
        return  this;
    },

    applyTemplate : function(G){
        var  s = this.subs;
        var  H = -1;
        this.html = this.originalHtml.replace(this.subTemplateRe, function(m, I){
            return  s[++H].buffer.join("");
        });
        return  Roo.MasterTemplate.superclass.applyTemplate.call(this, G);
    },

    apply : function(){
        return  this.applyTemplate.apply(this, arguments);
    },

    compile : function(){return  this;}
});

/**
 * Alias for fill().
 * @method
 */
Roo.MasterTemplate.prototype.addAll = Roo.MasterTemplate.prototype.fill;
 /**
 * Creates a template from the passed element's value (display:none textarea, preferred) or innerHTML. e.g.
 * var tpl = Roo.MasterTemplate.from('element-id');
 * @param {String/HTMLElement} el
 * @param {Object} config
 * @static
 */
Roo.MasterTemplate.from = function(el, I){
    el = Roo.getDom(el);
    return  new  Roo.MasterTemplate(el.value || el.innerHTML, I || '');
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.util.CSS
 * Utility class for manipulating CSS rules
 * @singleton
 */
Roo.util.CSS = function(){
	var  A = null;
   	var  B = document;

    var  C = /(-[a-z])/gi;
    var  D = function(m, a){ return  a.charAt(1).toUpperCase(); };

   return  {
   /**
    * Very simple dynamic creation of stylesheets from a text blob of rules.  The text will wrapped in a style
    * tag and appended to the HEAD of the document.
    * @param {String} cssText The text containing the css rules
    * @param {String} id An id to add to the stylesheet for later removal
    * @return {StyleSheet}
    */
   createStyleSheet : function(P, id){
       var  ss;
       var  Q = B.getElementsByTagName("head")[0];
       var  R = B.createElement("style");
       R.setAttribute("type", "text/css");
       if(id){
           R.setAttribute("id", id);
       }
       if(Roo.isIE){
           Q.appendChild(R);
           ss = R.styleSheet;
           ss.cssText = P;
       }else {
           try{
                R.appendChild(B.createTextNode(P));
           }catch(e){
               R.cssText = P; 
           }

           Q.appendChild(R);
           ss = R.styleSheet ? R.styleSheet : (R.sheet || B.styleSheets[B.styleSheets.length-1]);
       }

       this.cacheStyleSheet(ss);
       return  ss;
   },

   /**
    * Removes a style or link tag by id
    * @param {String} id The id of the tag
    */
   removeStyleSheet : function(id){
       var  S = B.getElementById(id);
       if(S){
           S.parentNode.removeChild(S);
       }
   },

   /**
    * Dynamically swaps an existing stylesheet reference for a new one
    * @param {String} id The id of an existing link tag to remove
    * @param {String} url The href of the new stylesheet to include
    */
   swapStyleSheet : function(id, T){
       this.removeStyleSheet(id);
       var  ss = B.createElement("link");
       ss.setAttribute("rel", "stylesheet");
       ss.setAttribute("type", "text/css");
       ss.setAttribute("id", id);
       ss.setAttribute("href", T);
       B.getElementsByTagName("head")[0].appendChild(ss);
   },
   
   /**
    * Refresh the rule cache if you have dynamically added stylesheets
    * @return {Object} An object (hash) of rules indexed by selector
    */
   refreshCache : function(){
       return  this.getRules(true);
   },

   // private
   cacheStyleSheet : function(ss){
       if(!R){
           R = {};
       }
       try{// try catch for cross domain access issue
           var  ssRules = ss.cssRules || ss.rules;
           for(var  j = ssRules.length-1; j >= 0; --j){
               R[ssRules[j].selectorText] = ssRules[j];
           }
       }catch(e){}
   },
   
   /**
    * Gets all css rules for the document
    * @param {Boolean} refreshCache true to refresh the internal cache
    * @return {Object} An object (hash) of rules indexed by selector
    */
   getRules : function(U){
   		if(R == null || U){
   			R = {};
   			var  ds = B.styleSheets;
   			for(var  i =0, len = ds.length; i < len; i++){
   			    try{
    		        this.cacheStyleSheet(ds[i]);
    		    }catch(e){} 
	        }
   		}
   		return  R;
   	},
   	
   	/**
    * Gets an an individual CSS rule by selector(s)
    * @param {String/Array} selector The CSS selector or an array of selectors to try. The first selector that is found is returned.
    * @param {Boolean} refreshCache true to refresh the internal cache if you have recently updated any rules or added styles dynamically
    * @return {CSSRule} The CSS rule or null if one is not found
    */
   getRule : function(V, W){
   		var  rs = this.getRules(W);
   		if(!(V  instanceof  Array)){
   		    return  rs[V];
   		}
   		for(var  i = 0; i < V.length; i++){
			if(rs[V[i]]){
				return  rs[V[i]];
			}
		}
		return  null;
   	},
   	
   	
   	/**
    * Updates a rule property
    * @param {String/Array} selector If it's an array it tries each selector until it finds one. Stops immediately once one is found.
    * @param {String} property The css property
    * @param {String} value The new value for the property
    * @return {Boolean} true If a rule was found and updated
    */
   updateRule : function(X, Y, Z){
   		if(!(X  instanceof  Array)){
   			var  rule = this.getRule(X);
   			if(rule){
   				rule.style[Y.replace(C, D)] = Z;
   				return  true;
   			}
   		}else {
   			for(var  i = 0; i < X.length; i++){
   				if(this.updateRule(X[i], Y, Z)){
   					return  true;
   				}
   			}
   		}
   		return  false;
   	}
   };	
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 

/**
 * @class Roo.util.ClickRepeater
 * @extends Roo.util.Observable
 * 
 * A wrapper class which can be applied to any element. Fires a "click" event while the
 * mouse is pressed. The interval between firings may be specified in the config but
 * defaults to 10 milliseconds.
 * 
 * Optionally, a CSS class may be applied to the element during the time it is pressed.
 * 
 * @cfg {String/HTMLElement/Element} el The element to act as a button.
 * @cfg {Number} delay The initial delay before the repeating event begins firing.
 * Similar to an autorepeat key delay.
 * @cfg {Number} interval The interval between firings of the "click" event. Default 10 ms.
 * @cfg {String} pressClass A CSS class name to be applied to the element while pressed.
 * @cfg {Boolean} accelerate True if autorepeating should start slowly and accelerate.
 *           "interval" and "delay" are ignored. "immediate" is honored.
 * @cfg {Boolean} preventDefault True to prevent the default click event
 * @cfg {Boolean} stopDefault True to stop the default click event
 * 
 * @history
 *     2007-02-02 jvs Original code contributed by Nige "Animal" White
 *     2007-02-02 jvs Renamed to ClickRepeater
 *   2007-02-03 jvs Modifications for FF Mac and Safari 
 *
 *  @constructor
 * @param {String/HTMLElement/Element} el The element to listen on
 * @param {Object} config
 **/
Roo.util.ClickRepeater = function(el, A)
{
    this.el = Roo.get(el);
    this.el.unselectable();

    Roo.apply(this, A);

    this.addEvents({
    /**
     * @event mousedown
     * Fires when the mouse button is depressed.
     * @param {Roo.util.ClickRepeater} this
     */
        "mousedown" : true,
    /**
     * @event click
     * Fires on a specified interval during the time the element is pressed.
     * @param {Roo.util.ClickRepeater} this
     */
        "click" : true,
    /**
     * @event mouseup
     * Fires when the mouse key is released.
     * @param {Roo.util.ClickRepeater} this
     */
        "mouseup" : true
    });

    this.el.on("mousedown", this.handleMouseDown, this);
    if(this.preventDefault || this.stopDefault){
        this.el.on("click", function(e){
            if(this.preventDefault){
                e.preventDefault();
            }
            if(this.stopDefault){
                e.stopEvent();
            }
        }, this);
    }

    // allow inline handler
    if(this.handler){
        this.on("click", this.handler,  this.scope || this);
    }


    Roo.util.ClickRepeater.superclass.constructor.call(this);
};

Roo.extend(Roo.util.ClickRepeater, Roo.util.Observable, {
    interval : 20,
    delay: 250,
    preventDefault : true,
    stopDefault : false,
    timer : 0,

    // private
    handleMouseDown : function(){
        clearTimeout(this.timer);
        this.el.blur();
        if(this.pressClass){
            this.el.addClass(this.pressClass);
        }

        this.mousedownTime = new  Date();

        Roo.get(document).on("mouseup", this.handleMouseUp, this);
        this.el.on("mouseout", this.handleMouseOut, this);

        this.fireEvent("mousedown", this);
        this.fireEvent("click", this);
        
        this.timer = this.click.defer(this.delay || this.interval, this);
    },

    // private
    click : function(){
        this.fireEvent("click", this);
        this.timer = this.click.defer(this.getInterval(), this);
    },

    // private
    getInterval: function(){
        if(!this.accelerate){
            return  this.interval;
        }
        var  B = this.mousedownTime.getElapsed();
        if(B < 500){
            return  400;
        }else  if(B < 1700){
            return  320;
        }else  if(B < 2600){
            return  250;
        }else  if(B < 3500){
            return  180;
        }else  if(B < 4400){
            return  140;
        }else  if(B < 5300){
            return  80;
        }else  if(B < 6200){
            return  50;
        }else {
            return  10;
        }
    },

    // private
    handleMouseOut : function(){
        clearTimeout(this.timer);
        if(this.pressClass){
            this.el.removeClass(this.pressClass);
        }

        this.el.on("mouseover", this.handleMouseReturn, this);
    },

    // private
    handleMouseReturn : function(){
        this.el.un("mouseover", this.handleMouseReturn);
        if(this.pressClass){
            this.el.addClass(this.pressClass);
        }

        this.click();
    },

    // private
    handleMouseUp : function(){
        clearTimeout(this.timer);
        this.el.un("mouseover", this.handleMouseReturn);
        this.el.un("mouseout", this.handleMouseOut);
        Roo.get(document).un("mouseup", this.handleMouseUp);
        this.el.removeClass(this.pressClass);
        this.fireEvent("mouseup", this);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.KeyNav
 * <p>Provides a convenient wrapper for normalized keyboard navigation.  KeyNav allows you to bind
 * navigation keys to function calls that will get called when the keys are pressed, providing an easy
 * way to implement custom navigation schemes for any UI component.</p>
 * <p>The following are all of the possible keys that can be implemented: enter, left, right, up, down, tab, esc,
 * pageUp, pageDown, del, home, end.  Usage:</p>
 <pre><code>
var nav = new Roo.KeyNav("my-element", {
    "left" : function(e){
        this.moveLeft(e.ctrlKey);
    },
    "right" : function(e){
        this.moveRight(e.ctrlKey);
    },
    "enter" : function(e){
        this.save();
    },
    scope : this
});
</code></pre>
 * @constructor
 * @param {String/HTMLElement/Roo.Element} el The element to bind to
 * @param {Object} config The config
 */
Roo.KeyNav = function(el, A){
    this.el = Roo.get(el);
    Roo.apply(this, A);
    if(!this.disabled){
        this.disabled = true;
        this.enable();
    }
};

Roo.KeyNav.prototype = {
    /**
     * @cfg {Boolean} disabled
     * True to disable this KeyNav instance (defaults to false)
     */
    disabled : false,
    /**
     * @cfg {String} defaultEventAction
     * The method to call on the {@link Roo.EventObject} after this KeyNav intercepts a key.  Valid values are
     * {@link Roo.EventObject#stopEvent}, {@link Roo.EventObject#preventDefault} and
     * {@link Roo.EventObject#stopPropagation} (defaults to 'stopEvent')
     */
    defaultEventAction: "stopEvent",
    /**
     * @cfg {Boolean} forceKeyDown
     * Handle the keydown event instead of keypress (defaults to false).  KeyNav automatically does this for IE since
     * IE does not propagate special keys on keypress, but setting this to true will force other browsers to also
     * handle keydown instead of keypress.
     */
    forceKeyDown : false,

    // private
    prepareEvent : function(e){
        var  k = e.getKey();
        var  h = this.keyToHandler[k];
        //if(h && this[h]){
        //    e.stopPropagation();
        //}
        if(Roo.isSafari && h && k >= 37 && k <= 40){
            e.stopEvent();
        }
    },

    // private
    relay : function(e){
        var  k = e.getKey();
        var  h = this.keyToHandler[k];
        if(h && this[h]){
            if(this.doRelay(e, this[h], h) !== true){
                e[this.defaultEventAction]();
            }
        }
    },

    // private
    doRelay : function(e, h, B){
        return  h.call(this.scope || this, e);
    },

    // possible handlers
    enter : false,
    left : false,
    right : false,
    up : false,
    down : false,
    tab : false,
    esc : false,
    pageUp : false,
    pageDown : false,
    del : false,
    home : false,
    end : false,

    // quick lookup hash
    keyToHandler : {
        37 : "left",
        39 : "right",
        38 : "up",
        40 : "down",
        33 : "pageUp",
        34 : "pageDown",
        46 : "del",
        36 : "home",
        35 : "end",
        13 : "enter",
        27 : "esc",
        9  : "tab"
    },

	/**
	 * Enable this KeyNav
	 */
	enable: function(){
		if(this.disabled){
            // ie won't do special keys on keypress, no one else will repeat keys with keydown
            // the EventObject will normalize Safari automatically
            if(this.forceKeyDown || Roo.isIE || Roo.isAir){
                this.el.on("keydown", this.relay,  this);
            }else {
                this.el.on("keydown", this.prepareEvent,  this);
                this.el.on("keypress", this.relay,  this);
            }

		    this.disabled = false;
		}
	},

	/**
	 * Disable this KeyNav
	 */
	disable: function(){
		if(!this.disabled){
		    if(this.forceKeyDown || Roo.isIE || Roo.isAir){
                this.el.un("keydown", this.relay);
            }else {
                this.el.un("keydown", this.prepareEvent);
                this.el.un("keypress", this.relay);
            }

		    this.disabled = true;
		}
	}
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.KeyMap
 * Handles mapping keys to actions for an element. One key map can be used for multiple actions.
 * The constructor accepts the same config object as defined by {@link #addBinding}.
 * If you bind a callback function to a KeyMap, anytime the KeyMap handles an expected key
 * combination it will call the function with this signature (if the match is a multi-key
 * combination the callback will still be called only once): (String key, Roo.EventObject e)
 * A KeyMap can also handle a string representation of keys.<br />
 * Usage:
 <pre><code>
// map one key by key code
var map = new Roo.KeyMap("my-element", {
    key: 13, // or Roo.EventObject.ENTER
    fn: myHandler,
    scope: myObject
});

// map multiple keys to one action by string
var map = new Roo.KeyMap("my-element", {
    key: "a\r\n\t",
    fn: myHandler,
    scope: myObject
});

// map multiple keys to multiple actions by strings and array of codes
var map = new Roo.KeyMap("my-element", [
    {
        key: [10,13],
        fn: function(){ alert("Return was pressed"); }
    }, {
        key: "abc",
        fn: function(){ alert('a, b or c was pressed'); }
    }, {
        key: "\t",
        ctrl:true,
        shift:true,
        fn: function(){ alert('Control + shift + tab was pressed.'); }
    }
]);
</code></pre>
 * <b>Note: A KeyMap starts enabled</b>
 * @constructor
 * @param {String/HTMLElement/Roo.Element} el The element to bind to
 * @param {Object} config The config (see {@link #addBinding})
 * @param {String} eventName (optional) The event to bind to (defaults to "keydown")
 */
Roo.KeyMap = function(el, A, B){
    this.el  = Roo.get(el);
    this.eventName = B || "keydown";
    this.bindings = [];
    if(A){
        this.addBinding(A);
    }

    this.enable();
};

Roo.KeyMap.prototype = {
    /**
     * True to stop the event from bubbling and prevent the default browser action if the
     * key was handled by the KeyMap (defaults to false)
     * @type Boolean
     */
    stopEvent : false,

    /**
     * Add a new binding to this KeyMap. The following config object properties are supported:
     * <pre>
Property    Type             Description
----------  ---------------  ----------------------------------------------------------------------
key         String/Array     A single keycode or an array of keycodes to handle
shift       Boolean          True to handle key only when shift is pressed (defaults to false)
ctrl        Boolean          True to handle key only when ctrl is pressed (defaults to false)
alt         Boolean          True to handle key only when alt is pressed (defaults to false)
fn          Function         The function to call when KeyMap finds the expected key combination
scope       Object           The scope of the callback function
</pre>
     *
     * Usage:
     * <pre><code>
// Create a KeyMap
var map = new Roo.KeyMap(document, {
    key: Roo.EventObject.ENTER,
    fn: handleKey,
    scope: this
});

//Add a new binding to the existing KeyMap later
map.addBinding({
    key: 'abc',
    shift: true,
    fn: handleKey,
    scope: this
});
</code></pre>
     * @param {Object/Array} config A single KeyMap config or an array of configs
     */
	addBinding : function(C){
        if(C  instanceof  Array){
            for(var  i = 0, len = C.length; i < len; i++){
                this.addBinding(C[i]);
            }
            return;
        }
        var  D = C.key,
            E = C.shift, 
            F = C.ctrl, 
            G = C.alt,
            fn = C.fn,
            H = C.scope;
        if(typeof  D == "string"){
            var  ks = [];
            var  keyString = D.toUpperCase();
            for(var  j = 0, len = keyString.length; j < len; j++){
                ks.push(keyString.charCodeAt(j));
            }

            D = ks;
        }
        var  I = D  instanceof  Array;
        var  J = function(e){
            if((!E || e.shiftKey) && (!F || e.ctrlKey) &&  (!G || e.altKey)){
                var  k = e.getKey();
                if(I){
                    for(var  i = 0, len = D.length; i < len; i++){
                        if(D[i] == k){
                          if(this.stopEvent){
                              e.stopEvent();
                          }

                          fn.call(H || window, k, e);
                          return;
                        }
                    }
                }else {
                    if(k == D){
                        if(this.stopEvent){
                           e.stopEvent();
                        }

                        fn.call(H || window, k, e);
                    }
                }
            }
        };
        this.bindings.push(J);  
	},

    /**
     * Shorthand for adding a single key listener
     * @param {Number/Array/Object} key Either the numeric key code, array of key codes or an object with the
     * following options:
     * {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
     * @param {Function} fn The function to call
     * @param {Object} scope (optional) The scope of the function
     */
    on : function(K, fn, L){
        var  M, N, O, P;
        if(typeof  K == "object" && !(K  instanceof  Array)){
            M = K.key;
            N = K.shift;
            O = K.ctrl;
            P = K.alt;
        }else {
            M = K;
        }

        this.addBinding({
            key: M,
            shift: N,
            ctrl: O,
            alt: P,
            fn: fn,
            scope: L
        })
    },

    // private
    handleKeyDown : function(e){
	    if(this.enabled){ //just in case
    	    var  b = this.bindings;
    	    for(var  i = 0, len = b.length; i < len; i++){
    	        b[i].call(this, e);
    	    }
	    }
	},
	
	/**
	 * Returns true if this KeyMap is enabled
	 * @return {Boolean} 
	 */
	isEnabled : function(){
	    return  this.enabled;  
	},
	
	/**
	 * Enables this KeyMap
	 */
	enable: function(){
		if(!this.enabled){
		    this.el.on(this.eventName, this.handleKeyDown, this);
		    this.enabled = true;
		}
	},

	/**
	 * Disable this KeyMap
	 */
	disable: function(){
		if(this.enabled){
		    this.el.removeListener(this.eventName, this.handleKeyDown, this);
		    this.enabled = false;
		}
	}
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
/**
 * @class Roo.util.TextMetrics
 * Provides precise pixel measurements for blocks of text so that you can determine exactly how high and
 * wide, in pixels, a given block of text will be.
 * @singleton
 */
Roo.util.TextMetrics = function(){
    var  A;
    return  {
        /**
         * Measures the size of the specified text
         * @param {String/HTMLElement} el The element, dom node or id from which to copy existing CSS styles
         * that can affect the size of the rendered text
         * @param {String} text The text to measure
         * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
         * in order to accurately measure the text height
         * @return {Object} An object containing the text's size {width: (width), height: (height)}
         */
        measure : function(el, E, F){
            if(!A){
                A = Roo.util.TextMetrics.Instance(el, F);
            }

            A.bind(el);
            A.setFixedWidth(F || 'auto');
            return  A.getSize(E);
        },

        /**
         * Return a unique TextMetrics instance that can be bound directly to an element and reused.  This reduces
         * the overhead of multiple calls to initialize the style properties on each measurement.
         * @param {String/HTMLElement} el The element, dom node or id that the instance will be bound to
         * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
         * in order to accurately measure the text height
         * @return {Roo.util.TextMetrics.Instance} instance The new instance
         */
        createInstance : function(el, G){
            return  Roo.util.TextMetrics.Instance(el, G);
        }
    };
}();

Roo.util.TextMetrics.Instance = function(B, C){
    var  ml = new  Roo.Element(document.createElement('div'));
    document.body.appendChild(ml.dom);
    ml.position('absolute');
    ml.setLeftTop(-1000, -1000);
    ml.hide();

    if(C){
        ml.setWidth(C);
    }

    var  D = {
        /**
         * Returns the size of the specified text based on the internal element's style and width properties
         * @param {String} text The text to measure
         * @return {Object} An object containing the text's size {width: (width), height: (height)}
         */
        getSize : function(E){
            ml.update(E);
            var  s = ml.getSize();
            ml.update('');
            return  s;
        },

        /**
         * Binds this TextMetrics instance to an element from which to copy existing CSS styles
         * that can affect the size of the rendered text
         * @param {String/HTMLElement} el The element, dom node or id
         */
        bind : function(el){
            ml.setStyle(
                Roo.fly(el).getStyles('font-size','font-style', 'font-weight', 'font-family','line-height')
            );
        },

        /**
         * Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
         * to set a fixed width in order to accurately measure the text height.
         * @param {Number} width The width to set on the element
         */
        setFixedWidth : function(F){
            ml.setWidth(F);
        },

        /**
         * Returns the measured width of the specified text
         * @param {String} text The text to measure
         * @return {Number} width The width in pixels
         */
        getWidth : function(G){
            ml.dom.style.width = 'auto';
            return  this.getSize(G).width;
        },

        /**
         * Returns the measured height of the specified text.  For multiline text, be sure to call
         * {@link #setFixedWidth} if necessary.
         * @param {String} text The text to measure
         * @return {Number} height The height in pixels
         */
        getHeight : function(H){
            return  this.getSize(H).height;
        }
    };

    D.bind(B);

    return  D;
};

// backwards compat
Roo.Element.measureText = Roo.util.TextMetrics.measure;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.state.Provider
 * Abstract base class for state provider implementations. This class provides methods
 * for encoding and decoding <b>typed</b> variables including dates and defines the 
 * Provider interface.
 */
Roo.state.Provider = function(){
    /**
     * @event statechange
     * Fires when a state change occurs.
     * @param {Provider} this This state provider
     * @param {String} key The state key which was changed
     * @param {String} value The encoded value for the state
     */
    this.addEvents({
        "statechange": true
    });
    this.state = {};
    Roo.state.Provider.superclass.constructor.call(this);
};
Roo.extend(Roo.state.Provider, Roo.util.Observable, {
    /**
     * Returns the current value for a key
     * @param {String} name The key name
     * @param {Mixed} defaultValue A default value to return if the key's value is not found
     * @return {Mixed} The state data
     */
    get : function(A, B){
        return  typeof  this.state[A] == "undefined" ?
            B : this.state[A];
    },
    
    /**
     * Clears a value from the state
     * @param {String} name The key name
     */
    clear : function(C){
        delete  this.state[C];
        this.fireEvent("statechange", this, C, null);
    },
    
    /**
     * Sets the value for a key
     * @param {String} name The key name
     * @param {Mixed} value The value to set
     */
    set : function(D, E){
        this.state[D] = E;
        this.fireEvent("statechange", this, D, E);
    },
    
    /**
     * Decodes a string previously encoded with {@link #encodeValue}.
     * @param {String} value The value to decode
     * @return {Mixed} The decoded value
     */
    decodeValue : function(F){
        var  re = /^(a|n|d|b|s|o)\:(.*)$/;
        var  G = re.exec(unescape(F));
        if(!G || !G[1]) return; // non state cookie
        var  H = G[1];
        var  v = G[2];
        switch(H){
            case  "n":
                return  parseFloat(v);
            case  "d":
                return  new  Date(Date.parse(v));
            case  "b":
                return  (v == "1");
            case  "a":
                var  all = [];
                var  values = v.split("^");
                for(var  i = 0, len = values.length; i < len; i++){
                    all.push(this.decodeValue(values[i]));
                }
                return  all;
           case  "o":
                var  all = {};
                var  values = v.split("^");
                for(var  i = 0, len = values.length; i < len; i++){
                    var  kv = values[i].split("=");
                    all[kv[0]] = this.decodeValue(kv[1]);
                }
                return  all;
           default:
                return  v;
        }
    },
    
    /**
     * Encodes a value including type information.  Decode with {@link #decodeValue}.
     * @param {Mixed} value The value to encode
     * @return {String} The encoded value
     */
    encodeValue : function(v){
        var  I;
        if(typeof  v == "number"){
            I = "n:" + v;
        }else  if(typeof  v == "boolean"){
            I = "b:" + (v ? "1" : "0");
        }else  if(v  instanceof  Date){
            I = "d:" + v.toGMTString();
        }else  if(v  instanceof  Array){
            var  flat = "";
            for(var  i = 0, len = v.length; i < len; i++){
                flat += this.encodeValue(v[i]);
                if(i != len-1) flat += "^";
            }

            I = "a:" + flat;
        }else  if(typeof  v == "object"){
            var  flat = "";
            for(var  key  in  v){
                if(typeof  v[key] != "function"){
                    flat += key + "=" + this.encodeValue(v[key]) + "^";
                }
            }

            I = "o:" + flat.substring(0, flat.length-1);
        }else {
            I = "s:" + v;
        }
        return  escape(I);        
    }
});


/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.state.Manager
 * This is the global state manager. By default all components that are "state aware" check this class
 * for state information if you don't pass them a custom state provider. In order for this class
 * to be useful, it must be initialized with a provider when your application initializes.
 <pre><code>
// in your initialization function
init : function(){
   Roo.state.Manager.setProvider(new Roo.state.CookieProvider());
   ...
   // supposed you have a {@link Roo.BorderLayout}
   var layout = new Roo.BorderLayout(...);
   layout.restoreState();
   // or a {Roo.BasicDialog}
   var dialog = new Roo.BasicDialog(...);
   dialog.restoreState();
 </code></pre>
 * @singleton
 */
Roo.state.Manager = function(){
    var  A = new  Roo.state.Provider();
    
    return  {
        /**
         * Configures the default state provider for your application
         * @param {Provider} stateProvider The state provider to set
         */
        setProvider : function(H){
            A = H;
        },
        
        /**
         * Returns the current value for a key
         * @param {String} name The key name
         * @param {Mixed} defaultValue The default value to return if the key lookup does not match
         * @return {Mixed} The state data
         */
        get : function(I, J){
            return  A.get(I, J);
        },
        
        /**
         * Sets the value for a key
         * @param {String} name The key name
         * @param {Mixed} value The state data
         */
         set : function(K, L){
            A.set(K, L);
        },
        
        /**
         * Clears a value from the state
         * @param {String} name The key name
         */
        clear : function(M){
            A.clear(M);
        },
        
        /**
         * Gets the currently configured state provider
         * @return {Provider} The state provider
         */
        getProvider : function(){
            return  A;
        }
    };
}();

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.state.CookieProvider
 * @extends Roo.state.Provider
 * The default Provider implementation which saves state via cookies.
 * <br />Usage:
 <pre><code>
   var cp = new Roo.state.CookieProvider({
       path: "/cgi-bin/",
       expires: new Date(new Date().getTime()+(1000*60*60*24*30)); //30 days
       domain: "roojs.com"
   })
   Roo.state.Manager.setProvider(cp);
 </code></pre>
 * @cfg {String} path The path for which the cookie is active (defaults to root '/' which makes it active for all pages in the site)
 * @cfg {Date} expires The cookie expiration date (defaults to 7 days from now)
 * @cfg {String} domain The domain to save the cookie for.  Note that you cannot specify a different domain than
 * your page is on, but you can specify a sub-domain, or simply the domain itself like 'roojs.com' to include
 * all sub-domains if you need to access cookies across different sub-domains (defaults to null which uses the same
 * domain the page is running on including the 'www' like 'www.roojs.com')
 * @cfg {Boolean} secure True if the site is using SSL (defaults to false)
 * @constructor
 * Create a new CookieProvider
 * @param {Object} config The configuration object
 */
Roo.state.CookieProvider = function(A){
    Roo.state.CookieProvider.superclass.constructor.call(this);
    this.path = "/";
    this.expires = new  Date(new  Date().getTime()+(1000*60*60*24*7)); //7 days
    this.domain = null;
    this.secure = false;
    Roo.apply(this, A);
    this.state = this.readCookies();
};

Roo.extend(Roo.state.CookieProvider, Roo.state.Provider, {
    // private
    set : function(B, C){
        if(typeof  C == "undefined" || C === null){
            this.clear(B);
            return;
        }

        this.setCookie(B, C);
        Roo.state.CookieProvider.superclass.set.call(this, B, C);
    },

    // private
    clear : function(D){
        this.clearCookie(D);
        Roo.state.CookieProvider.superclass.clear.call(this, D);
    },

    // private
    readCookies : function(){
        var  E = {};
        var  c = document.cookie + ";";
        var  re = /\s?(.*?)=(.*?);/g;
    	var  F;
    	while((F = re.exec(c)) != null){
            var  D = F[1];
            var  C = F[2];
            if(D && D.substring(0,3) == "ys-"){
                E[D.substr(3)] = this.decodeValue(C);
            }
        }
        return  E;
    },

    // private
    setCookie : function(G, H){
        document.cookie = "ys-"+ G + "=" + this.encodeValue(H) +
           ((this.expires == null) ? "" : ("; expires=" + this.expires.toGMTString())) +
           ((this.path == null) ? "" : ("; path=" + this.path)) +
           ((this.domain == null) ? "" : ("; domain=" + this.domain)) +
           ((this.secure == true) ? "; secure" : "");
    },

    // private
    clearCookie : function(I){
        document.cookie = "ys-" + I + "=null; expires=Thu, 01-Jan-70 00:00:01 GMT" +
           ((this.path == null) ? "" : ("; path=" + this.path)) +
           ((this.domain == null) ? "" : ("; domain=" + this.domain)) +
           ((this.secure == true) ? "; secure" : "");
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */



/*
 * These classes are derivatives of the similarly named classes in the YUI Library.
 * The original license:
 * Copyright (c) 2006, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 * http://developer.yahoo.net/yui/license.txt
 */

(function() {

var  A=Roo.EventManager;
var  B=Roo.lib.Dom;

/**
 * @class Roo.dd.DragDrop
 * Defines the interface and base operation of items that that can be
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver and onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with
 * other DragDrop objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that
 * was clicked matches a handle element.  By default this is the linked
 * element, but there are times that you will want only a portion of the
 * linked element to initiate the drag operation, and the setHandleElId()
 * method provides a way to define this.</li>
 * <li>drag element: this represents the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in {@link Roo.dd.DD}.  setDragElId() lets you define
 * a separate element that would be moved, as in {@link Roo.dd.DDProxy}.
 * </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any
 * other DragDrop obj in the "group1" group:
 * <pre>
 *  dd = new Roo.dd.DragDrop("div1", "group1");
 * </pre>
 * Since none of the event handlers have been implemented, nothing would
 * actually happen if you were to run the code above.  Normally you would
 * override this class or one of the default implementations, but you can
 * also override the methods you want on an instance of the class...
 * <pre>
 *  dd.onDragDrop = function(e, id) {
 *  &nbsp;&nbsp;alert("dd was dropped on " + id);
 *  }
 * </pre>
 * @constructor
 * @param {String} id of the element that is linked to this instance
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DragDrop:
 *                    padding, isTarget, maintainOffset, primaryButtonOnly
 */
Roo.dd.DragDrop = function(id, C, D) {
    if (id) {
        this.init(id, C, D);
    }
};

Roo.dd.DragDrop.prototype = {

    /**
     * The id of the element associated with this object.  This is what we
     * refer to as the "linked element" because the size and position of
     * this element is used to determine when the drag and drop objects have
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same
     * as the linked element , but could be changed to another element. Ex:
     * Roo.dd.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null,

    /**
     * the id of the element that initiates the drag operation.  By default
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null,

    /**
     * An associative array of HTML tags that will be ignored if clicked.
     * @property invalidHandleTypes
     * @type {string: string}
     */
    invalidHandleTypes: null,

    /**
     * An associative array of ids for elements that will be ignored if clicked
     * @property invalidHandleIds
     * @type {string: string}
     */
    invalidHandleIds: null,

    /**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * @property invalidHandleClasses
     * @type string[]
     */
    invalidHandleClasses: null,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are
     * related.  Instances only get events when interacting with other
     * DragDrop object in the same group.  This lets us define multiple
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type {string: string}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function() { this.locked = true; },

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function() { this.locked = false; },

    /**
     * By default, all insances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @method isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @method padding
     * @type int[]
     */
    padding: null,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a
     * vertical graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function(x, y) { },

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function(x, y) { /* override this */ },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function(e) { },

    /**
     * Abstract method called during the onMouseMove event while dragging an
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function(e) { /* override this */ },

    /**
     * Abstract method called when this element fist begins hovering over
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more
     * dragdrop items being hovered over.
     */
    onDragEnter: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function(e) { },

    /**
     * Abstract method called when this element is hovering over another
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items
     * being hovered over.
     */
    onDragOver: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function(e) { },

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items
     * that the mouse is no longer over.
     */
    onDragOut: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function(e) { },

    /**
     * Abstract method called when this item is dropped on another DragDrop
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this
     * was dropped on.
     */
    onDragDrop: function(e, id) { /* override this */ },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function(e) { /* override this */ },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function(e) { },

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function(e) { /* override this */ },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function(e) {  },

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function(e) { /* override this */ },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function(e) { /* override this */ },

    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () {
    },

    /*
     * Provides default constraint padding to "constrainTo" elements (defaults to {left: 0, right:0, top:0, bottom:0}).
     * @type Object
     */
    defaultPadding : {left:0, right:0, top:0, bottom:0},

    /*
     * Initializes the drag drop object's constraints to restrict movement to a certain element.
 *
 * Usage:
 <pre><code>
 var dd = new Roo.dd.DDProxy("dragDiv1", "proxytest",
                { dragElId: "existingProxyDiv" });
 dd.startDrag = function(){
     this.constrainTo("parent-id");
 };
 </code></pre>
 * Or you can initalize it using the {@link Roo.Element} object:
 <pre><code>
 Roo.get("dragDiv1").initDDProxy("proxytest", {dragElId: "existingProxyDiv"}, {
     startDrag : function(){
         this.constrainTo("parent-id");
     }
 });
 </code></pre>
     * @param {String/HTMLElement/Element} constrainTo The element to constrain to.
     * @param {Object/Number} pad (optional) Pad provides a way to specify "padding" of the constraints,
     * and can be either a number for symmetrical padding (4 would be equal to {left:4, right:4, top:4, bottom:4}) or
     * an object containing the sides to pad. For example: {right:10, bottom:10}
     * @param {Boolean} inContent (optional) Constrain the draggable in the content box of the element (inside padding and borders)
     */
    constrainTo : function(C, D, E){
        if(typeof  D == "number"){
            D = {left: D, right:D, top:D, bottom:D};
        }

        D = D || this.defaultPadding;
        var  b = Roo.get(this.getEl()).getBox();
        var  ce = Roo.get(C);
        var  s = ce.getScroll();
        var  c, cd = ce.dom;
        if(cd == document.body){
            c = { x: s.left, y: s.top, width: Roo.lib.Dom.getViewWidth(), height: Roo.lib.Dom.getViewHeight()};
        }else {
            xy = ce.getXY();
            c = {x : xy[0]+s.left, y: xy[1]+s.top, width: cd.clientWidth, height: cd.clientHeight};
        }


        var  F = b.y - c.y;
        var  G = b.x - c.x;

        this.resetConstraints();
        this.setXConstraint(G - (D.left||0), // left
                c.width - G - b.width - (D.right||0) //right
        );
        this.setYConstraint(F - (D.top||0), //top
                c.height - F - b.height - (D.bottom||0) //bottom
        );
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element
     */
    getEl: function() {
        if (!this._domRef) {
            this._domRef = Roo.getDom(this.id);
        }

        return  this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another
     * element. An example of this can be found in Roo.dd.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element
     */
    getDragEl: function() {
        return  Roo.getDom(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * Roo.dd.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function(id, H, I) {
        this.initTarget(id, H, I);
        A.on(this.id, "mousedown", this.handleMouseDown, this);
        // Event.on(this.id, "selectstart", Event.preventDefault);
    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function(id, J, K) {

        // configuration attributes
        this.config = K || {};

        // create a local reference to the drag and drop manager
        this.DDM = Roo.dd.DDM;
        // initialize the groups array
        this.groups = {};

        // assume that we have an element reference instead of an id if the
        // parameter is not a string
        if (typeof  id !== "string") {
            id = Roo.id(id);
        }


        // set the id
        this.id = id;

        // add to an interaction group
        this.addToGroup((J) ? J : "default");

        // We don't want to register this as the handle with the manager
        // so we just set the id rather than calling the setter.
        this.handleElId = id;

        // the linked element is the element that gets dragged by default
        this.setDragElId(id);

        // by default, clicked anchors will not start drag operations.
        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();

        this.handleOnAvailable();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function() {

        // configurable properties:
        //    padding, isTarget, maintainOffset, primaryButtonOnly
        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);

    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function(L, M, N, O) {
        // this.padding = [iLeft, iRight, iTop, iBot];
        if (!M && 0 !== M) {
            this.padding = [L, L, L, L];
        } else  if (!N && 0 !== N) {
            this.padding = [L, M, L, M];
        } else  {
            this.padding = [L, M, N, O];
        }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitialPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     */
    setInitPosition: function(P, Q) {
        var  el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            return;
        }

        var  dx = P || 0;
        var  dy = Q || 0;

        var  p = B.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];


        this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function(R) {
        var  p = R || B.getXY( this.getEl() );
        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All
     * instances belong to at least one group, and can belong to as many
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function(S) {
        this.groups[S] = true;
        this.DDM.regDragDrop(this, S);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function(T) {
        if (this.groups[T]) {
            delete  this.groups[T];
        }


        this.DDM.removeDDFromGroup(this, T);
    },

    /**
     * Allows you to specify that an element other than the linked element
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be
     * used to initiate the drag operation.  An example of this would be if
     * you have a content div with text and links.  Clicking anywhere in the
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to
     * initiate the drag.
     */
    setHandleElId: function(id) {
        if (typeof  id !== "string") {
            id = Roo.id(id);
        }

        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function(id) {
        if (typeof  id !== "string") {
            id = Roo.id(id);
        }

        A.on(id, "mousedown",
                this.handleMouseDown, this);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function() {
        A.un(this.id, "mousedown",
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    destroy : function(){
        this.unreg();
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else
     * false
     */
    isLocked: function() {
        return  (this.DDM.isLocked() || this.locked);
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e
     * @param {Roo.dd.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function(e, U){
        if (this.primaryButtonOnly && e.button != 0) {
            return;
        }

        if (this.isLocked()) {
            return;
        }


        this.DDM.refreshCache(this.groups);

        var  pt = new  Roo.lib.Point(Roo.lib.Event.getPageX(e), Roo.lib.Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else  {
            if (this.clickValidator(e)) {

                // set the initial element position
                this.setStartPosition();


                this.b4MouseDown(e);
                this.onMouseDown(e);

                this.DDM.handleMouseDown(e, this);

                this.DDM.stopEvent(e);
            } else  {


            }
        }
    },

    clickValidator: function(e) {
        var  V = e.getTarget();
        return  ( this.isValidHandleChild(V) &&
                    (this.id == this.handleElId ||
                        this.DDM.handleWasClicked(V, this.id)) );
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function(W) {
        var  X = W.toUpperCase();
        this.invalidHandleTypes[X] = X;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function(id) {
        if (typeof  id !== "string") {
            id = Roo.id(id);
        }

        this.invalidHandleIds[id] = id;
    },

    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function(Y) {
        this.invalidHandleClasses.push(Y);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function(Z) {
        var  a = Z.toUpperCase();
        // this.invalidHandleTypes[type] = null;
        delete  this.invalidHandleTypes[a];
    },

    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function(id) {
        if (typeof  id !== "string") {
            id = Roo.id(id);
        }
        delete  this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to
     * re-enable
     */
    removeInvalidHandleClass: function(d) {
        for (var  i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == d) {
                delete  this.invalidHandleClasses[i];
            }
        }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function(f) {

        var  g = true;
        // var n = (node.nodeName == "#text") ? node.parentNode : node;
        var  h;
        try {
            h = f.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }

        g = g && !this.invalidHandleTypes[h];
        g = g && !this.invalidHandleIds[f.id];

        for (var  i=0, len=this.invalidHandleClasses.length; g && i<len; ++i) {
            g = !B.hasClass(f, this.invalidHandleClasses[i]);
        }


        return  g;

    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function(j, k) {
        this.xTicks = [];
        this.xTickSize = k;

        var  l = {};

        for (var  i = this.initPageX; i >= this.minX; i = i - k) {
            if (!l[i]) {
                this.xTicks[this.xTicks.length] = i;
                l[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + k) {
            if (!l[i]) {
                this.xTicks[this.xTicks.length] = i;
                l[i] = true;
            }
        }


        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function(m, n) {
        this.yTicks = [];
        this.yTickSize = n;

        var  o = {};

        for (var  i = this.initPageY; i >= this.minY; i = i - n) {
            if (!o[i]) {
                this.yTicks[this.yTicks.length] = i;
                o[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + n) {
            if (!o[i]) {
                this.yTicks[this.yTicks.length] = i;
                o[i] = true;
            }
        }


        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use
     * this method to limit the horizontal travel of the element.  Pass in
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the
     * right
     * @param {int} iTickSize optional parameter for specifying that the
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function(q, r, t) {
        this.leftConstraint = q;
        this.rightConstraint = r;

        this.minX = this.initPageX - q;
        this.maxX = this.initPageX + r;
        if (t) { this.setXTicks(this.initPageX, t); }


        this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function(u, v, w) {
        this.topConstraint = u;
        this.bottomConstraint = v;

        this.minY = this.initPageY - u;
        this.maxY = this.initPageY + v;
        if (w) { this.setYTicks(this.initPageY, w); }


        this.constrainY = true;

    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     * @param {boolean} maintainOffset
     */
    resetConstraints: function() {


        // Maintain offsets if necessary
        if (this.initPageX || this.initPageX === 0) {
            // figure out how much this thing has moved
            var  dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var  dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
        } else  {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint,
                                 this.rightConstraint,
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint,
                                 this.bottomConstraint,
                                 this.yTickSize         );
        }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify
     * that it move a number of pixels at a time.  This method resolves the
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function(z, AA) {

        if (!AA) {
            // If tick interval is not defined, it is effectively 1 pixel,
            // so we return the value passed to us.
            return  z;
        } else  if (AA[0] >= z) {
            // The value is lower than the first tick, so we return the first
            // tick.
            return  AA[0];
        } else  {
            for (var  i=0, len=AA.length; i<len; ++i) {
                var  next = i + 1;
                if (AA[next] && AA[next] >= z) {
                    var  diff1 = z - AA[i];
                    var  diff2 = AA[next] - z;
                    return  (diff2 > diff1) ? AA[i] : AA[next];
                }
            }

            // The value is larger than the last tick, so we return the last
            // tick.
            return  AA[AA.length - 1];
        }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function() {
        return  ("DragDrop " + this.id);
    }

};

})();

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 */

// Only load the library once.  Rewriting the manager class would orphan
// existing drag and drop instances.
if (!Roo.dd.DragDropMgr) {

/**
 * @class Roo.dd.DragDropMgr
 * DragDropMgr is a singleton that tracks the element interaction for
 * all DragDrop items in the window.  Generally, you will not call
 * this class directly, but it does have helper methods that could
 * be useful in your DragDrop implementations.
 * @singleton
 */
Roo.dd.DragDropMgr = function() {

    var  A = Roo.EventManager;

    return  {

        /**
         * Two dimensional Array of registered DragDrop objects.  The first
         * dimension is the DragDrop item group, the second the DragDrop
         * object.
         * @property ids
         * @type {string: string}
         * @private
         * @static
         */
        ids: {},

        /**
         * Array of element ids defined as drag handles.  Used to determine
         * if the element that generated the mousedown event is actually the
         * handle and not the html element itself.
         * @property handleIds
         * @type {string: string}
         * @private
         * @static
         */
        handleIds: {},

        /**
         * the DragDrop object that is currently being dragged
         * @property dragCurrent
         * @type DragDrop
         * @private
         * @static
         **/
        dragCurrent: null,

        /**
         * the DragDrop object(s) that are being hovered over
         * @property dragOvers
         * @type Array
         * @private
         * @static
         */
        dragOvers: {},

        /**
         * the X distance between the cursor and the object being dragged
         * @property deltaX
         * @type int
         * @private
         * @static
         */
        deltaX: 0,

        /**
         * the Y distance between the cursor and the object being dragged
         * @property deltaY
         * @type int
         * @private
         * @static
         */
        deltaY: 0,

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to
         * false if you need the default behavior (not recommended)
         * @property preventDefault
         * @type boolean
         * @static
         */
        preventDefault: true,

        /**
         * Flag to determine if we should stop the propagation of the events
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         * @property stopPropagation
         * @type boolean
         * @static
         */
        stopPropagation: true,

        /**
         * Internal flag that is set to true when drag and drop has been
         * intialized
         * @property initialized
         * @private
         * @static
         */
        initalized: false,

        /**
         * All drag and drop can be disabled.
         * @property locked
         * @private
         * @static
         */
        locked: false,

        /**
         * Called the first time an element is registered.
         * @method init
         * @private
         * @static
         */
        init: function() {
            this.initialized = true;
        },

        /**
         * In point mode, drag and drop interaction is defined by the
         * location of the cursor during the drag/drop
         * @property POINT
         * @type int
         * @static
         */
        POINT: 0,

        /**
         * In intersect mode, drag and drop interactio nis defined by the
         * overlap of two or more drag and drop objects.
         * @property INTERSECT
         * @type int
         * @static
         */
        INTERSECT: 1,

        /**
         * The current drag and drop mode.  Default: POINT
         * @property mode
         * @type int
         * @static
         */
        mode: 0,

        /**
         * Runs method on all drag and drop objects
         * @method _execOnAll
         * @private
         * @static
         */
        _execOnAll: function(AG, AH) {
            for (var  i  in  this.ids) {
                for (var  j  in  this.ids[i]) {
                    var  h = this.ids[i][j];
                    if (! this.isTypeOfDD(h)) {
                        continue;
                    }

                    h[AG].apply(h, AH);
                }
            }
        },

        /**
         * Drag and drop initialization.  Sets up the global event handlers
         * @method _onLoad
         * @private
         * @static
         */
        _onLoad: function() {

            this.init();


            A.on(document, "mouseup",   this.handleMouseUp, this, true);
            A.on(document, "mousemove", this.handleMouseMove, this, true);
            A.on(window,   "unload",    this._onUnload, this, true);
            A.on(window,   "resize",    this._onResize, this, true);
            // Event.on(window,   "mouseout",    this._test);

        },

        /**
         * Reset constraints on all drag and drop objs
         * @method _onResize
         * @private
         * @static
         */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
         * Lock all drag and drop functionality
         * @method lock
         * @static
         */
        lock: function() { this.locked = true; },

        /**
         * Unlock all drag and drop functionality
         * @method unlock
         * @static
         */
        unlock: function() { this.locked = false; },

        /**
         * Is drag and drop locked?
         * @method isLocked
         * @return {boolean} True if drag and drop is locked, false otherwise.
         * @static
         */
        isLocked: function() { return  this.locked; },

        /**
         * Location cache that is set for all drag drop objects when a drag is
         * initiated, cleared when the drag is finished.
         * @property locationCache
         * @private
         * @static
         */
        locationCache: {},

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * @property useCache
         * @type boolean
         * @static
         */
        useCache: true,

        /**
         * The number of pixels that the mouse needs to move after the
         * mousedown before the drag is initiated.  Default=3;
         * @property clickPixelThresh
         * @type int
         * @static
         */
        clickPixelThresh: 3,

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * @property clickTimeThresh
         * @type int
         * @static
         */
        clickTimeThresh: 350,

        /**
         * Flag that indicates that either the drag pixel threshold or the
         * mousdown time threshold has been met
         * @property dragThreshMet
         * @type boolean
         * @private
         * @static
         */
        dragThreshMet: false,

        /**
         * Timeout used for the click time threshold
         * @property clickTimeout
         * @type Object
         * @private
         * @static
         */
        clickTimeout: null,

        /**
         * The X position of the mousedown event stored for later use when a
         * drag threshold is met.
         * @property startX
         * @type int
         * @private
         * @static
         */
        startX: 0,

        /**
         * The Y position of the mousedown event stored for later use when a
         * drag threshold is met.
         * @property startY
         * @type int
         * @private
         * @static
         */
        startY: 0,

        /**
         * Each DragDrop instance must be registered with the DragDropMgr.
         * This is executed in DragDrop.init()
         * @method regDragDrop
         * @param {DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         * @static
         */
        regDragDrop: function(AI, AJ) {
            if (!this.initialized) { this.init(); }

            if (!this.ids[AJ]) {
                this.ids[AJ] = {};
            }

            this.ids[AJ][AI.id] = AI;
        },

        /**
         * Removes the supplied dd instance from the supplied group. Executed
         * by DragDrop.removeFromGroup, so don't call this function directly.
         * @method removeDDFromGroup
         * @private
         * @static
         */
        removeDDFromGroup: function(AK, AL) {
            if (!this.ids[AL]) {
                this.ids[AL] = {};
            }

            var  AM = this.ids[AL];
            if (AM && AM[AK.id]) {
                delete  AM[AK.id];
            }
        },

        /**
         * Unregisters a drag and drop item.  This is executed in
         * DragDrop.unreg, use that method instead of calling this directly.
         * @method _remove
         * @private
         * @static
         */
        _remove: function(AN) {
            for (var  g  in  AN.groups) {
                if (g && this.ids[g][AN.id]) {
                    delete  this.ids[g][AN.id];
                }
            }
            delete  this.handleIds[AN.id];
        },

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @method regHandle
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag
         * handle
         * @static
         */
        regHandle: function(AO, AP) {
            if (!this.handleIds[AO]) {
                this.handleIds[AO] = {};
            }

            this.handleIds[AO][AP] = AP;
        },

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop item.
         * @method isDragDrop
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop item,
         * false otherwise
         * @static
         */
        isDragDrop: function(id) {
            return  ( this.getDDById(id) ) ? true : false;
        },

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @method getRelated
         * @param {DragDrop} p_oDD the obj to get related data for
         * @param {boolean} bTargetsOnly if true, only return targetable objs
         * @return {DragDrop[]} the related instances
         * @static
         */
        getRelated: function(AQ, AR) {
            var  AS = [];
            for (var  i  in  AQ.groups) {
                for (j  in  this.ids[i]) {
                    var  dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!AR || dd.isTarget) {
                        AS[AS.length] = dd;
                    }
                }
            }

            return  AS;
        },

        /**
         * Returns true if the specified dd target is a legal target for
         * the specifice drag obj
         * @method isLegalTarget
         * @param {DragDrop} the drag obj
         * @param {DragDrop} the target
         * @return {boolean} true if the target is a legal target for the
         * dd obj
         * @static
         */
        isLegalTarget: function (AT, AU) {
            var  AV = this.getRelated(AT, true);
            for (var  i=0, d=AV.length;i<d;++i) {
                if (AV[i].id == AU.id) {
                    return  true;
                }
            }

            return  false;
        },

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @method isTypeOfDD
         * @param {Object} the object to evaluate
         * @return {boolean} true if typeof oDD = DragDrop
         * @static
         */
        isTypeOfDD: function (AW) {
            return  (AW && AW.__ygDragDrop);
        },

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop handle for the given Drag Drop object.
         * @method isHandle
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop handle, false
         * otherwise
         * @static
         */
        isHandle: function(AX, AY) {
            return  ( this.handleIds[AX] &&
                            this.handleIds[AX][AY] );
        },

        /**
         * Returns the DragDrop instance for a given id
         * @method getDDById
         * @param {String} id the id of the DragDrop object
         * @return {DragDrop} the drag drop object, null if it is not found
         * @static
         */
        getDDById: function(id) {
            for (var  i  in  this.ids) {
                if (this.ids[i][id]) {
                    return  this.ids[i][id];
                }
            }
            return  null;
        },

        /**
         * Fired after a registered DragDrop object gets the mousedown event.
         * Sets up the events required to track the object being dragged
         * @method handleMouseDown
         * @param {Event} e the event
         * @param oDD the DragDrop object being dragged
         * @private
         * @static
         */
        handleMouseDown: function(e, AZ) {
            if(Roo.QuickTips){
                Roo.QuickTips.disable();
            }

            this.currentTarget = e.getTarget();

            this.dragCurrent = AZ;

            var  el = AZ.getEl();

            // track start position
            this.startX = e.getPageX();
            this.startY = e.getPageY();

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout(
                    function() {
                        var  Aa = Roo.dd.DDM;
                        Aa.startDrag(Aa.startX, Aa.startY);
                    },
                    this.clickTimeThresh );
        },

        /**
         * Fired when either the drag pixel threshol or the mousedown hold
         * time threshold has been met.
         * @method startDrag
         * @param x {int} the X position of the original mousedown
         * @param y {int} the Y position of the original mousedown
         * @static
         */
        startDrag: function(x, y) {
            clearTimeout(this.clickTimeout);
            if (this.dragCurrent) {
                this.dragCurrent.b4StartDrag(x, y);
                this.dragCurrent.startDrag(x, y);
            }

            this.dragThreshMet = true;
        },

        /**
         * Internal function to handle the mouseup event.  Will be invoked
         * from the context of the document.
         * @method handleMouseUp
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseUp: function(e) {

            if(Roo.QuickTips){
                Roo.QuickTips.enable();
            }
            if (! this.dragCurrent) {
                return;
            }


            clearTimeout(this.clickTimeout);

            if (this.dragThreshMet) {
                this.fireEvents(e, true);
            } else  {
            }


            this.stopDrag(e);

            this.stopEvent(e);
        },

        /**
         * Utility to stop event propagation and event default, if these
         * features are turned on.
         * @method stopEvent
         * @param {Event} e the event as returned by this.getEvent()
         * @static
         */
        stopEvent: function(e){
            if(this.stopPropagation) {
                e.stopPropagation();
            }

            if (this.preventDefault) {
                e.preventDefault();
            }
        },

        /**
         * Internal function to clean up event handlers after the drag
         * operation is complete
         * @method stopDrag
         * @param {Event} e the event
         * @private
         * @static
         */
        stopDrag: function(e) {
            // Fire the drag end event for the item that was dragged
            if (this.dragCurrent) {
                if (this.dragThreshMet) {
                    this.dragCurrent.b4EndDrag(e);
                    this.dragCurrent.endDrag(e);
                }


                this.dragCurrent.onMouseUp(e);
            }


            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /**
         * Internal function to handle the mousemove event.  Will be invoked
         * from the context of the html element.
         *
         * @TODO figure out what we can do about mouse events lost when the
         * user drags objects beyond the window boundary.  Currently we can
         * detect this in internet explorer by verifying that the mouse is
         * down during the mousemove event.  Firefox doesn't give us the
         * button state on the mousemove event.
         * @method handleMouseMove
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseMove: function(e) {
            if (! this.dragCurrent) {
                return  true;
            }

            // var button = e.which || e.button;

            // check for IE mouseup outside of page boundary
            if (Roo.isIE && (e.button !== 0 && e.button !== 1 && e.button !== 2)) {
                this.stopEvent(e);
                return  this.handleMouseUp(e);
            }

            if (!this.dragThreshMet) {
                var  diffX = Math.abs(this.startX - e.getPageX());
                var  diffY = Math.abs(this.startY - e.getPageY());
                if (diffX > this.clickPixelThresh ||
                            diffY > this.clickPixelThresh) {
                    this.startDrag(this.startX, this.startY);
                }
            }

            if (this.dragThreshMet) {
                this.dragCurrent.b4Drag(e);
                this.dragCurrent.onDrag(e);
                if(!this.dragCurrent.moveOnly){
                    this.fireEvents(e, false);
                }
            }


            this.stopEvent(e);

            return  true;
        },

        /**
         * Iterates over all of the DragDrop elements to find ones we are
         * hovering over or dropping on
         * @method fireEvents
         * @param {Event} e the event
         * @param {boolean} isDrop is this a drop op or a mouseover op?
         * @private
         * @static
         */
        fireEvents: function(e, Aa) {
            var  dc = this.dragCurrent;

            // If the user did the mouse up outside of the window, we could
            // get here even though we have ended the drag.
            if (!dc || dc.isLocked()) {
                return;
            }

            var  pt = e.getPoint();

            // cache the previous dragOver array
            var  Ab = [];

            var  Ac   = [];
            var  Ad  = [];
            var  Ae  = [];
            var  Af = [];

            // Check to see if the object(s) we were hovering over is no longer
            // being hovered over so we can fire the onDragOut event
            for (var  i  in  this.dragOvers) {

                var  ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }

                if (! this.isOverTarget(pt, ddo, this.mode)) {
                    Ac.push( ddo );
                }


                Ab[i] = true;
                delete  this.dragOvers[i];
            }

            for (var  AL  in  dc.groups) {

                if ("string" != typeof  AL) {
                    continue;
                }

                for (i  in  this.ids[AL]) {
                    var  AZ = this.ids[AL][i];
                    if (! this.isTypeOfDD(AZ)) {
                        continue;
                    }

                    if (AZ.isTarget && !AZ.isLocked() && AZ != dc) {
                        if (this.isOverTarget(pt, AZ, this.mode)) {
                            // look for drop interactions
                            if (Aa) {
                                Ae.push( AZ );
                            // look for drag enter and drag over interactions
                            } else  {

                                // initial drag over: dragEnter fires
                                if (!Ab[AZ.id]) {
                                    Af.push( AZ );
                                // subsequent drag overs: dragOver fires
                                } else  {
                                    Ad.push( AZ );
                                }


                                this.dragOvers[AZ.id] = AZ;
                            }
                        }
                    }
                }
            }

            if (this.mode) {
                if (Ac.length) {
                    dc.b4DragOut(e, Ac);
                    dc.onDragOut(e, Ac);
                }

                if (Af.length) {
                    dc.onDragEnter(e, Af);
                }

                if (Ad.length) {
                    dc.b4DragOver(e, Ad);
                    dc.onDragOver(e, Ad);
                }

                if (Ae.length) {
                    dc.b4DragDrop(e, Ae);
                    dc.onDragDrop(e, Ae);
                }

            } else  {
                // fire dragout events
                var  d = 0;
                for (i=0, d=Ac.length; i<d; ++i) {
                    dc.b4DragOut(e, Ac[i].id);
                    dc.onDragOut(e, Ac[i].id);
                }

                // fire enter events
                for (i=0,d=Af.length; i<d; ++i) {
                    // dc.b4DragEnter(e, oDD.id);
                    dc.onDragEnter(e, Af[i].id);
                }

                // fire over events
                for (i=0,d=Ad.length; i<d; ++i) {
                    dc.b4DragOver(e, Ad[i].id);
                    dc.onDragOver(e, Ad[i].id);
                }

                // fire drop events
                for (i=0, d=Ae.length; i<d; ++i) {
                    dc.b4DragDrop(e, Ae[i].id);
                    dc.onDragDrop(e, Ae[i].id);
                }

            }

            // notify about a drop that did not find a target
            if (Aa && !Ae.length) {
                dc.onInvalidDrop(e);
            }

        },

        /**
         * Helper function for getting the best match from the list of drag
         * and drop objects returned by the drag and drop events when we are
         * in INTERSECT mode.  It returns either the first object that the
         * cursor is over, or the object that has the greatest overlap with
         * the dragged element.
         * @method getBestMatch
         * @param  {DragDrop[]} dds The array of drag and drop objects
         * targeted
         * @return {DragDrop}       The best single match
         * @static
         */
        getBestMatch: function(Ag) {
            var  Ah = null;
            // Return null if the input is not what we expect
            //if (!dds || !dds.length || dds.length == 0) {
               // winner = null;
            // If there is only one item, it wins
            //} else if (dds.length == 1) {

            var  Ai = Ag.length;

            if (Ai == 1) {
                Ah = Ag[0];
            } else  {
                // Loop through the targeted items
                for (var  i=0; i<Ai; ++i) {
                    var  dd = Ag[i];
                    // If the cursor is over the object, it wins.  If the
                    // cursor is over multiple matches, the first one we come
                    // to wins.
                    if (dd.cursorIsOver) {
                        Ah = dd;
                        break;
                    // Otherwise the object with the most overlap wins
                    } else  {
                        if (!Ah ||
                            Ah.overlap.getArea() < dd.overlap.getArea()) {
                            Ah = dd;
                        }
                    }
                }
            }

            return  Ah;
        },

        /**
         * Refreshes the cache of the top-left and bottom-right points of the
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical
         * usage is:
         * <code>
         * Roo.dd.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
         * Alternatively:
         * <code>
         * Roo.dd.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
         * @TODO this really should be an indexed array.  Alternatively this
         * method could accept both.
         * @method refreshCache
         * @param {Object} groups an associative array of groups to refresh
         * @static
         */
        refreshCache: function(Aj) {
            for (var  AL  in  Aj) {
                if ("string" != typeof  AL) {
                    continue;
                }
                for (var  i  in  this.ids[AL]) {
                    var  AZ = this.ids[AL][i];

                    if (this.isTypeOfDD(AZ)) {
                    // if (this.isTypeOfDD(oDD) && oDD.isTarget) {
                        var  o = this.getLocation(AZ);
                        if (o) {
                            this.locationCache[AZ.id] = o;
                        } else  {
                            delete  this.locationCache[AZ.id];
                            // this will unregister the drag and drop object if
                            // the element is not in a usable state
                            // oDD.unreg();
                        }
                    }
                }
            }
        },

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @method verifyEl
         * @param {HTMLElement} el the element to check
         * @return {boolean} true if the element looks usable
         * @static
         */
        verifyEl: function(el) {
            if (el) {
                var  parent;
                if(Roo.isIE){
                    try{
                        parent = el.offsetParent;
                    }catch(e){}
                }else {
                    parent = el.offsetParent;
                }
                if (parent) {
                    return  true;
                }
            }

            return  false;
        },

        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @method getLocation
         * @param {DragDrop} oDD the drag and drop object to get the
         *                       location for
         * @return {Roo.lib.Region} a Region object representing the total area
         *                             the element occupies, including any padding
         *                             the instance is configured for.
         * @static
         */
        getLocation: function(Ak) {
            if (! this.isTypeOfDD(Ak)) {
                return  null;
            }

            var  el = Ak.getEl(), Al, x1, x2, y1, y2, t, r, b, l;

            try {
                Al= Roo.lib.Dom.getXY(el);
            } catch (e) { }

            if (!Al) {
                return  null;
            }


            x1 = Al[0];
            x2 = x1 + el.offsetWidth;
            y1 = Al[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - Ak.padding[0];
            r = x2 + Ak.padding[1];
            b = y2 + Ak.padding[2];
            l = x1 - Ak.padding[3];

            return  new  Roo.lib.Region( t, r, b, l );
        },

        /**
         * Checks the cursor location to see if it over the target
         * @method isOverTarget
         * @param {Roo.lib.Point} pt The point to evaluate
         * @param {DragDrop} oTarget the DragDrop object we are inspecting
         * @return {boolean} true if the mouse is over the target
         * @private
         * @static
         */
        isOverTarget: function(pt, Am, An) {
            // use cache if available
            var  Ao = this.locationCache[Am.id];
            if (!Ao || !this.useCache) {
                Ao = this.getLocation(Am);
                this.locationCache[Am.id] = Ao;

            }

            if (!Ao) {
                return  false;
            }


            Am.cursorIsOver = Ao.contains( pt );

            // DragDrop is using this as a sanity check for the initial mousedown
            // in this case we are done.  In POINT mode, if the drag obj has no
            // contraints, we are also done. Otherwise we need to evaluate the
            // location of the target as related to the actual location of the
            // dragged element.
            var  dc = this.dragCurrent;
            if (!dc || !dc.getTargetCoord ||
                    (!An && !dc.constrainX && !dc.constrainY)) {
                return  Am.cursorIsOver;
            }


            Am.overlap = null;

            // Get the current location of the drag element, this is the
            // location of the mouse event less the delta that represents
            // where the original mousedown happened on the element.  We
            // need to consider constraints and ticks as well.
            var  Ap = dc.getTargetCoord(pt.x, pt.y);

            var  el = dc.getDragEl();
            var  Aq = new  Roo.lib.Region( Ap.y,
                                                   Ap.x + el.offsetWidth,
                                                   Ap.y + el.offsetHeight,
                                                   Ap.x );

            var  Ar = Aq.intersect(Ao);

            if (Ar) {
                Am.overlap = Ar;
                return  (An) ? true : Am.cursorIsOver;
            } else  {
                return  false;
            }
        },

        /**
         * unload event handler
         * @method _onUnload
         * @private
         * @static
         */
        _onUnload: function(e, me) {
            Roo.dd.DragDropMgr.unregAll();
        },

        /**
         * Cleans up the drag and drop events and objects.
         * @method unregAll
         * @private
         * @static
         */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }


            this._execOnAll("unreg", []);

            for (i  in  this.elementCache) {
                delete  this.elementCache[i];
            }


            this.elementCache = {};
            this.ids = {};
        },

        /**
         * A cache of DOM elements
         * @property elementCache
         * @private
         * @static
         */
        elementCache: {},

        /**
         * Get the wrapper for the DOM element specified
         * @method getElWrapper
         * @param {String} id the id of the element to get
         * @return {Roo.dd.DDM.ElementWrapper} the wrapped element
         * @private
         * @deprecated This wrapper isn't that useful
         * @static
         */
        getElWrapper: function(id) {
            var  As = this.elementCache[id];
            if (!As || !As.el) {
                As = this.elementCache[id] =
                    new  this.ElementWrapper(Roo.getDom(id));
            }
            return  As;
        },

        /**
         * Returns the actual DOM element
         * @method getElement
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use Roo.getDom instead
         * @static
         */
        getElement: function(id) {
            return  Roo.getDom(id);
        },

        /**
         * Returns the style property for the DOM element (i.e.,
         * document.getElById(id).style)
         * @method getCss
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         * @deprecated use Roo.getDom instead
         * @static
         */
        getCss: function(id) {
            var  el = Roo.getDom(id);
            return  (el) ? el.style : null;
        },

        /**
         * Inner class for cached elements
         * @class DragDropMgr.ElementWrapper
         * @for DragDropMgr
         * @private
         * @deprecated
         */
        ElementWrapper: function(el) {
                /**
                 * The element
                 * @property el
                 */
                this.el = el || null;
                /**
                 * The element id
                 * @property id
                 */
                this.id = this.el && el.id;
                /**
                 * A reference to the style property
                 * @property css
                 */
                this.css = this.el && el.style;
            },

        /**
         * Returns the X position of an html element
         * @method getPosX
         * @param el the element for which to get the position
         * @return {int} the X coordinate
         * @for DragDropMgr
         * @deprecated use Roo.lib.Dom.getX instead
         * @static
         */
        getPosX: function(el) {
            return  Roo.lib.Dom.getX(el);
        },

        /**
         * Returns the Y position of an html element
         * @method getPosY
         * @param el the element for which to get the position
         * @return {int} the Y coordinate
         * @deprecated use Roo.lib.Dom.getY instead
         * @static
         */
        getPosY: function(el) {
            return  Roo.lib.Dom.getY(el);
        },

        /**
         * Swap two nodes.  In IE, we use the native method, for others we
         * emulate the IE behavior
         * @method swapNode
         * @param n1 the first node to swap
         * @param n2 the other node to swap
         * @static
         */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else  {
                var  p = n2.parentNode;
                var  s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else  if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else  {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
         * Returns the current scroll position
         * @method getScroll
         * @private
         * @static
         */
        getScroll: function () {
            var  t, l, At=document.documentElement, db=document.body;
            if (At && (At.scrollTop || At.scrollLeft)) {
                t = At.scrollTop;
                l = At.scrollLeft;
            } else  if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else  {

            }
            return  { top: t, left: l };
        },

        /**
         * Returns the specified element style property
         * @method getStyle
         * @param {HTMLElement} el          the element
         * @param {string}      styleProp   the style property
         * @return {string} The value of the style property
         * @deprecated use Roo.lib.Dom.getStyle
         * @static
         */
        getStyle: function(el, Au) {
            return  Roo.fly(el).getStyle(Au);
        },

        /**
         * Gets the scrollTop
         * @method getScrollTop
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollTop: function () { return  this.getScroll().top; },

        /**
         * Gets the scrollLeft
         * @method getScrollLeft
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollLeft: function () { return  this.getScroll().left; },

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @method moveToEl
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         * @static
         */
        moveToEl: function (Av, Aw) {
            var  Ax = Roo.lib.Dom.getXY(Aw);
            Roo.lib.Dom.setXY(Av, Ax);
        },

        /**
         * Numeric array sort function
         * @method numericSort
         * @static
         */
        numericSort: function(a, b) { return  (a - b); },

        /**
         * Internal counter
         * @property _timeoutCount
         * @private
         * @static
         */
        _timeoutCount: 0,

        /**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * @method _addListeners
         * @private
         * @static
         */
        _addListeners: function() {
            var  Ay = Roo.dd.DDM;
            if ( Roo.lib.Event && document ) {
                Ay._onLoad();
            } else  {
                if (Ay._timeoutCount > 2000) {
                } else  {
                    setTimeout(Ay._addListeners, 10);
                    if (document && document.body) {
                        Ay._timeoutCount += 1;
                    }
                }
            }
        },

        /**
         * Recursively searches the immediate parent and all child nodes for
         * the handle element in order to determine wheter or not it was
         * clicked.
         * @method handleWasClicked
         * @param node the html element to inspect
         * @static
         */
        handleWasClicked: function(Az, id) {
            if (this.isHandle(id, Az.id)) {
                return  true;
            } else  {
                // check to see if this is a text node child of the one we want
                var  p = Az.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return  true;
                    } else  {
                        p = p.parentNode;
                    }
                }
            }

            return  false;
        }

    };

}();

// shorter alias, save a few bytes
Roo.dd.DDM = Roo.dd.DragDropMgr;
Roo.dd.DDM._addListeners();

}
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.dd.DD
 * A DragDrop implementation where the linked element follows the
 * mouse cursor during a drag.
 * @extends Roo.dd.DragDrop
 * @constructor
 * @param {String} id the id of the linked element
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD:
 *                    scroll
 */
Roo.dd.DD = function(id, A, B) {
    if (id) {
        this.init(id, A, B);
    }
};

Roo.extend(Roo.dd.DD, Roo.dd.DragDrop, {

    /**
     * When set to true, the utility automatically tries to scroll the browser
     * window wehn a drag and drop element is dragged near the viewport boundary.
     * Defaults to true.
     * @property scroll
     * @type boolean
     */
    scroll: true,

    /**
     * Sets the pointer offset to the distance between the linked element's top
     * left corner and the location the element was clicked
     * @method autoOffset
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     */
    autoOffset: function(C, D) {
        var  x = C - this.startPageX;
        var  y = D - this.startPageY;
        this.setDelta(x, y);
    },

    /**
     * Sets the pointer offset.  You can call this directly to force the
     * offset to be in a particular location (e.g., pass in 0,0 to set it
     * to the center of the object)
     * @method setDelta
     * @param {int} iDeltaX the distance from the left
     * @param {int} iDeltaY the distance from the top
     */
    setDelta: function(E, F) {
        this.deltaX = E;
        this.deltaY = F;
    },

    /**
     * Sets the drag element to the location of the mousedown or click event,
     * maintaining the cursor location relative to the location on the element
     * that was clicked.  Override this if you want to place the element in a
     * location other than where the cursor is.
     * @method setDragElPos
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    setDragElPos: function(G, H) {
        // the first time we do this, we are going to check to make sure
        // the element has css positioning

        var  el = this.getDragEl();
        this.alignElWithMouse(el, G, H);
    },

    /**
     * Sets the element to the location of the mousedown or click event,
     * maintaining the cursor location relative to the location on the element
     * that was clicked.  Override this if you want to place the element in a
     * location other than where the cursor is.
     * @method alignElWithMouse
     * @param {HTMLElement} el the element to move
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    alignElWithMouse: function(el, I, J) {
        var  K = this.getTargetCoord(I, J);
        var  L = el.dom ? el : Roo.fly(el);
        if (!this.deltaSetXY) {
            var  aCoord = [K.x, K.y];
            L.setXY(aCoord);
            var  newLeft = L.getLeft(true);
            var  newTop  = L.getTop(true);
            this.deltaSetXY = [ newLeft - K.x, newTop - K.y ];
        } else  {
            L.setLeftTop(K.x + this.deltaSetXY[0], K.y + this.deltaSetXY[1]);
        }


        this.cachePosition(K.x, K.y);
        this.autoScroll(K.x, K.y, el.offsetHeight, el.offsetWidth);
        return  K;
    },

    /**
     * Saves the most recent position so that we can reset the constraints and
     * tick marks on-demand.  We need to know this so that we can calculate the
     * number of pixels the element is offset from its original position.
     * @method cachePosition
     * @param iPageX the current x position (optional, this just makes it so we
     * don't have to look it up again)
     * @param iPageY the current y position (optional, this just makes it so we
     * don't have to look it up again)
     */
    cachePosition: function(M, N) {
        if (M) {
            this.lastPageX = M;
            this.lastPageY = N;
        } else  {
            var  aCoord = Roo.lib.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
     * Auto-scroll the window if the dragged object has been moved beyond the
     * visible window boundary.
     * @method autoScroll
     * @param {int} x the drag element's x position
     * @param {int} y the drag element's y position
     * @param {int} h the height of the drag element
     * @param {int} w the width of the drag element
     * @private
     */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            // The client height
            var  clientH = Roo.lib.Dom.getViewWidth();

            // The client width
            var  clientW = Roo.lib.Dom.getViewHeight();

            // The amt scrolled down
            var  st = this.DDM.getScrollTop();

            // The amt scrolled right
            var  sl = this.DDM.getScrollLeft();

            // Location of the bottom of the element
            var  bot = h + y;

            // Location of the right of the element
            var  right = w + x;

            // The distance from the cursor to the bottom of the visible area,
            // adjusted so that we don't scroll if the cursor is beyond the
            // element drag constraints
            var  toBot = (clientH + st - y - this.deltaY);

            // The distance from the cursor to the right of the visible area
            var  toRight = (clientW + sl - x - this.deltaX);


            // How close to the edge the cursor must be before we scroll
            // var thresh = (document.all) ? 100 : 40;
            var  thresh = 40;

            // How many pixels to scroll per autoscroll op.  This helps to reduce
            // clunky scrolling. IE is more sensitive about this ... it needs this
            // value to be higher.
            var  scrAmt = (document.all) ? 80 : 30;

            // Scroll down if we are near the bottom of the visible page and the
            // obj extends below the crease
            if ( bot > clientH && toBot < thresh ) {
                window.scrollTo(sl, st + scrAmt);
            }

            // Scroll up if the window is scrolled down and the top of the object
            // goes above the top border
            if ( y < st && st > 0 && y - st < thresh ) {
                window.scrollTo(sl, st - scrAmt);
            }

            // Scroll right if the obj is beyond the right border and the cursor is
            // near the border.
            if ( right > clientW && toRight < thresh ) {
                window.scrollTo(sl + scrAmt, st);
            }

            // Scroll left if the window has been scrolled to the right and the obj
            // extends past the left border
            if ( x < sl && sl > 0 && x - sl < thresh ) {
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /**
     * Finds the location the element should be placed if we want to move
     * it to where the mouse location less the click offset would place us.
     * @method getTargetCoord
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     * @return an object that contains the coordinates (Object.x and Object.y)
     * @private
     */
    getTargetCoord: function(O, P) {


        var  x = O - this.deltaX;
        var  y = P - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }


        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return  {x:x, y:y};
    },

    /*
     * Sets up config options specific to this class. Overrides
     * Roo.dd.DragDrop, but all versions of this method through the
     * inheritance chain are called
     */
    applyConfig: function() {
        Roo.dd.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
     * Event that fires prior to the onMouseDown event.  Overrides
     * Roo.dd.DragDrop.
     */
    b4MouseDown: function(e) {
        // this.resetConstraints();
        this.autoOffset(e.getPageX(),
                            e.getPageY());
    },

    /*
     * Event that fires prior to the onDrag event.  Overrides
     * Roo.dd.DragDrop.
     */
    b4Drag: function(e) {
        this.setDragElPos(e.getPageX(),
                            e.getPageY());
    },

    toString: function() {
        return  ("DD " + this.id);
    }

    //////////////////////////////////////////////////////////////////////////
    // Debugging ygDragDrop events that can be overridden
    //////////////////////////////////////////////////////////////////////////
    /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */

});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.dd.DDProxy
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @extends Roo.dd.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop:
 *                   resizeFrame, centerFrame, dragElId
 */
Roo.dd.DDProxy = function(id, A, B) {
    if (id) {
        this.init(id, A, B);
        this.initFrame();
    }
};

/**
 * The default drag frame div id
 * @property Roo.dd.DDProxy.dragElId
 * @type String
 * @static
 */
Roo.dd.DDProxy.dragElId = "ygddfdiv";

Roo.extend(Roo.dd.DDProxy, Roo.dd.DD, {

    /**
     * By default we resize the drag frame to be the same size as the element
     * we want to drag (this is to get the frame effect).  We can turn it off
     * if we want a different behavior.
     * @property resizeFrame
     * @type boolean
     */
    resizeFrame: true,

    /**
     * By default the frame is positioned exactly where the drag element is, so
     * we use the cursor offset provided by Roo.dd.DD.  Another option that works only if
     * you do not have constraints on the obj is to have the drag frame centered
     * around the cursor.  Set centerFrame to true for this effect.
     * @property centerFrame
     * @type boolean
     */
    centerFrame: false,

    /**
     * Creates the proxy element if it does not yet exist
     * @method createFrame
     */
    createFrame: function() {
        var  C = this;
        var  D = document.body;

        if (!D || !D.firstChild) {
            setTimeout( function() { C.createFrame(); }, 50 );
            return;
        }

        var  E = this.getDragEl();

        if (!E) {
            E    = document.createElement("div");
            E.id = this.dragElId;
            var  s  = E.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;

            // appendChild can blow up IE if invoked prior to the window load event
            // while rendering a table.  It is possible there are other scenarios
            // that would cause this to happen as well.
            D.insertBefore(E, D.firstChild);
        }
    },

    /**
     * Initialization for the drag frame element.  Must be called in the
     * constructor of all subclasses
     * @method initFrame
     */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        Roo.dd.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || Roo.dd.DDProxy.dragElId);
    },

    /**
     * Resizes the drag frame to the dimensions of the clicked object, positions
     * it over the object, and finally displays it
     * @method showFrame
     * @param {int} iPageX X click position
     * @param {int} iPageY Y click position
     * @private
     */
    showFrame: function(F, G) {
        var  el = this.getEl();
        var  H = this.getDragEl();
        var  s = H.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2),
                           Math.round(parseInt(s.height, 10)/2) );
        }


        this.setDragElPos(F, G);

        Roo.fly(H).show();
    },

    /**
     * The proxy is automatically resized to the dimensions of the linked
     * element when a drag is initiated, unless resizeFrame is set to false
     * @method _resizeProxy
     * @private
     */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var  el = this.getEl();
            Roo.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
        }
    },

    // overrides Roo.dd.DragDrop
    b4MouseDown: function(e) {
        var  x = e.getPageX();
        var  y = e.getPageY();
        this.autoOffset(x, y);
        this.setDragElPos(x, y);
    },

    // overrides Roo.dd.DragDrop
    b4StartDrag: function(x, y) {
        // show the drag frame
        this.showFrame(x, y);
    },

    // overrides Roo.dd.DragDrop
    b4EndDrag: function(e) {
        Roo.fly(this.getDragEl()).hide();
    },

    // overrides Roo.dd.DragDrop
    // By default we try to move the element to the last location of the frame.
    // This is so that the default behavior mirrors that of Roo.dd.DD.
    endDrag: function(e) {

        var  I = this.getEl();
        var  J = this.getDragEl();

        // Show the drag frame briefly so we can get its position
        J.style.visibility = "";

        this.beforeMove();
        // Hide the linked element before the move to get around a Safari
        // rendering bug.
        I.style.visibility = "hidden";
        Roo.dd.DDM.moveToEl(I, J);
        J.style.visibility = "hidden";
        I.style.visibility = "";

        this.afterDrag();
    },

    beforeMove : function(){

    },

    afterDrag : function(){

    },

    toString: function() {
        return  ("DDProxy " + this.id);
    }

});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 /**
 * @class Roo.dd.DDTarget
 * A DragDrop implementation that does not move, but can be a drop
 * target.  You would get the same result by simply omitting implementation
 * for the event callbacks, but this way we reduce the processing cost of the
 * event listener and the callbacks.
 * @extends Roo.dd.DragDrop
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in
 *                 DragDrop:
 *                    none
 */
Roo.dd.DDTarget = function(id, A, B) {
    if (id) {
        this.initTarget(id, A, B);
    }
};

// Roo.dd.DDTarget.prototype = new Roo.dd.DragDrop();
Roo.extend(Roo.dd.DDTarget, Roo.dd.DragDrop, {
    toString: function() {
        return  ("DDTarget " + this.id);
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.dd.ScrollManager
 * Provides automatic scrolling of overflow regions in the page during drag operations.<br><br>
 * <b>Note: This class uses "Point Mode" and is untested in "Intersect Mode".</b>
 * @singleton
 */
Roo.dd.ScrollManager = function(){
    var  A = Roo.dd.DragDropMgr;
    var  B = {};
    var  C = null;
    var  D = {};
    
    var  E = function(e){
        C = null;
        H();
    };
    
    var  F = function(){
        if(A.dragCurrent){
             A.refreshCache(A.dragCurrent.groups);
        }
    };
    
    var  G = function(){
        if(A.dragCurrent){
            var  dds = Roo.dd.ScrollManager;
            if(!dds.animate){
                if(D.el.scroll(D.dir, dds.increment)){
                    F();
                }
            }else {
                D.el.scroll(D.dir, dds.increment, true, dds.animDuration, F);
            }
        }
    };
    
    var  H = function(){
        if(D.id){
            clearInterval(D.id);
        }

        D.id = 0;
        D.el = null;
        D.dir = "";
    };
    
    var  I = function(el, K){
        H();
        D.el = el;
        D.dir = K;
        D.id = setInterval(G, Roo.dd.ScrollManager.frequency);
    };
    
    var  J = function(e, K){
        if(K || !A.dragCurrent){ return; }
        var  L = Roo.dd.ScrollManager;
        if(!C || C != A.dragCurrent){
            C = A.dragCurrent;
            // refresh regions on drag start
            L.refreshCache();
        }
        
        var  xy = Roo.lib.Event.getXY(e);
        var  pt = new  Roo.lib.Point(xy[0], xy[1]);
        for(var  id  in  B){
            var  el = B[id], r = el._region;
            if(r && r.contains(pt) && el.isScrollable()){
                if(r.bottom - pt.y <= L.thresh){
                    if(D.el != el){
                        I(el, "down");
                    }
                    return;
                }else  if(r.right - pt.x <= L.thresh){
                    if(D.el != el){
                        I(el, "left");
                    }
                    return;
                }else  if(pt.y - r.top <= L.thresh){
                    if(D.el != el){
                        I(el, "up");
                    }
                    return;
                }else  if(pt.x - r.left <= L.thresh){
                    if(D.el != el){
                        I(el, "right");
                    }
                    return;
                }
            }
        }

        H();
    };
    
    A.fireEvents = A.fireEvents.createSequence(J, A);
    A.stopDrag = A.stopDrag.createSequence(E, A);
    
    return  {
        /**
         * Registers new overflow element(s) to auto scroll
         * @param {String/HTMLElement/Element/Array} el The id of or the element to be scrolled or an array of either
         */
        register : function(el){
            if(el  instanceof  Array){
                for(var  i = 0, len = el.length; i < len; i++) {
                	this.register(el[i]);
                }
            }else {
                el = Roo.get(el);
                B[el.id] = el;
            }
        },
        
        /**
         * Unregisters overflow element(s) so they are no longer scrolled
         * @param {String/HTMLElement/Element/Array} el The id of or the element to be removed or an array of either
         */
        unregister : function(el){
            if(el  instanceof  Array){
                for(var  i = 0, len = el.length; i < len; i++) {
                	this.unregister(el[i]);
                }
            }else {
                el = Roo.get(el);
                delete  B[el.id];
            }
        },
        
        /**
         * The number of pixels from the edge of a container the pointer needs to be to 
         * trigger scrolling (defaults to 25)
         * @type Number
         */
        thresh : 25,
        
        /**
         * The number of pixels to scroll in each scroll increment (defaults to 50)
         * @type Number
         */
        increment : 100,
        
        /**
         * The frequency of scrolls in milliseconds (defaults to 500)
         * @type Number
         */
        frequency : 500,
        
        /**
         * True to animate the scroll (defaults to true)
         * @type Boolean
         */
        animate: true,
        
        /**
         * The animation duration in seconds - 
         * MUST BE less than Roo.dd.ScrollManager.frequency! (defaults to .4)
         * @type Number
         */
        animDuration: .4,
        
        /**
         * Manually trigger a cache refresh.
         */
        refreshCache : function(){
            for(var  id  in  B){
                if(typeof  B[id] == 'object'){ // for people extending the object prototype
                    B[id]._region = B[id].getRegion();
                }
            }
        }
    };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.dd.Registry
 * Provides easy access to all drag drop components that are registered on a page.  Items can be retrieved either
 * directly by DOM node id, or by passing in the drag drop event that occurred and looking up the event target.
 * @singleton
 */
Roo.dd.Registry = function(){
    var  A = {}; 
    var  B = {}; 
    var  C = 0;

    var  D = function(el, E){
        if(typeof  el == "string"){
            return  el;
        }
        var  id = el.id;
        if(!id && E !== false){
            id = "roodd-" + (++C);
            el.id = id;
        }
        return  id;
    };
    
    return  {
    /**
     * Register a drag drop element
     * @param {String|HTMLElement} element The id or DOM node to register
     * @param {Object} data (optional) A custom data object that will be passed between the elements that are involved
     * in drag drop operations.  You can populate this object with any arbitrary properties that your own code
     * knows how to interpret, plus there are some specific properties known to the Registry that should be
     * populated in the data object (if applicable):
     * <pre>
Value      Description<br />
---------  ------------------------------------------<br />
handles    Array of DOM nodes that trigger dragging<br />
           for the element being registered<br />
isHandle   True if the element passed in triggers<br />
           dragging itself, else false
</pre>
     */
        register : function(el, G){
            G = G || {};
            if(typeof  el == "string"){
                el = document.getElementById(el);
            }

            G.ddel = el;
            A[D(el)] = G;
            if(G.isHandle !== false){
                B[G.ddel.id] = G;
            }
            if(G.handles){
                var  hs = G.handles;
                for(var  i = 0, len = hs.length; i < len; i++){
                	B[D(hs[i])] = G;
                }
            }
        },

    /**
     * Unregister a drag drop element
     * @param {String|HTMLElement}  element The id or DOM node to unregister
     */
        unregister : function(el){
            var  id = D(el, false);
            var  H = A[id];
            if(H){
                delete  A[id];
                if(H.handles){
                    var  hs = H.handles;
                    for(var  i = 0, len = hs.length; i < len; i++){
                    	delete  B[D(hs[i], false)];
                    }
                }
            }
        },

    /**
     * Returns the handle registered for a DOM Node by id
     * @param {String|HTMLElement} id The DOM node or id to look up
     * @return {Object} handle The custom handle data
     */
        getHandle : function(id){
            if(typeof  id != "string"){ // must be element?
                id = id.id;
            }
            return  B[id];
        },

    /**
     * Returns the handle that is registered for the DOM node that is the target of the event
     * @param {Event} e The event
     * @return {Object} handle The custom handle data
     */
        getHandleFromEvent : function(e){
            var  t = Roo.lib.Event.getTarget(e);
            return  t ? B[t.id] : null;
        },

    /**
     * Returns a custom data object that is registered for a DOM node by id
     * @param {String|HTMLElement} id The DOM node or id to look up
     * @return {Object} data The custom data
     */
        getTarget : function(id){
            if(typeof  id != "string"){ // must be element?
                id = id.id;
            }
            return  A[id];
        },

    /**
     * Returns a custom data object that is registered for the DOM node that is the target of the event
     * @param {Event} e The event
     * @return {Object} data The custom data
     */
        getTargetFromEvent : function(e){
            var  t = Roo.lib.Event.getTarget(e);
            return  t ? A[t.id] || B[t.id] : null;
        }
    };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.dd.StatusProxy
 * A specialized drag proxy that supports a drop status icon, {@link Roo.Layer} styles and auto-repair.  This is the
 * default drag proxy used by all Roo.dd components.
 * @constructor
 * @param {Object} config
 */
Roo.dd.StatusProxy = function(A){
    Roo.apply(this, A);
    this.id = this.id || Roo.id();
    this.el = new  Roo.Layer({
        dh: {
            id: this.id, tag: "div", cls: "x-dd-drag-proxy "+this.dropNotAllowed, children: [
                {tag: "div", cls: "x-dd-drop-icon"},
                {tag: "div", cls: "x-dd-drag-ghost"}
            ]
        }, 
        shadow: !A || A.shadow !== false
    });
    this.ghost = Roo.get(this.el.dom.childNodes[1]);
    this.dropStatus = this.dropNotAllowed;
};

Roo.dd.StatusProxy.prototype = {
    /**
     * @cfg {String} dropAllowed
     * The CSS class to apply to the status element when drop is allowed (defaults to "x-dd-drop-ok").
     */
    dropAllowed : "x-dd-drop-ok",
    /**
     * @cfg {String} dropNotAllowed
     * The CSS class to apply to the status element when drop is not allowed (defaults to "x-dd-drop-nodrop").
     */
    dropNotAllowed : "x-dd-drop-nodrop",

    /**
     * Updates the proxy's visual element to indicate the status of whether or not drop is allowed
     * over the current target element.
     * @param {String} cssClass The css class for the new drop status indicator image
     */
    setStatus : function(B){
        B = B || this.dropNotAllowed;
        if(this.dropStatus != B){
            this.el.replaceClass(this.dropStatus, B);
            this.dropStatus = B;
        }
    },

    /**
     * Resets the status indicator to the default dropNotAllowed value
     * @param {Boolean} clearGhost True to also remove all content from the ghost, false to preserve it
     */
    reset : function(C){
        this.el.dom.className = "x-dd-drag-proxy " + this.dropNotAllowed;
        this.dropStatus = this.dropNotAllowed;
        if(C){
            this.ghost.update("");
        }
    },

    /**
     * Updates the contents of the ghost element
     * @param {String} html The html that will replace the current innerHTML of the ghost element
     */
    update : function(D){
        if(typeof  D == "string"){
            this.ghost.update(D);
        }else {
            this.ghost.update("");
            D.style.margin = "0";
            this.ghost.dom.appendChild(D);
        }
        // ensure float = none set?? cant remember why though.
        var  el = this.ghost.dom.firstChild;
		if(el){
			Roo.fly(el).setStyle('float', 'none');
		}
    },
    
    /**
     * Returns the underlying proxy {@link Roo.Layer}
     * @return {Roo.Layer} el
    */
    getEl : function(){
        return  this.el;
    },

    /**
     * Returns the ghost element
     * @return {Roo.Element} el
     */
    getGhost : function(){
        return  this.ghost;
    },

    /**
     * Hides the proxy
     * @param {Boolean} clear True to reset the status and clear the ghost contents, false to preserve them
     */
    hide : function(E){
        this.el.hide();
        if(E){
            this.reset(true);
        }
    },

    /**
     * Stops the repair animation if it's currently running
     */
    stop : function(){
        if(this.anim && this.anim.isAnimated && this.anim.isAnimated()){
            this.anim.stop();
        }
    },

    /**
     * Displays this proxy
     */
    show : function(){
        this.el.show();
    },

    /**
     * Force the Layer to sync its shadow and shim positions to the element
     */
    sync : function(){
        this.el.sync();
    },

    /**
     * Causes the proxy to return to its position of origin via an animation.  Should be called after an
     * invalid drop operation by the item being dragged.
     * @param {Array} xy The XY position of the element ([x, y])
     * @param {Function} callback The function to call after the repair is complete
     * @param {Object} scope The scope in which to execute the callback
     */
    repair : function(xy, F, G){
        this.callback = F;
        this.scope = G;
        if(xy && this.animRepair !== false){
            this.el.addClass("x-dd-drag-repair");
            this.el.hideUnders(true);
            this.anim = this.el.shift({
                duration: this.repairDuration || .5,
                easing: 'easeOut',
                xy: xy,
                stopFx: true,
                callback: this.afterRepair,
                scope: this
            });
        }else {
            this.afterRepair();
        }
    },

    // private
    afterRepair : function(){
        this.hide(true);
        if(typeof  this.callback == "function"){
            this.callback.call(this.scope || this);
        }

        this.callback = null;
        this.scope = null;
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.dd.DragSource
 * @extends Roo.dd.DDProxy
 * A simple class that provides the basic implementation needed to make any element draggable.
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.dd.DragSource = function(el, A){
    this.el = Roo.get(el);
    this.dragData = {};
    
    Roo.apply(this, A);
    
    if(!this.proxy){
        this.proxy = new  Roo.dd.StatusProxy();
    }


    Roo.dd.DragSource.superclass.constructor.call(this, this.el.dom, this.ddGroup || this.group,
          {dragElId : this.proxy.id, resizeFrame: false, isTarget: false, scroll: this.scroll === true});
    
    this.dragging = false;
};

Roo.extend(Roo.dd.DragSource, Roo.dd.DDProxy, {
    /**
     * @cfg {String} dropAllowed
     * The CSS class returned to the drag source when drop is allowed (defaults to "x-dd-drop-ok").
     */
    dropAllowed : "x-dd-drop-ok",
    /**
     * @cfg {String} dropNotAllowed
     * The CSS class returned to the drag source when drop is not allowed (defaults to "x-dd-drop-nodrop").
     */
    dropNotAllowed : "x-dd-drop-nodrop",

    /**
     * Returns the data object associated with this drag source
     * @return {Object} data An object containing arbitrary data
     */
    getDragData : function(e){
        return  this.dragData;
    },

    // private
    onDragEnter : function(e, id){
        var  B = Roo.dd.DragDropMgr.getDDById(id);
        this.cachedTarget = B;
        if(this.beforeDragEnter(B, e, id) !== false){
            if(B.isNotifyTarget){
                var  status = B.notifyEnter(this, e, this.dragData);
                this.proxy.setStatus(status);
            }else {
                this.proxy.setStatus(this.dropAllowed);
            }
            
            if(this.afterDragEnter){
                /**
                 * An empty function by default, but provided so that you can perform a custom action
                 * when the dragged item enters the drop target by providing an implementation.
                 * @param {Roo.dd.DragDrop} target The drop target
                 * @param {Event} e The event object
                 * @param {String} id The id of the dragged element
                 * @method afterDragEnter
                 */
                this.afterDragEnter(B, e, id);
            }
        }
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the dragged item enters the drop target and optionally cancel the onDragEnter.
     * @param {Roo.dd.DragDrop} target The drop target
     * @param {Event} e The event object
     * @param {String} id The id of the dragged element
     * @return {Boolean} isValid True if the drag event is valid, else false to cancel
     */
    beforeDragEnter : function(C, e, id){
        return  true;
    },

    // private
    alignElWithMouse: function() {
        Roo.dd.DragSource.superclass.alignElWithMouse.apply(this, arguments);
        this.proxy.sync();
    },

    // private
    onDragOver : function(e, id){
        var  D = this.cachedTarget || Roo.dd.DragDropMgr.getDDById(id);
        if(this.beforeDragOver(D, e, id) !== false){
            if(D.isNotifyTarget){
                var  status = D.notifyOver(this, e, this.dragData);
                this.proxy.setStatus(status);
            }

            if(this.afterDragOver){
                /**
                 * An empty function by default, but provided so that you can perform a custom action
                 * while the dragged item is over the drop target by providing an implementation.
                 * @param {Roo.dd.DragDrop} target The drop target
                 * @param {Event} e The event object
                 * @param {String} id The id of the dragged element
                 * @method afterDragOver
                 */
                this.afterDragOver(D, e, id);
            }
        }
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * while the dragged item is over the drop target and optionally cancel the onDragOver.
     * @param {Roo.dd.DragDrop} target The drop target
     * @param {Event} e The event object
     * @param {String} id The id of the dragged element
     * @return {Boolean} isValid True if the drag event is valid, else false to cancel
     */
    beforeDragOver : function(E, e, id){
        return  true;
    },

    // private
    onDragOut : function(e, id){
        var  F = this.cachedTarget || Roo.dd.DragDropMgr.getDDById(id);
        if(this.beforeDragOut(F, e, id) !== false){
            if(F.isNotifyTarget){
                F.notifyOut(this, e, this.dragData);
            }

            this.proxy.reset();
            if(this.afterDragOut){
                /**
                 * An empty function by default, but provided so that you can perform a custom action
                 * after the dragged item is dragged out of the target without dropping.
                 * @param {Roo.dd.DragDrop} target The drop target
                 * @param {Event} e The event object
                 * @param {String} id The id of the dragged element
                 * @method afterDragOut
                 */
                this.afterDragOut(F, e, id);
            }
        }

        this.cachedTarget = null;
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action before the dragged
     * item is dragged out of the target without dropping, and optionally cancel the onDragOut.
     * @param {Roo.dd.DragDrop} target The drop target
     * @param {Event} e The event object
     * @param {String} id The id of the dragged element
     * @return {Boolean} isValid True if the drag event is valid, else false to cancel
     */
    beforeDragOut : function(G, e, id){
        return  true;
    },
    
    // private
    onDragDrop : function(e, id){
        var  H = this.cachedTarget || Roo.dd.DragDropMgr.getDDById(id);
        if(this.beforeDragDrop(H, e, id) !== false){
            if(H.isNotifyTarget){
                if(H.notifyDrop(this, e, this.dragData)){ // valid drop?
                    this.onValidDrop(H, e, id);
                }else {
                    this.onInvalidDrop(H, e, id);
                }
            }else {
                this.onValidDrop(H, e, id);
            }
            
            if(this.afterDragDrop){
                /**
                 * An empty function by default, but provided so that you can perform a custom action
                 * after a valid drag drop has occurred by providing an implementation.
                 * @param {Roo.dd.DragDrop} target The drop target
                 * @param {Event} e The event object
                 * @param {String} id The id of the dropped element
                 * @method afterDragDrop
                 */
                this.afterDragDrop(H, e, id);
            }
        }
        delete  this.cachedTarget;
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action before the dragged
     * item is dropped onto the target and optionally cancel the onDragDrop.
     * @param {Roo.dd.DragDrop} target The drop target
     * @param {Event} e The event object
     * @param {String} id The id of the dragged element
     * @return {Boolean} isValid True if the drag drop event is valid, else false to cancel
     */
    beforeDragDrop : function(I, e, id){
        return  true;
    },

    // private
    onValidDrop : function(J, e, id){
        this.hideProxy();
        if(this.afterValidDrop){
            /**
             * An empty function by default, but provided so that you can perform a custom action
             * after a valid drop has occurred by providing an implementation.
             * @param {Object} target The target DD 
             * @param {Event} e The event object
             * @param {String} id The id of the dropped element
             * @method afterInvalidDrop
             */
            this.afterValidDrop(J, e, id);
        }
    },

    // private
    getRepairXY : function(e, K){
        return  this.el.getXY();  
    },

    // private
    onInvalidDrop : function(L, e, id){
        this.beforeInvalidDrop(L, e, id);
        if(this.cachedTarget){
            if(this.cachedTarget.isNotifyTarget){
                this.cachedTarget.notifyOut(this, e, this.dragData);
            }

            this.cacheTarget = null;
        }

        this.proxy.repair(this.getRepairXY(e, this.dragData), this.afterRepair, this);

        if(this.afterInvalidDrop){
            /**
             * An empty function by default, but provided so that you can perform a custom action
             * after an invalid drop has occurred by providing an implementation.
             * @param {Event} e The event object
             * @param {String} id The id of the dropped element
             * @method afterInvalidDrop
             */
            this.afterInvalidDrop(e, id);
        }
    },

    // private
    afterRepair : function(){
        if(Roo.enableFx){
            this.el.highlight(this.hlColor || "c3daf9");
        }

        this.dragging = false;
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action after an invalid
     * drop has occurred.
     * @param {Roo.dd.DragDrop} target The drop target
     * @param {Event} e The event object
     * @param {String} id The id of the dragged element
     * @return {Boolean} isValid True if the invalid drop should proceed, else false to cancel
     */
    beforeInvalidDrop : function(M, e, id){
        return  true;
    },

    // private
    handleMouseDown : function(e){
        if(this.dragging) {
            return;
        }
        var  N = this.getDragData(e);
        if(N && this.onBeforeDrag(N, e) !== false){
            this.dragData = N;
            this.proxy.stop();
            Roo.dd.DragSource.superclass.handleMouseDown.apply(this, arguments);
        } 
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action before the initial
     * drag event begins and optionally cancel it.
     * @param {Object} data An object containing arbitrary data to be shared with drop targets
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the drag event is valid, else false to cancel
     */
    onBeforeDrag : function(O, e){
        return  true;
    },

    /**
     * An empty function by default, but provided so that you can perform a custom action once the initial
     * drag event has begun.  The drag cannot be canceled from this function.
     * @param {Number} x The x position of the click on the dragged object
     * @param {Number} y The y position of the click on the dragged object
     */
    onStartDrag : Roo.emptyFn,

    // private - YUI override
    startDrag : function(x, y){
        this.proxy.reset();
        this.dragging = true;
        this.proxy.update("");
        this.onInitDrag(x, y);
        this.proxy.show();
    },

    // private
    onInitDrag : function(x, y){
        var  P = this.el.dom.cloneNode(true);
        P.id = Roo.id(); // prevent duplicate ids
        this.proxy.update(P);
        this.onStartDrag(x, y);
        return  true;
    },

    /**
     * Returns the drag source's underlying {@link Roo.dd.StatusProxy}
     * @return {Roo.dd.StatusProxy} proxy The StatusProxy
     */
    getProxy : function(){
        return  this.proxy;  
    },

    /**
     * Hides the drag source's {@link Roo.dd.StatusProxy}
     */
    hideProxy : function(){
        this.proxy.hide();  
        this.proxy.reset(true);
        this.dragging = false;
    },

    // private
    triggerCacheRefresh : function(){
        Roo.dd.DDM.refreshCache(this.groups);
    },

    // private - override to prevent hiding
    b4EndDrag: function(e) {
    },

    // private - override to prevent moving
    endDrag : function(e){
        this.onEndDrag(this.dragData, e);
    },

    // private
    onEndDrag : function(Q, e){
    },
    
    // private - pin to cursor
    autoOffset : function(x, y) {
        this.setDelta(-12, -20);
    }    
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.dd.DropTarget
 * @extends Roo.dd.DDTarget
 * A simple class that provides the basic implementation needed to make any element a drop target that can have
 * draggable items dropped onto it.  The drop has no effect until an implementation of notifyDrop is provided.
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.dd.DropTarget = function(el, A){
    this.el = Roo.get(el);
    
    Roo.apply(this, A);
    
    if(this.containerScroll){
        Roo.dd.ScrollManager.register(this.el);
    }

    
    Roo.dd.DropTarget.superclass.constructor.call(this, this.el.dom, this.ddGroup || this.group, 
          {isTarget: true});

};

Roo.extend(Roo.dd.DropTarget, Roo.dd.DDTarget, {
    /**
     * @cfg {String} overClass
     * The CSS class applied to the drop target element while the drag source is over it (defaults to "").
     */
    /**
     * @cfg {String} dropAllowed
     * The CSS class returned to the drag source when drop is allowed (defaults to "x-dd-drop-ok").
     */
    dropAllowed : "x-dd-drop-ok",
    /**
     * @cfg {String} dropNotAllowed
     * The CSS class returned to the drag source when drop is not allowed (defaults to "x-dd-drop-nodrop").
     */
    dropNotAllowed : "x-dd-drop-nodrop",

    // private
    isTarget : true,

    // private
    isNotifyTarget : true,

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop target that the source is now over the
     * target.  This default implementation adds the CSS class specified by overClass (if any) to the drop element
     * and returns the dropAllowed config value.  This method should be overridden if drop validation is required.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop target
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    notifyEnter : function(dd, e, B){
        if(this.overClass){
            this.el.addClass(this.overClass);
        }
        return  this.dropAllowed;
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls continuously while it is being dragged over the target.
     * This method will be called on every mouse movement while the drag source is over the drop target.
     * This default implementation simply returns the dropAllowed config value.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop target
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    notifyOver : function(dd, e, C){
        return  this.dropAllowed;
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop target that the source has been dragged
     * out of the target without dropping.  This default implementation simply removes the CSS class specified by
     * overClass (if any) from the drop element.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop target
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     */
    notifyOut : function(dd, e, D){
        if(this.overClass){
            this.el.removeClass(this.overClass);
        }
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop target that the dragged item has
     * been dropped on it.  This method has no default implementation and returns false, so you must provide an
     * implementation that does something to process the drop event and returns true so that the drag source's
     * repair action does not run.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop target
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {Boolean} True if the drop was valid, else false
     */
    notifyDrop : function(dd, e, E){
        return  false;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.dd.DragZone
 * @extends Roo.dd.DragSource
 * This class provides a container DD instance that proxies for multiple child node sources.<br />
 * By default, this class requires that draggable child nodes are registered with {@link Roo.dd.Registry}.
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.dd.DragZone = function(el, A){
    Roo.dd.DragZone.superclass.constructor.call(this, el, A);
    if(this.containerScroll){
        Roo.dd.ScrollManager.register(this.el);
    }
};

Roo.extend(Roo.dd.DragZone, Roo.dd.DragSource, {
    /**
     * @cfg {Boolean} containerScroll True to register this container with the Scrollmanager
     * for auto scrolling during drag operations.
     */
    /**
     * @cfg {String} hlColor The color to use when visually highlighting the drag source in the afterRepair
     * method after a failed drop (defaults to "c3daf9" - light blue)
     */

    /**
     * Called when a mousedown occurs in this container. Looks in {@link Roo.dd.Registry}
     * for a valid target to drag based on the mouse down. Override this method
     * to provide your own lookup logic (e.g. finding a child by class name). Make sure your returned
     * object has a "ddel" attribute (with an HTML Element) for other functions to work.
     * @param {EventObject} e The mouse down event
     * @return {Object} The dragData
     */
    getDragData : function(e){
        return  Roo.dd.Registry.getHandleFromEvent(e);
    },
    
    /**
     * Called once drag threshold has been reached to initialize the proxy element. By default, it clones the
     * this.dragData.ddel
     * @param {Number} x The x position of the click on the dragged object
     * @param {Number} y The y position of the click on the dragged object
     * @return {Boolean} true to continue the drag, false to cancel
     */
    onInitDrag : function(x, y){
        this.proxy.update(this.dragData.ddel.cloneNode(true));
        this.onStartDrag(x, y);
        return  true;
    },
    
    /**
     * Called after a repair of an invalid drop. By default, highlights this.dragData.ddel 
     */
    afterRepair : function(){
        if(Roo.enableFx){
            Roo.Element.fly(this.dragData.ddel).highlight(this.hlColor || "c3daf9");
        }

        this.dragging = false;
    },

    /**
     * Called before a repair of an invalid drop to get the XY to animate to. By default returns
     * the XY of this.dragData.ddel
     * @param {EventObject} e The mouse up event
     * @return {Array} The xy location (e.g. [100, 200])
     */
    getRepairXY : function(e){
        return  Roo.Element.fly(this.dragData.ddel).getXY();  
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.dd.DropZone
 * @extends Roo.dd.DropTarget
 * This class provides a container DD instance that proxies for multiple child node targets.<br />
 * By default, this class requires that child nodes accepting drop are registered with {@link Roo.dd.Registry}.
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.dd.DropZone = function(el, A){
    Roo.dd.DropZone.superclass.constructor.call(this, el, A);
};

Roo.extend(Roo.dd.DropZone, Roo.dd.DropTarget, {
    /**
     * Returns a custom data object associated with the DOM node that is the target of the event.  By default
     * this looks up the event target in the {@link Roo.dd.Registry}, although you can override this method to
     * provide your own custom lookup.
     * @param {Event} e The event
     * @return {Object} data The custom data
     */
    getTargetFromEvent : function(e){
        return  Roo.dd.Registry.getTargetFromEvent(e);
    },

    /**
     * Called internally when the DropZone determines that a {@link Roo.dd.DragSource} has entered a drop node
     * that it has registered.  This method has no default implementation and should be overridden to provide
     * node-specific processing if necessary.
     * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from 
     * {@link #getTargetFromEvent} for this node)
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     */
    onNodeEnter : function(n, dd, e, B){
        
    },

    /**
     * Called internally while the DropZone determines that a {@link Roo.dd.DragSource} is over a drop node
     * that it has registered.  The default implementation returns this.dropNotAllowed, so it should be
     * overridden to provide the proper feedback.
     * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
     * {@link #getTargetFromEvent} for this node)
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    onNodeOver : function(n, dd, e, C){
        return  this.dropAllowed;
    },

    /**
     * Called internally when the DropZone determines that a {@link Roo.dd.DragSource} has been dragged out of
     * the drop node without dropping.  This method has no default implementation and should be overridden to provide
     * node-specific processing if necessary.
     * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
     * {@link #getTargetFromEvent} for this node)
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     */
    onNodeOut : function(n, dd, e, D){
        
    },

    /**
     * Called internally when the DropZone determines that a {@link Roo.dd.DragSource} has been dropped onto
     * the drop node.  The default implementation returns false, so it should be overridden to provide the
     * appropriate processing of the drop event and return true so that the drag source's repair action does not run.
     * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
     * {@link #getTargetFromEvent} for this node)
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {Boolean} True if the drop was valid, else false
     */
    onNodeDrop : function(n, dd, e, E){
        return  false;
    },

    /**
     * Called internally while the DropZone determines that a {@link Roo.dd.DragSource} is being dragged over it,
     * but not over any of its registered drop nodes.  The default implementation returns this.dropNotAllowed, so
     * it should be overridden to provide the proper feedback if necessary.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    onContainerOver : function(dd, e, F){
        return  this.dropNotAllowed;
    },

    /**
     * Called internally when the DropZone determines that a {@link Roo.dd.DragSource} has been dropped on it,
     * but not on any of its registered drop nodes.  The default implementation returns false, so it should be
     * overridden to provide the appropriate processing of the drop event if you need the drop zone itself to
     * be able to accept drops.  It should return true when valid so that the drag source's repair action does not run.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {Boolean} True if the drop was valid, else false
     */
    onContainerDrop : function(dd, e, G){
        return  false;
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop zone that the source is now over
     * the zone.  The default implementation returns this.dropNotAllowed and expects that only registered drop
     * nodes can process drag drop operations, so if you need the drop zone itself to be able to process drops
     * you should override this method and provide a custom implementation.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    notifyEnter : function(dd, e, H){
        return  this.dropNotAllowed;
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls continuously while it is being dragged over the drop zone.
     * This method will be called on every mouse movement while the drag source is over the drop zone.
     * It will call {@link #onNodeOver} while the drag source is over a registered node, and will also automatically
     * delegate to the appropriate node-specific methods as necessary when the drag source enters and exits
     * registered nodes ({@link #onNodeEnter}, {@link #onNodeOut}). If the drag source is not currently over a
     * registered node, it will call {@link #onContainerOver}.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {String} status The CSS class that communicates the drop status back to the source so that the
     * underlying {@link Roo.dd.StatusProxy} can be updated
     */
    notifyOver : function(dd, e, I){
        var  n = this.getTargetFromEvent(e);
        if(!n){ // not over valid drop target
            if(this.lastOverNode){
                this.onNodeOut(this.lastOverNode, dd, e, I);
                this.lastOverNode = null;
            }
            return  this.onContainerOver(dd, e, I);
        }
        if(this.lastOverNode != n){
            if(this.lastOverNode){
                this.onNodeOut(this.lastOverNode, dd, e, I);
            }

            this.onNodeEnter(n, dd, e, I);
            this.lastOverNode = n;
        }
        return  this.onNodeOver(n, dd, e, I);
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop zone that the source has been dragged
     * out of the zone without dropping.  If the drag source is currently over a registered node, the notification
     * will be delegated to {@link #onNodeOut} for node-specific handling, otherwise it will be ignored.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop target
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag zone
     */
    notifyOut : function(dd, e, J){
        if(this.lastOverNode){
            this.onNodeOut(this.lastOverNode, dd, e, J);
            this.lastOverNode = null;
        }
    },

    /**
     * The function a {@link Roo.dd.DragSource} calls once to notify this drop zone that the dragged item has
     * been dropped on it.  The drag zone will look up the target node based on the event passed in, and if there
     * is a node registered for that event, it will delegate to {@link #onNodeDrop} for node-specific handling,
     * otherwise it will call {@link #onContainerDrop}.
     * @param {Roo.dd.DragSource} source The drag source that was dragged over this drop zone
     * @param {Event} e The event
     * @param {Object} data An object containing arbitrary data supplied by the drag source
     * @return {Boolean} True if the drop was valid, else false
     */
    notifyDrop : function(dd, e, K){
        if(this.lastOverNode){
            this.onNodeOut(this.lastOverNode, dd, e, K);
            this.lastOverNode = null;
        }
        var  n = this.getTargetFromEvent(e);
        return  n ?
            this.onNodeDrop(n, dd, e, K) :
            this.onContainerDrop(dd, e, K);
    },

    // private
    triggerCacheRefresh : function(){
        Roo.dd.DDM.refreshCache(this.groups);
    }  
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.data.SortTypes
 * @singleton
 * Defines the default sorting (casting?) comparison functions used when sorting data.
 */
Roo.data.SortTypes = {
    /**
     * Default sort that does nothing
     * @param {Mixed} s The value being converted
     * @return {Mixed} The comparison value
     */
    none : function(s){
        return  s;
    },
    
    /**
     * The regular expression used to strip tags
     * @type {RegExp}
     * @property
     */
    stripTagsRE : /<\/?[^>]+>/gi,
    
    /**
     * Strips all HTML tags to sort on text only
     * @param {Mixed} s The value being converted
     * @return {String} The comparison value
     */
    asText : function(s){
        return  String(s).replace(this.stripTagsRE, "");
    },
    
    /**
     * Strips all HTML tags to sort on text only - Case insensitive
     * @param {Mixed} s The value being converted
     * @return {String} The comparison value
     */
    asUCText : function(s){
        return  String(s).toUpperCase().replace(this.stripTagsRE, "");
    },
    
    /**
     * Case insensitive string
     * @param {Mixed} s The value being converted
     * @return {String} The comparison value
     */
    asUCString : function(s) {
    	return  String(s).toUpperCase();
    },
    
    /**
     * Date sorting
     * @param {Mixed} s The value being converted
     * @return {Number} The comparison value
     */
    asDate : function(s) {
        if(!s){
            return  0;
        }
        if(s  instanceof  Date){
            return  s.getTime();
        }
    	return  Date.parse(String(s));
    },
    
    /**
     * Float sorting
     * @param {Mixed} s The value being converted
     * @return {Float} The comparison value
     */
    asFloat : function(s) {
    	var  A = parseFloat(String(s).replace(/,/g, ""));
        if(isNaN(A)) A = 0;
    	return  A;
    },
    
    /**
     * Integer sorting
     * @param {Mixed} s The value being converted
     * @return {Number} The comparison value
     */
    asInt : function(s) {
        var  B = parseInt(String(s).replace(/,/g, ""));
        if(isNaN(B)) B = 0;
    	return  B;
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
* @class Roo.data.Record
 * Instances of this class encapsulate both record <em>definition</em> information, and record
 * <em>value</em> information for use in {@link Roo.data.Store} objects, or any code which needs
 * to access Records cached in an {@link Roo.data.Store} object.<br>
 * <p>
 * Constructors for this class are generated by passing an Array of field definition objects to {@link #create}.
 * Instances are usually only created by {@link Roo.data.Reader} implementations when processing unformatted data
 * objects.<br>
 * <p>
 * Record objects generated by this constructor inherit all the methods of Roo.data.Record listed below.
 * @constructor
 * This constructor should not be used to create Record objects. Instead, use the constructor generated by
 * {@link #create}. The parameters are the same.
 * @param {Array} data An associative Array of data values keyed by the field name.
 * @param {Object} id (Optional) The id of the record. This id should be unique, and is used by the
 * {@link Roo.data.Store} object which owns the Record to index its collection of Records. If
 * not specified an integer id is generated.
 */
Roo.data.Record = function(A, id){
    this.id = (id || id === 0) ? id : ++Roo.data.Record.AUTO_ID;
    this.data = A;
};

/**
 * Generate a constructor for a specific record layout.
 * @param {Array} o An Array of field definition objects which specify field names, and optionally,
 * data types, and a mapping for an {@link Roo.data.Reader} to extract the field's value from a data object.
 * Each field definition object may contain the following properties: <ul>
 * <li><b>name</b> : String<p style="margin-left:1em">The name by which the field is referenced within the Record. This is referenced by,
 * for example the <em>dataIndex</em> property in column definition objects passed to {@link Roo.grid.ColumnModel}</p></li>
 * <li><b>mapping</b> : String<p style="margin-left:1em">(Optional) A path specification for use by the {@link Roo.data.Reader} implementation
 * that is creating the Record to access the data value from the data object. If an {@link Roo.data.JsonReader}
 * is being used, then this is a string containing the javascript expression to reference the data relative to 
 * the record item's root. If an {@link Roo.data.XmlReader} is being used, this is an {@link Roo.DomQuery} path
 * to the data item relative to the record element. If the mapping expression is the same as the field name,
 * this may be omitted.</p></li>
 * <li><b>type</b> : String<p style="margin-left:1em">(Optional) The data type for conversion to displayable value. Possible values are
 * <ul><li>auto (Default, implies no conversion)</li>
 * <li>string</li>
 * <li>int</li>
 * <li>float</li>
 * <li>boolean</li>
 * <li>date</li></ul></p></li>
 * <li><b>sortType</b> : Mixed<p style="margin-left:1em">(Optional) A member of {@link Roo.data.SortTypes}.</p></li>
 * <li><b>sortDir</b> : String<p style="margin-left:1em">(Optional) Initial direction to sort. "ASC" or "DESC"</p></li>
 * <li><b>convert</b> : Function<p style="margin-left:1em">(Optional) A function which converts the value provided
 * by the Reader into an object that will be stored in the Record. It is passed the
 * following parameters:<ul>
 * <li><b>v</b> : Mixed<p style="margin-left:1em">The data value as read by the Reader.</p></li>
 * </ul></p></li>
 * <li><b>dateFormat</b> : String<p style="margin-left:1em">(Optional) A format String for the Date.parseDate function.</p></li>
 * </ul>
 * <br>usage:<br><pre><code>
var TopicRecord = Roo.data.Record.create(
    {name: 'title', mapping: 'topic_title'},
    {name: 'author', mapping: 'username'},
    {name: 'totalPosts', mapping: 'topic_replies', type: 'int'},
    {name: 'lastPost', mapping: 'post_time', type: 'date'},
    {name: 'lastPoster', mapping: 'user2'},
    {name: 'excerpt', mapping: 'post_text'}
);

var myNewRecord = new TopicRecord({
    title: 'Do my job please',
    author: 'noobie',
    totalPosts: 1,
    lastPost: new Date(),
    lastPoster: 'Animal',
    excerpt: 'No way dude!'
});
myStore.add(myNewRecord);
</code></pre>
 * @method create
 * @static
 */
Roo.data.Record.create = function(o){
    var  f = function(){
        f.superclass.constructor.apply(this, arguments);
    };
    Roo.extend(f, Roo.data.Record);
    var  p = f.prototype;
    p.fields = new  Roo.util.MixedCollection(false, function(B){
        return  B.name;
    });
    for(var  i = 0, len = o.length; i < len; i++){
        p.fields.add(new  Roo.data.Field(o[i]));
    }

    f.getField = function(B){
        return  p.fields.get(B);  
    };
    return  f;
};

Roo.data.Record.AUTO_ID = 1000;
Roo.data.Record.EDIT = 'edit';
Roo.data.Record.REJECT = 'reject';
Roo.data.Record.COMMIT = 'commit';

Roo.data.Record.prototype = {
    /**
     * Readonly flag - true if this record has been modified.
     * @type Boolean
     */
    dirty : false,
    editing : false,
    error: null,
    modified: null,

    // private
    join : function(B){
        this.store = B;
    },

    /**
     * Set the named field to the specified value.
     * @param {String} name The name of the field to set.
     * @param {Object} value The value to set the field to.
     */
    set : function(C, D){
        if(this.data[C] == D){
            return;
        }

        this.dirty = true;
        if(!this.modified){
            this.modified = {};
        }
        if(typeof  this.modified[C] == 'undefined'){
            this.modified[C] = this.data[C];
        }

        this.data[C] = D;
        if(!this.editing){
            this.store.afterEdit(this);
        }       
    },

    /**
     * Get the value of the named field.
     * @param {String} name The name of the field to get the value of.
     * @return {Object} The value of the field.
     */
    get : function(E){
        return  this.data[E]; 
    },

    // private
    beginEdit : function(){
        this.editing = true;
        this.modified = {}; 
    },

    // private
    cancelEdit : function(){
        this.editing = false;
        delete  this.modified;
    },

    // private
    endEdit : function(){
        this.editing = false;
        if(this.dirty && this.store){
            this.store.afterEdit(this);
        }
    },

    /**
     * Usually called by the {@link Roo.data.Store} which owns the Record.
     * Rejects all changes made to the Record since either creation, or the last commit operation.
     * Modified fields are reverted to their original values.
     * <p>
     * Developers should subscribe to the {@link Roo.data.Store#update} event to have their code notified
     * of reject operations.
     */
    reject : function(){
        var  m = this.modified;
        for(var  n  in  m){
            if(typeof  m[n] != "function"){
                this.data[n] = m[n];
            }
        }

        this.dirty = false;
        delete  this.modified;
        this.editing = false;
        if(this.store){
            this.store.afterReject(this);
        }
    },

    /**
     * Usually called by the {@link Roo.data.Store} which owns the Record.
     * Commits all changes made to the Record since either creation, or the last commit operation.
     * <p>
     * Developers should subscribe to the {@link Roo.data.Store#update} event to have their code notified
     * of commit operations.
     */
    commit : function(){
        this.dirty = false;
        delete  this.modified;
        this.editing = false;
        if(this.store){
            this.store.afterCommit(this);
        }
    },

    // private
    hasError : function(){
        return  this.error != null;
    },

    // private
    clearError : function(){
        this.error = null;
    },

    /**
     * Creates a copy of this record.
     * @param {String} id (optional) A new record id if you don't want to use this record's id
     * @return {Record}
     */
    copy : function(F) {
        return  new  this.constructor(Roo.apply({}, this.data), F || this.id);
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */



/**
 * @class Roo.data.Store
 * @extends Roo.util.Observable
 * The Store class encapsulates a client side cache of {@link Roo.data.Record} objects which provide input data
 * for widgets such as the Roo.grid.Grid, or the Roo.form.ComboBox.<br>
 * <p>
 * A Store object uses an implementation of {@link Roo.data.DataProxy} to access a data object unless you call loadData() directly and pass in your data. The Store object
 * has no knowledge of the format of the data returned by the Proxy.<br>
 * <p>
 * A Store object uses its configured implementation of {@link Roo.data.DataReader} to create {@link Roo.data.Record}
 * instances from the data object. These records are cached and made available through accessor functions.
 * @constructor
 * Creates a new Store.
 * @param {Object} config A config object containing the objects needed for the Store to access data,
 * and read the data into Records.
 */
Roo.data.Store = function(A){
    this.data = new  Roo.util.MixedCollection(false);
    this.data.getKey = function(o){
        return  o.id;
    };
    this.baseParams = {};
    // private
    this.paramNames = {
        "start" : "start",
        "limit" : "limit",
        "sort" : "sort",
        "dir" : "dir"
    };

    if(A && A.data){
        this.inlineData = A.data;
        delete  A.data;
    }


    Roo.apply(this, A);
    
    if(this.reader){ // reader passed
        this.reader = Roo.factory(this.reader, Roo.data);
        this.reader.xmodule = this.xmodule || false;
        if(!this.recordType){
            this.recordType = this.reader.recordType;
        }
        if(this.reader.onMetaChange){
            this.reader.onMetaChange = this.onMetaChange.createDelegate(this);
        }
    }

    if(this.recordType){
        this.fields = this.recordType.prototype.fields;
    }

    this.modified = [];

    this.addEvents({
        /**
         * @event datachanged
         * Fires when the data cache has changed, and a widget which is using this Store
         * as a Record cache should refresh its view.
         * @param {Store} this
         */
        datachanged : true,
        /**
         * @event metachange
         * Fires when this store's reader provides new metadata (fields). This is currently only support for JsonReaders.
         * @param {Store} this
         * @param {Object} meta The JSON metadata
         */
        metachange : true,
        /**
         * @event add
         * Fires when Records have been added to the Store
         * @param {Store} this
         * @param {Roo.data.Record[]} records The array of Records added
         * @param {Number} index The index at which the record(s) were added
         */
        add : true,
        /**
         * @event remove
         * Fires when a Record has been removed from the Store
         * @param {Store} this
         * @param {Roo.data.Record} record The Record that was removed
         * @param {Number} index The index at which the record was removed
         */
        remove : true,
        /**
         * @event update
         * Fires when a Record has been updated
         * @param {Store} this
         * @param {Roo.data.Record} record The Record that was updated
         * @param {String} operation The update operation being performed.  Value may be one of:
         * <pre><code>
 Roo.data.Record.EDIT
 Roo.data.Record.REJECT
 Roo.data.Record.COMMIT
         * </code></pre>
         */
        update : true,
        /**
         * @event clear
         * Fires when the data cache has been cleared.
         * @param {Store} this
         */
        clear : true,
        /**
         * @event beforeload
         * Fires before a request is made for a new data object.  If the beforeload handler returns false
         * the load action will be canceled.
         * @param {Store} this
         * @param {Object} options The loading options that were specified (see {@link #load} for details)
         */
        beforeload : true,
        /**
         * @event load
         * Fires after a new set of Records has been loaded.
         * @param {Store} this
         * @param {Roo.data.Record[]} records The Records that were loaded
         * @param {Object} options The loading options that were specified (see {@link #load} for details)
         */
        load : true,
        /**
         * @event loadexception
         * Fires if an exception occurs in the Proxy during loading.
         * Called with the signature of the Proxy's "loadexception" event.
         * If you return Json { data: [] , success: false, .... } then this will be thrown with the following args
         * 
         * @param {Proxy} 
         * @param {Object} return from JsonData.reader() - success, totalRecords, records
         * @param {Object} load options 
         * @param {Object} jsonData from your request (normally this contains the Exception)
         */
        loadexception : true
    });
    
    if(this.proxy){
        this.proxy = Roo.factory(this.proxy, Roo.data);
        this.proxy.xmodule = this.xmodule || false;
        this.relayEvents(this.proxy,  ["loadexception"]);
    }

    this.sortToggle = {};

    Roo.data.Store.superclass.constructor.call(this);

    if(this.inlineData){
        this.loadData(this.inlineData);
        delete  this.inlineData;
    }
};
Roo.extend(Roo.data.Store, Roo.util.Observable, {
     /**
    * @cfg {boolean} isLocal   flag if data is locally available (and can be always looked up
    * without a remote query - used by combo/forms at present.
    */
    
    /**
    * @cfg {Roo.data.DataProxy} proxy The Proxy object which provides access to a data object.
    */
    /**
    * @cfg {Array} data Inline data to be loaded when the store is initialized.
    */
    /**
    * @cfg {Roo.data.Reader} reader The Reader object which processes the data object and returns
    * an Array of Roo.data.record objects which are cached keyed by their <em>id</em> property.
    */
    /**
    * @cfg {Object} baseParams An object containing properties which are to be sent as parameters
    * on any HTTP request
    */
    /**
    * @cfg {Object} sortInfo A config object in the format: {field: "fieldName", direction: "ASC|DESC"}
    */
    /**
    * @cfg {boolean} remoteSort True if sorting is to be handled by requesting the Proxy to provide a refreshed
    * version of the data object in sorted order, as opposed to sorting the Record cache in place (defaults to false).
    */
    remoteSort : false,

    /**
    * @cfg {boolean} pruneModifiedRecords True to clear all modified record information each time the store is
     * loaded or when a record is removed. (defaults to false).
    */
    pruneModifiedRecords : false,

    // private
    lastOptions : null,

    /**
     * Add Records to the Store and fires the add event.
     * @param {Roo.data.Record[]} records An Array of Roo.data.Record objects to add to the cache.
     */
    add : function(B){
        B = [].concat(B);
        for(var  i = 0, len = B.length; i < len; i++){
            B[i].join(this);
        }
        var  C = this.data.length;
        this.data.addAll(B);
        this.fireEvent("add", this, B, C);
    },

    /**
     * Remove a Record from the Store and fires the remove event.
     * @param {Ext.data.Record} record The Roo.data.Record object to remove from the cache.
     */
    remove : function(D){
        var  E = this.data.indexOf(D);
        this.data.removeAt(E);
        if(this.pruneModifiedRecords){
            this.modified.remove(D);
        }

        this.fireEvent("remove", this, D, E);
    },

    /**
     * Remove all Records from the Store and fires the clear event.
     */
    removeAll : function(){
        this.data.clear();
        if(this.pruneModifiedRecords){
            this.modified = [];
        }

        this.fireEvent("clear", this);
    },

    /**
     * Inserts Records to the Store at the given index and fires the add event.
     * @param {Number} index The start index at which to insert the passed Records.
     * @param {Roo.data.Record[]} records An Array of Roo.data.Record objects to add to the cache.
     */
    insert : function(F, G){
        G = [].concat(G);
        for(var  i = 0, len = G.length; i < len; i++){
            this.data.insert(F, G[i]);
            G[i].join(this);
        }

        this.fireEvent("add", this, G, F);
    },

    /**
     * Get the index within the cache of the passed Record.
     * @param {Roo.data.Record} record The Roo.data.Record object to to find.
     * @return {Number} The index of the passed Record. Returns -1 if not found.
     */
    indexOf : function(H){
        return  this.data.indexOf(H);
    },

    /**
     * Get the index within the cache of the Record with the passed id.
     * @param {String} id The id of the Record to find.
     * @return {Number} The index of the Record. Returns -1 if not found.
     */
    indexOfId : function(id){
        return  this.data.indexOfKey(id);
    },

    /**
     * Get the Record with the specified id.
     * @param {String} id The id of the Record to find.
     * @return {Roo.data.Record} The Record with the passed id. Returns undefined if not found.
     */
    getById : function(id){
        return  this.data.key(id);
    },

    /**
     * Get the Record at the specified index.
     * @param {Number} index The index of the Record to find.
     * @return {Roo.data.Record} The Record at the passed index. Returns undefined if not found.
     */
    getAt : function(I){
        return  this.data.itemAt(I);
    },

    /**
     * Returns a range of Records between specified indices.
     * @param {Number} startIndex (optional) The starting index (defaults to 0)
     * @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store)
     * @return {Roo.data.Record[]} An array of Records
     */
    getRange : function(J, K){
        return  this.data.getRange(J, K);
    },

    // private
    storeOptions : function(o){
        o = Roo.apply({}, o);
        delete  o.callback;
        delete  o.scope;
        this.lastOptions = o;
    },

    /**
     * Loads the Record cache from the configured Proxy using the configured Reader.
     * <p>
     * If using remote paging, then the first load call must specify the <em>start</em>
     * and <em>limit</em> properties in the options.params property to establish the initial
     * position within the dataset, and the number of Records to cache on each read from the Proxy.
     * <p>
     * <strong>It is important to note that for remote data sources, loading is asynchronous,
     * and this call will return before the new data has been loaded. Perform any post-processing
     * in a callback function, or in a "load" event handler.</strong>
     * <p>
     * @param {Object} options An object containing properties which control loading options:<ul>
     * <li>params {Object} An object containing properties to pass as HTTP parameters to a remote data source.</li>
     * <li>callback {Function} A function to be called after the Records have been loaded. The callback is
     * passed the following arguments:<ul>
     * <li>r : Roo.data.Record[]</li>
     * <li>options: Options object from the load call</li>
     * <li>success: Boolean success indicator</li></ul></li>
     * <li>scope {Object} Scope with which to call the callback (defaults to the Store object)</li>
     * <li>add {Boolean} indicator to append loaded records rather than replace the current cache.</li>
     * </ul>
     */
    load : function(L){
        L = L || {};
        if(this.fireEvent("beforeload", this, L) !== false){
            this.storeOptions(L);
            var  p = Roo.apply(L.params || {}, this.baseParams);
            if(this.sortInfo && this.remoteSort){
                var  pn = this.paramNames;
                p[pn["sort"]] = this.sortInfo.field;
                p[pn["dir"]] = this.sortInfo.direction;
            }

            this.proxy.load(p, this.reader, this.loadRecords, this, L);
        }
    },

    /**
     * Reloads the Record cache from the configured Proxy using the configured Reader and
     * the options from the last load operation performed.
     * @param {Object} options (optional) An object containing properties which may override the options
     * used in the last load operation. See {@link #load} for details (defaults to null, in which case
     * the most recently used options are reused).
     */
    reload : function(M){
        this.load(Roo.applyIf(M||{}, this.lastOptions));
    },

    // private
    // Called as a callback by the Reader during a load operation.
    loadRecords : function(o, N, O){
        if(!o || O === false){
            if(O !== false){
                this.fireEvent("load", this, [], N);
            }
            if(N.callback){
                N.callback.call(N.scope || this, [], N, false);
            }
            return;
        }
        // if data returned failure - throw an exception.
        if (o.success === false) {
            this.fireEvent("loadexception", this, o, N, this.reader.jsonData);
            return;
        }
        var  r = o.records, t = o.totalRecords || r.length;
        if(!N || N.add !== true){
            if(this.pruneModifiedRecords){
                this.modified = [];
            }
            for(var  i = 0, len = r.length; i < len; i++){
                r[i].join(this);
            }
            if(this.snapshot){
                this.data = this.snapshot;
                delete  this.snapshot;
            }

            this.data.clear();
            this.data.addAll(r);
            this.totalLength = t;
            this.applySort();
            this.fireEvent("datachanged", this);
        }else {
            this.totalLength = Math.max(t, this.data.length+r.length);
            this.add(r);
        }

        this.fireEvent("load", this, r, N);
        if(N.callback){
            N.callback.call(N.scope || this, r, N, true);
        }
    },

    /**
     * Loads data from a passed data block. A Reader which understands the format of the data
     * must have been configured in the constructor.
     * @param {Object} data The data block from which to read the Records.  The format of the data expected
     * is dependent on the type of Reader that is configured and should correspond to that Reader's readRecords parameter.
     * @param {Boolean} append (Optional) True to append the new Records rather than replace the existing cache.
     */
    loadData : function(o, P){
        var  r = this.reader.readRecords(o);
        this.loadRecords(r, {add: P}, true);
    },

    /**
     * Gets the number of cached records.
     * <p>
     * <em>If using paging, this may not be the total size of the dataset. If the data object
     * used by the Reader contains the dataset size, then the getTotalCount() function returns
     * the data set size</em>
     */
    getCount : function(){
        return  this.data.length || 0;
    },

    /**
     * Gets the total number of records in the dataset as returned by the server.
     * <p>
     * <em>If using paging, for this to be accurate, the data object used by the Reader must contain
     * the dataset size</em>
     */
    getTotalCount : function(){
        return  this.totalLength || 0;
    },

    /**
     * Returns the sort state of the Store as an object with two properties:
     * <pre><code>
 field {String} The name of the field by which the Records are sorted
 direction {String} The sort order, "ASC" or "DESC"
     * </code></pre>
     */
    getSortState : function(){
        return  this.sortInfo;
    },

    // private
    applySort : function(){
        if(this.sortInfo && !this.remoteSort){
            var  s = this.sortInfo, f = s.field;
            var  st = this.fields.get(f).sortType;
            var  fn = function(r1, r2){
                var  v1 = st(r1.data[f]), v2 = st(r2.data[f]);
                return  v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
            };
            this.data.sort(s.direction, fn);
            if(this.snapshot && this.snapshot != this.data){
                this.snapshot.sort(s.direction, fn);
            }
        }
    },

    /**
     * Sets the default sort column and order to be used by the next load operation.
     * @param {String} fieldName The name of the field to sort by.
     * @param {String} dir (optional) The sort order, "ASC" or "DESC" (defaults to "ASC")
     */
    setDefaultSort : function(Q, R){
        this.sortInfo = {field: Q, direction: R ? R.toUpperCase() : "ASC"};
    },

    /**
     * Sort the Records.
     * If remote sorting is used, the sort is performed on the server, and the cache is
     * reloaded. If local sorting is used, the cache is sorted internally.
     * @param {String} fieldName The name of the field to sort by.
     * @param {String} dir (optional) The sort order, "ASC" or "DESC" (defaults to "ASC")
     */
    sort : function(S, T){
        var  f = this.fields.get(S);
        if(!T){
            if(this.sortInfo && this.sortInfo.field == f.name){ // toggle sort dir
                T = (this.sortToggle[f.name] || "ASC").toggle("ASC", "DESC");
            }else {
                T = f.sortDir;
            }
        }

        this.sortToggle[f.name] = T;
        this.sortInfo = {field: f.name, direction: T};
        if(!this.remoteSort){
            this.applySort();
            this.fireEvent("datachanged", this);
        }else {
            this.load(this.lastOptions);
        }
    },

    /**
     * Calls the specified function for each of the Records in the cache.
     * @param {Function} fn The function to call. The Record is passed as the first parameter.
     * Returning <em>false</em> aborts and exits the iteration.
     * @param {Object} scope (optional) The scope in which to call the function (defaults to the Record).
     */
    each : function(fn, U){
        this.data.each(fn, U);
    },

    /**
     * Gets all records modified since the last commit.  Modified records are persisted across load operations
     * (e.g., during paging).
     * @return {Roo.data.Record[]} An array of Records containing outstanding modifications.
     */
    getModifiedRecords : function(){
        return  this.modified;
    },

    // private
    createFilterFn : function(V, W, X){
        if(!W.exec){ // not a regex
            W = String(W);
            if(W.length == 0){
                return  false;
            }

            W = new  RegExp((X === true ? '' : '^') + Roo.escapeRe(W), "i");
        }
        return  function(r){
            return  W.test(r.data[V]);
        };
    },

    /**
     * Sums the value of <i>property</i> for each record between start and end and returns the result.
     * @param {String} property A field on your records
     * @param {Number} start The record index to start at (defaults to 0)
     * @param {Number} end The last record index to include (defaults to length - 1)
     * @return {Number} The sum
     */
    sum : function(Y, Z, a){
        var  rs = this.data.items, v = 0;
        Z = Z || 0;
        a = (a || a === 0) ? a : rs.length-1;

        for(var  i = Z; i <= a; i++){
            v += (rs[i].data[Y] || 0);
        }
        return  v;
    },

    /**
     * Filter the records by a specified property.
     * @param {String} field A field on your records
     * @param {String/RegExp} value Either a string that the field
     * should start with or a RegExp to test against the field
     * @param {Boolean} anyMatch True to match any part not just the beginning
     */
    filter : function(b, c, d){
        var  fn = this.createFilterFn(b, c, d);
        return  fn ? this.filterBy(fn) : this.clearFilter();
    },

    /**
     * Filter by a function. The specified function will be called with each
     * record in this data source. If the function returns true the record is included,
     * otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive 2 args (record, id)
     * @param {Object} scope (optional) The scope of the function (defaults to this)
     */
    filterBy : function(fn, e){
        this.snapshot = this.snapshot || this.data;
        this.data = this.queryBy(fn, e||this);
        this.fireEvent("datachanged", this);
    },

    /**
     * Query the records by a specified property.
     * @param {String} field A field on your records
     * @param {String/RegExp} value Either a string that the field
     * should start with or a RegExp to test against the field
     * @param {Boolean} anyMatch True to match any part not just the beginning
     * @return {MixedCollection} Returns an Roo.util.MixedCollection of the matched records
     */
    query : function(g, h, j){
        var  fn = this.createFilterFn(g, h, j);
        return  fn ? this.queryBy(fn) : this.data.clone();
    },

    /**
     * Query by a function. The specified function will be called with each
     * record in this data source. If the function returns true the record is included
     * in the results.
     * @param {Function} fn The function to be called, it will receive 2 args (record, id)
     * @param {Object} scope (optional) The scope of the function (defaults to this)
      @return {MixedCollection} Returns an Roo.util.MixedCollection of the matched records
     **/
    queryBy : function(fn, k){
        var  l = this.snapshot || this.data;
        return  l.filterBy(fn, k||this);
    },

    /**
     * Collects unique values for a particular dataIndex from this store.
     * @param {String} dataIndex The property to collect
     * @param {Boolean} allowNull (optional) Pass true to allow null, undefined or empty string values
     * @param {Boolean} bypassFilter (optional) Pass true to collect from all records, even ones which are filtered
     * @return {Array} An array of the unique values
     **/
    collect : function(m, n, q){
        var  d = (q === true && this.snapshot) ?
                this.snapshot.items : this.data.items;
        var  v, sv, r = [], l = {};
        for(var  i = 0, len = d.length; i < len; i++){
            v = d[i].data[m];
            sv = String(v);
            if((n || !Roo.isEmpty(v)) && !l[sv]){
                l[sv] = true;
                r[r.length] = v;
            }
        }
        return  r;
    },

    /**
     * Revert to a view of the Record cache with no filtering applied.
     * @param {Boolean} suppressEvent If true the filter is cleared silently without notifying listeners
     */
    clearFilter : function(u){
        if(this.snapshot && this.snapshot != this.data){
            this.data = this.snapshot;
            delete  this.snapshot;
            if(u !== true){
                this.fireEvent("datachanged", this);
            }
        }
    },

    // private
    afterEdit : function(w){
        if(this.modified.indexOf(w) == -1){
            this.modified.push(w);
        }

        this.fireEvent("update", this, w, Roo.data.Record.EDIT);
    },

    // private
    afterReject : function(x){
        this.modified.remove(x);
        this.fireEvent("update", this, x, Roo.data.Record.REJECT);
    },

    // private
    afterCommit : function(y){
        this.modified.remove(y);
        this.fireEvent("update", this, y, Roo.data.Record.COMMIT);
    },

    /**
     * Commit all Records with outstanding changes. To handle updates for changes, subscribe to the
     * Store's "update" event, and perform updating when the third parameter is Roo.data.Record.COMMIT.
     */
    commitChanges : function(){
        var  m = this.modified.slice(0);
        this.modified = [];
        for(var  i = 0, len = m.length; i < len; i++){
            m[i].commit();
        }
    },

    /**
     * Cancel outstanding changes on all changed records.
     */
    rejectChanges : function(){
        var  m = this.modified.slice(0);
        this.modified = [];
        for(var  i = 0, len = m.length; i < len; i++){
            m[i].reject();
        }
    },

    onMetaChange : function(z, AA, o){
        this.recordType = AA;
        this.fields = AA.prototype.fields;
        delete  this.snapshot;
        this.sortInfo = z.sortInfo;
        this.modified = [];
        this.fireEvent('metachange', this, this.reader.meta);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.SimpleStore
 * @extends Roo.data.Store
 * Small helper class to make creating Stores from Array data easier.
 * @cfg {Number} id The array index of the record id. Leave blank to auto generate ids.
 * @cfg {Array} fields An array of field definition objects, or field name strings.
 * @cfg {Array} data The multi-dimensional array of data
 * @constructor
 * @param {Object} config
 */
Roo.data.SimpleStore = function(A){
    Roo.data.SimpleStore.superclass.constructor.call(this, {
        isLocal : true,
        reader: new  Roo.data.ArrayReader({
                id: A.id
            },
            Roo.data.Record.create(A.fields)
        ),
        proxy : new  Roo.data.MemoryProxy(A.data)
    });
    this.load();
};
Roo.extend(Roo.data.SimpleStore, Roo.data.Store);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
/**
 * @extends Roo.data.Store
 * @class Roo.data.JsonStore
 * Small helper class to make creating Stores for JSON data easier. <br/>
<pre><code>
var store = new Roo.data.JsonStore({
    url: 'get-images.php',
    root: 'images',
    fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
});
</code></pre>
 * <b>Note: Although they are not listed, this class inherits all of the config options of Store,
 * JsonReader and HttpProxy (unless inline data is provided).</b>
 * @cfg {Array} fields An array of field definition objects, or field name strings.
 * @constructor
 * @param {Object} config
 */
Roo.data.JsonStore = function(c){
    Roo.data.JsonStore.superclass.constructor.call(this, Roo.apply(c, {
        proxy: !c.data ? new  Roo.data.HttpProxy({url: c.url}) : undefined,
        reader: new  Roo.data.JsonReader(c, c.fields)
    }));
};
Roo.extend(Roo.data.JsonStore, Roo.data.Store);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

 
Roo.data.Field = function(A){
    if(typeof  A == "string"){
        A = {name: A};
    }

    Roo.apply(this, A);
    
    if(!this.type){
        this.type = "auto";
    }
    
    var  st = Roo.data.SortTypes;
    // named sortTypes are supported, here we look them up
    if(typeof  this.sortType == "string"){
        this.sortType = st[this.sortType];
    }
    
    // set default sortType for strings and dates
    if(!this.sortType){
        switch(this.type){
            case  "string":
                this.sortType = st.asUCString;
                break;
            case  "date":
                this.sortType = st.asDate;
                break;
            default:
                this.sortType = st.none;
        }
    }

    // define once
    var  B = /[\$,%]/g;

    // prebuilt conversion function for this field, instead of
    // switching every time we're reading a value
    if(!this.convert){
        var  cv, dateFormat = this.dateFormat;
        switch(this.type){
            case  "":
            case  "auto":
            case  undefined:
                cv = function(v){ return  v; };
                break;
            case  "string":
                cv = function(v){ return  (v === undefined || v === null) ? '' : String(v); };
                break;
            case  "int":
                cv = function(v){
                    return  v !== undefined && v !== null && v !== '' ?
                           parseInt(String(v).replace(B, ""), 10) : '';
                    };
                break;
            case  "float":
                cv = function(v){
                    return  v !== undefined && v !== null && v !== '' ?
                           parseFloat(String(v).replace(B, ""), 10) : ''; 
                    };
                break;
            case  "bool":
            case  "boolean":
                cv = function(v){ return  v === true || v === "true" || v == 1; };
                break;
            case  "date":
                cv = function(v){
                    if(!v){
                        return  '';
                    }
                    if(v  instanceof  Date){
                        return  v;
                    }
                    if(dateFormat){
                        if(dateFormat == "timestamp"){
                            return  new  Date(v*1000);
                        }
                        return  Date.parseDate(v, dateFormat);
                    }
                    var  C = Date.parse(v);
                    return  C ? new  Date(C) : null;
                };
             break;
            
        }

        this.convert = cv;
    }
};

Roo.data.Field.prototype = {
    dateFormat: null,
    defaultValue: "",
    mapping: null,
    sortType : null,
    sortDir : "ASC"
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
// Base class for reading structured data from a data source.  This class is intended to be
// extended (see ArrayReader, JsonReader and XmlReader) and should not be created directly.

/**
 * @class Roo.data.DataReader
 * Base class for reading structured data from a data source.  This class is intended to be
 * extended (see {Roo.data.ArrayReader}, {Roo.data.JsonReader} and {Roo.data.XmlReader}) and should not be created directly.
 */

Roo.data.DataReader = function(A, B){
    
    this.meta = A;
    
    this.recordType = B  instanceof  Array ? 
        Roo.data.Record.create(B) : B;
};

Roo.data.DataReader.prototype = {
     /**
     * Create an empty record
     * @param {Object} data (optional) - overlay some values
     * @return {Roo.data.Record} record created.
     */
    newRow :  function(d) {
        var  da =  {};
        this.recordType.prototype.fields.each(function(c) {
            switch( c.type) {
                case  'int' : da[c.name] = 0; break;
                case  'date' : da[c.name] = new  Date(); break;
                case  'float' : da[c.name] = 0.0; break;
                case  'boolean' : da[c.name] = false; break;
                default : da[c.name] = ""; break;
            }
            
        });
        return  new  this.recordType(Roo.apply(da, d));
    }
    
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.DataProxy
 * @extends Roo.data.Observable
 * This class is an abstract base class for implementations which provide retrieval of
 * unformatted data objects.<br>
 * <p>
 * DataProxy implementations are usually used in conjunction with an implementation of Roo.data.DataReader
 * (of the appropriate type which knows how to parse the data object) to provide a block of
 * {@link Roo.data.Records} to an {@link Roo.data.Store}.<br>
 * <p>
 * Custom implementations must implement the load method as described in
 * {@link Roo.data.HttpProxy#load}.
 */
Roo.data.DataProxy = function(){
    this.addEvents({
        /**
         * @event beforeload
         * Fires before a network request is made to retrieve a data object.
         * @param {Object} This DataProxy object.
         * @param {Object} params The params parameter to the load function.
         */
        beforeload : true,
        /**
         * @event load
         * Fires before the load method's callback is called.
         * @param {Object} This DataProxy object.
         * @param {Object} o The data object.
         * @param {Object} arg The callback argument object passed to the load function.
         */
        load : true,
        /**
         * @event loadexception
         * Fires if an Exception occurs during data retrieval.
         * @param {Object} This DataProxy object.
         * @param {Object} o The data object.
         * @param {Object} arg The callback argument object passed to the load function.
         * @param {Object} e The Exception.
         */
        loadexception : true
    });
    Roo.data.DataProxy.superclass.constructor.call(this);
};

Roo.extend(Roo.data.DataProxy, Roo.util.Observable);

    /**
     * @cfg {void} listeners (Not available) Constructor blocks listeners from being set
     */

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.data.MemoryProxy
 * An implementation of Roo.data.DataProxy that simply passes the data specified in its constructor
 * to the Reader when its load method is called.
 * @constructor
 * @param {Object} data The data object which the Reader uses to construct a block of Roo.data.Records.
 */
Roo.data.MemoryProxy = function(A){
    if (A.data) {
        A = A.data;
    }

    Roo.data.MemoryProxy.superclass.constructor.call(this);
    this.data = A;
};

Roo.extend(Roo.data.MemoryProxy, Roo.data.DataProxy, {
    /**
     * Load data from the requested source (in this case an in-memory
     * data object passed to the constructor), read the data object into
     * a block of Roo.data.Records using the passed Roo.data.DataReader implementation, and
     * process that block using the passed callback.
     * @param {Object} params This parameter is not used by the MemoryProxy class.
     * @param {Roo.data.DataReader} reader The Reader object which converts the data
     * object into a block of Roo.data.Records.
     * @param {Function} callback The function into which to pass the block of Roo.data.records.
     * The function must be passed <ul>
     * <li>The Record block object</li>
     * <li>The "arg" argument from the load function</li>
     * <li>A boolean success indicator</li>
     * </ul>
     * @param {Object} scope The scope in which to call the callback
     * @param {Object} arg An optional argument which is passed to the callback as its second parameter.
     */
    load : function(B, C, D, E, F){
        B = B || {};
        var  G;
        try {
            G = C.readRecords(this.data);
        }catch(e){
            this.fireEvent("loadexception", this, arg, null, e);
            callback.call(scope, null, arg, false);
            return;
        }

        D.call(E, G, F, true);
    },
    
    // private
    update : function(H, I){
        
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.data.HttpProxy
 * @extends Roo.data.DataProxy
 * An implementation of {@link Roo.data.DataProxy} that reads a data object from an {@link Roo.data.Connection} object
 * configured to reference a certain URL.<br><br>
 * <p>
 * <em>Note that this class cannot be used to retrieve data from a domain other than the domain
 * from which the running page was served.<br><br>
 * <p>
 * For cross-domain access to remote data, use an {@link Roo.data.ScriptTagProxy}.</em><br><br>
 * <p>
 * Be aware that to enable the browser to parse an XML document, the server must set
 * the Content-Type header in the HTTP response to "text/xml".
 * @constructor
 * @param {Object} conn Connection config options to add to each request (e.g. {url: 'foo.php'} or
 * an {@link Roo.data.Connection} object.  If a Connection config is passed, the singleton {@link Roo.Ajax} object
 * will be used to make the request.
 */
Roo.data.HttpProxy = function(A){
    Roo.data.HttpProxy.superclass.constructor.call(this);
    // is conn a conn config or a real conn?
    this.conn = A;
    this.useAjax = !A || !A.events;
  
};

Roo.extend(Roo.data.HttpProxy, Roo.data.DataProxy, {
    // thse are take from connection...
    
    /**
     * @cfg {String} url (Optional) The default URL to be used for requests to the server. (defaults to undefined)
     */
    /**
     * @cfg {Object} extraParams (Optional) An object containing properties which are used as
     * extra parameters to each request made by this object. (defaults to undefined)
     */
    /**
     * @cfg {Object} defaultHeaders (Optional) An object containing request headers which are added
     *  to each request made by this object. (defaults to undefined)
     */
    /**
     * @cfg {String} method (Optional) The default HTTP method to be used for requests. (defaults to undefined; if not set but parms are present will use POST, otherwise GET)
     */
    /**
     * @cfg {Number} timeout (Optional) The timeout in milliseconds to be used for requests. (defaults to 30000)
     */
     /**
     * @cfg {Boolean} autoAbort (Optional) Whether this request should abort any pending requests. (defaults to false)
     * @type Boolean
     */
  

    /**
     * @cfg {Boolean} disableCaching (Optional) True to add a unique cache-buster param to GET requests. (defaults to true)
     * @type Boolean
     */
    /**
     * Return the {@link Roo.data.Connection} object being used by this Proxy.
     * @return {Connection} The Connection object. This object may be used to subscribe to events on
     * a finer-grained basis than the DataProxy events.
     */
    getConnection : function(){
        return  this.useAjax ? Roo.Ajax : this.conn;
    },

    /**
     * Load data from the configured {@link Roo.data.Connection}, read the data object into
     * a block of Roo.data.Records using the passed {@link Roo.data.DataReader} implementation, and
     * process that block using the passed callback.
     * @param {Object} params An object containing properties which are to be used as HTTP parameters
     * for the request to the remote server.
     * @param {Roo.data.DataReader} reader The Reader object which converts the data
     * object into a block of Roo.data.Records.
     * @param {Function} callback The function into which to pass the block of Roo.data.Records.
     * The function must be passed <ul>
     * <li>The Record block object</li>
     * <li>The "arg" argument from the load function</li>
     * <li>A boolean success indicator</li>
     * </ul>
     * @param {Object} scope The scope in which to call the callback
     * @param {Object} arg An optional argument which is passed to the callback as its second parameter.
     */
    load : function(B, C, D, E, F){
        if(this.fireEvent("beforeload", this, B) !== false){
            var   o = {
                params : B || {},
                request: {
                    callback : D,
                    scope : E,
                    arg : F
                },
                reader: C,
                callback : this.loadResponse,
                scope: this
            };
            if(this.useAjax){
                Roo.applyIf(o, this.conn);
                if(this.activeRequest){
                    Roo.Ajax.abort(this.activeRequest);
                }

                this.activeRequest = Roo.Ajax.request(o);
            }else {
                this.conn.request(o);
            }
        }else {
            D.call(E||this, null, F, false);
        }
    },

    // private
    loadResponse : function(o, G, H){
        delete  this.activeRequest;
        if(!G){
            this.fireEvent("loadexception", this, o, H);
            o.request.callback.call(o.request.scope, null, o.request.arg, false);
            return;
        }
        var  I;
        try {
            I = o.reader.read(H);
        }catch(e){
            this.fireEvent("loadexception", this, o, response, e);
            o.request.callback.call(o.request.scope, null, o.request.arg, false);
            return;
        }

        
        this.fireEvent("load", this, o, o.request.arg);
        o.request.callback.call(o.request.scope, I, o.request.arg, true);
    },

    // private
    update : function(J){

    },

    // private
    updateResponse : function(K){

    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.ScriptTagProxy
 * An implementation of Roo.data.DataProxy that reads a data object from a URL which may be in a domain
 * other than the originating domain of the running page.<br><br>
 * <p>
 * <em>Note that if you are retrieving data from a page that is in a domain that is NOT the same as the originating domain
 * of the running page, you must use this class, rather than DataProxy.</em><br><br>
 * <p>
 * The content passed back from a server resource requested by a ScriptTagProxy is executable JavaScript
 * source code that is used as the source inside a &lt;script> tag.<br><br>
 * <p>
 * In order for the browser to process the returned data, the server must wrap the data object
 * with a call to a callback function, the name of which is passed as a parameter by the ScriptTagProxy.
 * Below is a Java example for a servlet which returns data for either a ScriptTagProxy, or an HttpProxy
 * depending on whether the callback name was passed:
 * <p>
 * <pre><code>
boolean scriptTag = false;
String cb = request.getParameter("callback");
if (cb != null) {
    scriptTag = true;
    response.setContentType("text/javascript");
} else {
    response.setContentType("application/x-json");
}
Writer out = response.getWriter();
if (scriptTag) {
    out.write(cb + "(");
}
out.print(dataBlock.toJsonString());
if (scriptTag) {
    out.write(");");
}
</pre></code>
 *
 * @constructor
 * @param {Object} config A configuration object.
 */
Roo.data.ScriptTagProxy = function(A){
    Roo.data.ScriptTagProxy.superclass.constructor.call(this);
    Roo.apply(this, A);
    this.head = document.getElementsByTagName("head")[0];
};

Roo.data.ScriptTagProxy.TRANS_ID = 1000;

Roo.extend(Roo.data.ScriptTagProxy, Roo.data.DataProxy, {
    /**
     * @cfg {String} url The URL from which to request the data object.
     */
    /**
     * @cfg {Number} timeout (Optional) The number of milliseconds to wait for a response. Defaults to 30 seconds.
     */
    timeout : 30000,
    /**
     * @cfg {String} callbackParam (Optional) The name of the parameter to pass to the server which tells
     * the server the name of the callback function set up by the load call to process the returned data object.
     * Defaults to "callback".<p>The server-side processing must read this parameter value, and generate
     * javascript output which calls this named function passing the data object as its only parameter.
     */
    callbackParam : "callback",
    /**
     *  @cfg {Boolean} nocache (Optional) Defaults to true. Disable cacheing by adding a unique parameter
     * name to the request.
     */
    nocache : true,

    /**
     * Load data from the configured URL, read the data object into
     * a block of Roo.data.Records using the passed Roo.data.DataReader implementation, and
     * process that block using the passed callback.
     * @param {Object} params An object containing properties which are to be used as HTTP parameters
     * for the request to the remote server.
     * @param {Roo.data.DataReader} reader The Reader object which converts the data
     * object into a block of Roo.data.Records.
     * @param {Function} callback The function into which to pass the block of Roo.data.Records.
     * The function must be passed <ul>
     * <li>The Record block object</li>
     * <li>The "arg" argument from the load function</li>
     * <li>A boolean success indicator</li>
     * </ul>
     * @param {Object} scope The scope in which to call the callback
     * @param {Object} arg An optional argument which is passed to the callback as its second parameter.
     */
    load : function(B, C, D, E, F){
        if(this.fireEvent("beforeload", this, B) !== false){

            var  p = Roo.urlEncode(Roo.apply(B, this.extraParams));

            var  url = this.url;
            url += (url.indexOf("?") != -1 ? "&" : "?") + p;
            if(this.nocache){
                url += "&_dc=" + (new  Date().getTime());
            }
            var  transId = ++Roo.data.ScriptTagProxy.TRANS_ID;
            var  trans = {
                id : transId,
                cb : "stcCallback"+transId,
                scriptId : "stcScript"+transId,
                params : B,
                arg : F,
                url : url,
                callback : D,
                scope : E,
                reader : C
            };
            var  conn = this;

            window[trans.cb] = function(o){
                conn.handleResponse(o, trans);
            };

            url += String.format("&{0}={1}", this.callbackParam, trans.cb);

            if(this.autoAbort !== false){
                this.abort();
            }


            trans.timeoutId = this.handleFailure.defer(this.timeout, this, [trans]);

            var  script = document.createElement("script");
            script.setAttribute("src", url);
            script.setAttribute("type", "text/javascript");
            script.setAttribute("id", trans.scriptId);
            this.head.appendChild(script);

            this.trans = trans;
        }else {
            D.call(E||this, null, F, false);
        }
    },

    // private
    isLoading : function(){
        return  this.trans ? true : false;
    },

    /**
     * Abort the current server request.
     */
    abort : function(){
        if(this.isLoading()){
            this.destroyTrans(this.trans);
        }
    },

    // private
    destroyTrans : function(G, H){
        this.head.removeChild(document.getElementById(G.scriptId));
        clearTimeout(G.timeoutId);
        if(H){
            window[G.cb] = undefined;
            try{
                delete  window[G.cb];
            }catch(e){}
        }else {
            // if hasn't been loaded, wait for load to remove it to prevent script error
            window[G.cb] = function(){
                window[G.cb] = undefined;
                try{
                    delete  window[G.cb];
                }catch(e){}
            };
        }
    },

    // private
    handleResponse : function(o, I){
        this.trans = false;
        this.destroyTrans(I, true);
        var  J;
        try {
            J = I.reader.readRecords(o);
        }catch(e){
            this.fireEvent("loadexception", this, o, trans.arg, e);
            trans.callback.call(trans.scope||window, null, trans.arg, false);
            return;
        }

        this.fireEvent("load", this, o, I.arg);
        I.callback.call(I.scope||window, J, I.arg, true);
    },

    // private
    handleFailure : function(K){
        this.trans = false;
        this.destroyTrans(K, false);
        this.fireEvent("loadexception", this, null, K.arg);
        K.callback.call(K.scope||window, null, K.arg, false);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.JsonReader
 * @extends Roo.data.DataReader
 * Data reader class to create an Array of Roo.data.Record objects from a JSON response
 * based on mappings in a provided Roo.data.Record constructor.
 * <p>
 * Example code:
 * <pre><code>
var RecordDef = Roo.data.Record.create([
    {name: 'name', mapping: 'name'},     // "mapping" property not needed if it's the same as "name"
    {name: 'occupation'}                 // This field will use "occupation" as the mapping.
]);
var myReader = new Roo.data.JsonReader({
    totalProperty: "results",    // The property which contains the total dataset size (optional)
    root: "rows",                // The property which contains an Array of row objects
    id: "id"                     // The property within each row object that provides an ID for the record (optional)
}, RecordDef);
</code></pre>
 * <p>
 * This would consume a JSON file like this:
 * <pre><code>
{ 'results': 2, 'rows': [
    { 'id': 1, 'name': 'Bill', occupation: 'Gardener' },
    { 'id': 2, 'name': 'Ben', occupation: 'Horticulturalist' } ]
}
</code></pre>
 * @cfg {String} totalProperty Name of the property from which to retrieve the total number of records
 * in the dataset. This is only needed if the whole dataset is not passed in one go, but is being
 * paged from the remote server.
 * @cfg {String} successProperty Name of the property from which to retrieve the success attribute used by forms.
 * @cfg {String} root name of the property which contains the Array of row objects.
 * @cfg {String} id Name of the property within a row object that contains a record identifier value.
 * @constructor
 * Create a new JsonReader
 * @param {Object} meta Metadata configuration options
 * @param {Object} recordType Either an Array of field definition objects,
 * or an {@link Roo.data.Record} object created using {@link Roo.data.Record#create}.
 */
Roo.data.JsonReader = function(A, B){
    
    A = A || {};
    // set some defaults:
    Roo.applyIf(A, {
        totalProperty: 'total',
        successProperty : 'success',
        root : 'data',
        id : 'id'
    });
    
    Roo.data.JsonReader.superclass.constructor.call(this, A, B||A.fields);
};
Roo.extend(Roo.data.JsonReader, Roo.data.DataReader, {
    /**
     * This method is only used by a DataProxy which has retrieved data from a remote server.
     * @param {Object} response The XHR object which contains the JSON data in its responseText.
     * @return {Object} data A data block which is used by an Roo.data.Store object as
     * a cache of Roo.data.Records.
     */
    read : function(C){
        var  D = C.responseText;
        /* eval:var:o */
        var  o = eval("("+D+")");
        if(!o) {
            throw  {message: "JsonReader.read: Json object not found"};
        }
        
        if(o.metaData){
            delete  this.ef;
            this.meta = o.metaData;
            this.recordType = Roo.data.Record.create(o.metaData.fields);
            this.onMetaChange(this.meta, this.recordType, o);
        }
        return  this.readRecords(o);
    },

    // private function a store will implement
    onMetaChange : function(E, F, o){

    },

    /**
	 * @ignore
	 */
    simpleAccess: function(G, H) {
    	return  G[H];
    },

	/**
	 * @ignore
	 */
    getJsonAccessor: function(){
        var  re = /[\[\.]/;
        return  function(I) {
            try {
                return (re.test(I))
                    ? new  Function("obj", "return obj." + I)
                    : function(K){
                        return  K[I];
                    };
            } catch(e){}
            return  Roo.emptyFn;
        };
    }(),

    /**
     * Create a data block containing Roo.data.Records from an XML document.
     * @param {Object} o An object which contains an Array of row objects in the property specified
     * in the config as 'root, and optionally a property, specified in the config as 'totalProperty'
     * which contains the total size of the dataset.
     * @return {Object} data A data block which is used by an Roo.data.Store object as
     * a cache of Roo.data.Records.
     */
    readRecords : function(o){
        /**
         * After any data loads, the raw JSON data is available for further custom processing.
         * @type Object
         */
        this.jsonData = o;
        var  s = this.meta, I = this.recordType,
            f = I.prototype.fields, fi = f.items, fl = f.length;

//      Generate extraction functions for the totalProperty, the root, the id, and for each field
        if (!this.ef) {
            if(s.totalProperty) {
	            this.getTotal = this.getJsonAccessor(s.totalProperty);
	        }
	        if(s.successProperty) {
	            this.getSuccess = this.getJsonAccessor(s.successProperty);
	        }

	        this.getRoot = s.root ? this.getJsonAccessor(s.root) : function(p){return  p;};
	        if (s.id) {
	        	var  g = this.getJsonAccessor(s.id);
	        	this.getId = function(N) {
	        		var  r = g(N);
		        	return  (r === undefined || r === "") ? null : r;
	        	};
	        } else  {
	        	this.getId = function(){return  null;};
	        }

            this.ef = [];
            for(var  i = 0; i < fl; i++){
                f = fi[i];
                var  map = (f.mapping !== undefined && f.mapping !== null) ? f.mapping : f.name;
                this.ef[i] = this.getJsonAccessor(map);
            }
        }

    	var  J = this.getRoot(o), c = J.length, K = c, L = true;
    	if(s.totalProperty){
            var  v = parseInt(this.getTotal(o), 10);
            if(!isNaN(v)){
                K = v;
            }
        }
        if(s.successProperty){
            var  v = this.getSuccess(o);
            if(v === false || v === 'false'){
                L = false;
            }
        }
        var  M = [];
	    for(var  i = 0; i < c; i++){
		    var  n = J[i];
	        var  values = {};
	        var  id = this.getId(n);
	        for(var  j = 0; j < fl; j++){
	            f = fi[j];
                var  v = this.ef[j](n);
                values[f.name] = f.convert((v !== undefined) ? v : f.defaultValue);
	        }
	        var  record = new  I(values, id);
	        record.json = n;
	        M[i] = record;
	    }
	    return  {
	        success : L,
	        records : M,
	        totalRecords : K
	    };
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.XmlReader
 * @extends Roo.data.DataReader
 * Data reader class to create an Array of {@link Roo.data.Record} objects from an XML document
 * based on mappings in a provided Roo.data.Record constructor.<br><br>
 * <p>
 * <em>Note that in order for the browser to parse a returned XML document, the Content-Type
 * header in the HTTP response must be set to "text/xml".</em>
 * <p>
 * Example code:
 * <pre><code>
var RecordDef = Roo.data.Record.create([
   {name: 'name', mapping: 'name'},     // "mapping" property not needed if it's the same as "name"
   {name: 'occupation'}                 // This field will use "occupation" as the mapping.
]);
var myReader = new Roo.data.XmlReader({
   totalRecords: "results", // The element which contains the total dataset size (optional)
   record: "row",           // The repeated element which contains row information
   id: "id"                 // The element within the row that provides an ID for the record (optional)
}, RecordDef);
</code></pre>
 * <p>
 * This would consume an XML file like this:
 * <pre><code>
&lt;?xml?>
&lt;dataset>
 &lt;results>2&lt;/results>
 &lt;row>
   &lt;id>1&lt;/id>
   &lt;name>Bill&lt;/name>
   &lt;occupation>Gardener&lt;/occupation>
 &lt;/row>
 &lt;row>
   &lt;id>2&lt;/id>
   &lt;name>Ben&lt;/name>
   &lt;occupation>Horticulturalist&lt;/occupation>
 &lt;/row>
&lt;/dataset>
</code></pre>
 * @cfg {String} totalRecords The DomQuery path from which to retrieve the total number of records
 * in the dataset. This is only needed if the whole dataset is not passed in one go, but is being
 * paged from the remote server.
 * @cfg {String} record The DomQuery path to the repeated element which contains record information.
 * @cfg {String} success The DomQuery path to the success attribute used by forms.
 * @cfg {String} id The DomQuery path relative from the record element to the element that contains
 * a record identifier value.
 * @constructor
 * Create a new XmlReader
 * @param {Object} meta Metadata configuration options
 * @param {Mixed} recordType The definition of the data record type to produce.  This can be either a valid
 * Record subclass created with {@link Roo.data.Record#create}, or an array of objects with which to call
 * Roo.data.Record.create.  See the {@link Roo.data.Record} class for more details.
 */
Roo.data.XmlReader = function(A, B){
    A = A || {};
    Roo.data.XmlReader.superclass.constructor.call(this, A, B||A.fields);
};
Roo.extend(Roo.data.XmlReader, Roo.data.DataReader, {
    /**
     * This method is only used by a DataProxy which has retrieved data from a remote server.
	 * @param {Object} response The XHR object which contains the parsed XML document.  The response is expected
	 * to contain a method called 'responseXML' that returns an XML document object.
     * @return {Object} records A data block which is used by an {@link Roo.data.Store} as
     * a cache of Roo.data.Records.
     */
    read : function(C){
        var  D = C.responseXML;
        if(!D) {
            throw  {message: "XmlReader.read: XML Document not available"};
        }
        return  this.readRecords(D);
    },

    /**
     * Create a data block containing Roo.data.Records from an XML document.
	 * @param {Object} doc A parsed XML document.
     * @return {Object} records A data block which is used by an {@link Roo.data.Store} as
     * a cache of Roo.data.Records.
     */
    readRecords : function(E){
        /**
         * After any data loads/reads, the raw XML Document is available for further custom processing.
         * @type XMLDocument
         */
        this.xmlData = E;
        var  F = E.documentElement || E;
    	var  q = Roo.DomQuery;
    	var  G = this.recordType, H = G.prototype.fields;
    	var  I = this.meta.id;
    	var  J = 0, K = true;
    	if(this.meta.totalRecords){
    	    J = q.selectNumber(this.meta.totalRecords, F, 0);
    	}
        
        if(this.meta.success){
            var  sv = q.selectValue(this.meta.success, F, true);
            K = sv !== false && sv !== 'false';
    	}
    	var  L = [];
    	var  ns = q.select(this.meta.record, F);
        for(var  i = 0, len = ns.length; i < len; i++) {
	        var  n = ns[i];
	        var  values = {};
	        var  id = I ? q.selectValue(I, n) : undefined;
	        for(var  j = 0, jlen = H.length; j < jlen; j++){
	            var  f = H.items[j];
                var  v = q.selectValue(f.mapping || f.name, n, f.defaultValue);
	            v = f.convert(v);
	            values[f.name] = v;
	        }
	        var  record = new  G(values, id);
	        record.node = n;
	        L[L.length] = record;
	    }

	    return  {
	        success : K,
	        records : L,
	        totalRecords : J || L.length
	    };
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.data.ArrayReader
 * @extends Roo.data.DataReader
 * Data reader class to create an Array of Roo.data.Record objects from an Array.
 * Each element of that Array represents a row of data fields. The
 * fields are pulled into a Record object using as a subscript, the <em>mapping</em> property
 * of the field definition if it exists, or the field's ordinal position in the definition.<br>
 * <p>
 * Example code:.
 * <pre><code>
var RecordDef = Roo.data.Record.create([
    {name: 'name', mapping: 1},         // "mapping" only needed if an "id" field is present which
    {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
]);
var myReader = new Roo.data.ArrayReader({
    id: 0                     // The subscript within row Array that provides an ID for the Record (optional)
}, RecordDef);
</code></pre>
 * <p>
 * This would consume an Array like this:
 * <pre><code>
[ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]
  </code></pre>
 * @cfg {String} id (optional) The subscript within row Array that provides an ID for the Record
 * @constructor
 * Create a new JsonReader
 * @param {Object} meta Metadata configuration options.
 * @param {Object} recordType Either an Array of field definition objects
 * as specified to {@link Roo.data.Record#create},
 * or an {@link Roo.data.Record} object
 * created using {@link Roo.data.Record#create}.
 */
Roo.data.ArrayReader = function(A, B){
    Roo.data.ArrayReader.superclass.constructor.call(this, A, B);
};

Roo.extend(Roo.data.ArrayReader, Roo.data.JsonReader, {
    /**
     * Create a data block containing Roo.data.Records from an XML document.
     * @param {Object} o An Array of row objects which represents the dataset.
     * @return {Object} data A data block which is used by an Roo.data.Store object as
     * a cache of Roo.data.Records.
     */
    readRecords : function(o){
        var  C = this.meta ? this.meta.id : null;
    	var  D = this.recordType, E = D.prototype.fields;
    	var  F = [];
    	var  G = o;
	    for(var  i = 0; i < G.length; i++){
		    var  n = G[i];
	        var  values = {};
	        var  id = ((C || C === 0) && n[C] !== undefined && n[C] !== "" ? n[C] : null);
	        for(var  j = 0, jlen = E.length; j < jlen; j++){
                var  f = E.items[j];
                var  k = f.mapping !== undefined && f.mapping !== null ? f.mapping : j;
                var  v = n[k] !== undefined ? n[k] : f.defaultValue;
                v = f.convert(v);
                values[f.name] = v;
            }
	        var  record = new  D(values, id);
	        record.json = n;
	        F[F.length] = record;
	    }
	    return  {
	        records : F,
	        totalRecords : F.length
	    };
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.data.Tree
 * @extends Roo.util.Observable
 * Represents a tree data structure and bubbles all the events for its nodes. The nodes
 * in the tree have most standard DOM functionality.
 * @constructor
 * @param {Node} root (optional) The root node
 */
Roo.data.Tree = function(A){
   this.nodeHash = {};
   /**
    * The root node for this tree
    * @type Node
    */
   this.root = null;
   if(A){
       this.setRootNode(A);
   }

   this.addEvents({
       /**
        * @event append
        * Fires when a new child node is appended to a node in this tree.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The newly appended node
        * @param {Number} index The index of the newly appended node
        */
       "append" : true,
       /**
        * @event remove
        * Fires when a child node is removed from a node in this tree.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The child node removed
        */
       "remove" : true,
       /**
        * @event move
        * Fires when a node is moved to a new location in the tree
        * @param {Tree} tree The owner tree
        * @param {Node} node The node moved
        * @param {Node} oldParent The old parent of this node
        * @param {Node} newParent The new parent of this node
        * @param {Number} index The index it was moved to
        */
       "move" : true,
       /**
        * @event insert
        * Fires when a new child node is inserted in a node in this tree.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The child node inserted
        * @param {Node} refNode The child node the node was inserted before
        */
       "insert" : true,
       /**
        * @event beforeappend
        * Fires before a new child is appended to a node in this tree, return false to cancel the append.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The child node to be appended
        */
       "beforeappend" : true,
       /**
        * @event beforeremove
        * Fires before a child is removed from a node in this tree, return false to cancel the remove.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The child node to be removed
        */
       "beforeremove" : true,
       /**
        * @event beforemove
        * Fires before a node is moved to a new location in the tree. Return false to cancel the move.
        * @param {Tree} tree The owner tree
        * @param {Node} node The node being moved
        * @param {Node} oldParent The parent of the node
        * @param {Node} newParent The new parent the node is moving to
        * @param {Number} index The index it is being moved to
        */
       "beforemove" : true,
       /**
        * @event beforeinsert
        * Fires before a new child is inserted in a node in this tree, return false to cancel the insert.
        * @param {Tree} tree The owner tree
        * @param {Node} parent The parent node
        * @param {Node} node The child node to be inserted
        * @param {Node} refNode The child node the node is being inserted before
        */
       "beforeinsert" : true
   });

    Roo.data.Tree.superclass.constructor.call(this);
};

Roo.extend(Roo.data.Tree, Roo.util.Observable, {
    pathSeparator: "/",

    proxyNodeEvent : function(){
        return  this.fireEvent.apply(this, arguments);
    },

    /**
     * Returns the root node for this tree.
     * @return {Node}
     */
    getRootNode : function(){
        return  this.root;
    },

    /**
     * Sets the root node for this tree.
     * @param {Node} node
     * @return {Node}
     */
    setRootNode : function(B){
        this.root = B;
        B.ownerTree = this;
        B.isRoot = true;
        this.registerNode(B);
        return  B;
    },

    /**
     * Gets a node in this tree by its id.
     * @param {String} id
     * @return {Node}
     */
    getNodeById : function(id){
        return  this.nodeHash[id];
    },

    registerNode : function(C){
        this.nodeHash[C.id] = C;
    },

    unregisterNode : function(D){
        delete  this.nodeHash[D.id];
    },

    toString : function(){
        return  "[Tree"+(this.id?" "+this.id:"")+"]";
    }
});

/**
 * @class Roo.data.Node
 * @extends Roo.util.Observable
 * @cfg {Boolean} leaf true if this node is a leaf and does not have children
 * @cfg {String} id The id for this node. If one is not specified, one is generated.
 * @constructor
 * @param {Object} attributes The attributes/config for the node
 */
Roo.data.Node = function(E){
    /**
     * The attributes supplied for the node. You can use this property to access any custom attributes you supplied.
     * @type {Object}
     */
    this.attributes = E || {};
    this.leaf = this.attributes.leaf;
    /**
     * The node id. @type String
     */
    this.id = this.attributes.id;
    if(!this.id){
        this.id = Roo.id(null, "ynode-");
        this.attributes.id = this.id;
    }

    /**
     * All child nodes of this node. @type Array
     */
    this.childNodes = [];
    if(!this.childNodes.indexOf){ // indexOf is a must
        this.childNodes.indexOf = function(o){
            for(var  i = 0, len = this.length; i < len; i++){
                if(this[i] == o) return  i;
            }
            return  -1;
        };
    }

    /**
     * The parent node for this node. @type Node
     */
    this.parentNode = null;
    /**
     * The first direct child node of this node, or null if this node has no child nodes. @type Node
     */
    this.firstChild = null;
    /**
     * The last direct child node of this node, or null if this node has no child nodes. @type Node
     */
    this.lastChild = null;
    /**
     * The node immediately preceding this node in the tree, or null if there is no sibling node. @type Node
     */
    this.previousSibling = null;
    /**
     * The node immediately following this node in the tree, or null if there is no sibling node. @type Node
     */
    this.nextSibling = null;

    this.addEvents({
       /**
        * @event append
        * Fires when a new child node is appended
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The newly appended node
        * @param {Number} index The index of the newly appended node
        */
       "append" : true,
       /**
        * @event remove
        * Fires when a child node is removed
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The removed node
        */
       "remove" : true,
       /**
        * @event move
        * Fires when this node is moved to a new location in the tree
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} oldParent The old parent of this node
        * @param {Node} newParent The new parent of this node
        * @param {Number} index The index it was moved to
        */
       "move" : true,
       /**
        * @event insert
        * Fires when a new child node is inserted.
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The child node inserted
        * @param {Node} refNode The child node the node was inserted before
        */
       "insert" : true,
       /**
        * @event beforeappend
        * Fires before a new child is appended, return false to cancel the append.
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The child node to be appended
        */
       "beforeappend" : true,
       /**
        * @event beforeremove
        * Fires before a child is removed, return false to cancel the remove.
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The child node to be removed
        */
       "beforeremove" : true,
       /**
        * @event beforemove
        * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} oldParent The parent of this node
        * @param {Node} newParent The new parent this node is moving to
        * @param {Number} index The index it is being moved to
        */
       "beforemove" : true,
       /**
        * @event beforeinsert
        * Fires before a new child is inserted, return false to cancel the insert.
        * @param {Tree} tree The owner tree
        * @param {Node} this This node
        * @param {Node} node The child node to be inserted
        * @param {Node} refNode The child node the node is being inserted before
        */
       "beforeinsert" : true
   });
    this.listeners = this.attributes.listeners;
    Roo.data.Node.superclass.constructor.call(this);
};

Roo.extend(Roo.data.Node, Roo.util.Observable, {
    fireEvent : function(F){
        // first do standard event for this node
        if(Roo.data.Node.superclass.fireEvent.apply(this, arguments) === false){
            return  false;
        }
        // then bubble it up to the tree if the event wasn't cancelled
        var  ot = this.getOwnerTree();
        if(ot){
            if(ot.proxyNodeEvent.apply(ot, arguments) === false){
                return  false;
            }
        }
        return  true;
    },

    /**
     * Returns true if this node is a leaf
     * @return {Boolean}
     */
    isLeaf : function(){
        return  this.leaf === true;
    },

    // private
    setFirstChild : function(G){
        this.firstChild = G;
    },

    //private
    setLastChild : function(H){
        this.lastChild = H;
    },


    /**
     * Returns true if this node is the last child of its parent
     * @return {Boolean}
     */
    isLast : function(){
       return  (!this.parentNode ? true : this.parentNode.lastChild == this);
    },

    /**
     * Returns true if this node is the first child of its parent
     * @return {Boolean}
     */
    isFirst : function(){
       return  (!this.parentNode ? true : this.parentNode.firstChild == this);
    },

    hasChildNodes : function(){
        return  !this.isLeaf() && this.childNodes.length > 0;
    },

    /**
     * Insert node(s) as the last child node of this node.
     * @param {Node/Array} node The node or Array of nodes to append
     * @return {Node} The appended node if single append, or null if an array was passed
     */
    appendChild : function(I){
        var  J = false;
        if(I  instanceof  Array){
            J = I;
        }else  if(arguments.length > 1){
            J = arguments;
        }
        // if passed an array or multiple args do them one by one
        if(J){
            for(var  i = 0, len = J.length; i < len; i++) {
            	this.appendChild(J[i]);
            }
        }else {
            if(this.fireEvent("beforeappend", this.ownerTree, this, I) === false){
                return  false;
            }
            var  index = this.childNodes.length;
            var  oldParent = I.parentNode;
            // it's a move, make sure we move it cleanly
            if(oldParent){
                if(I.fireEvent("beforemove", I.getOwnerTree(), I, oldParent, this, index) === false){
                    return  false;
                }

                oldParent.removeChild(I);
            }

            index = this.childNodes.length;
            if(index == 0){
                this.setFirstChild(I);
            }

            this.childNodes.push(I);
            I.parentNode = this;
            var  ps = this.childNodes[index-1];
            if(ps){
                I.previousSibling = ps;
                ps.nextSibling = I;
            }else {
                I.previousSibling = null;
            }

            I.nextSibling = null;
            this.setLastChild(I);
            I.setOwnerTree(this.getOwnerTree());
            this.fireEvent("append", this.ownerTree, this, I, index);
            if(oldParent){
                I.fireEvent("move", this.ownerTree, I, oldParent, this, index);
            }
            return  I;
        }
    },

    /**
     * Removes a child node from this node.
     * @param {Node} node The node to remove
     * @return {Node} The removed node
     */
    removeChild : function(K){
        var  L = this.childNodes.indexOf(K);
        if(L == -1){
            return  false;
        }
        if(this.fireEvent("beforeremove", this.ownerTree, this, K) === false){
            return  false;
        }


        // remove it from childNodes collection
        this.childNodes.splice(L, 1);

        // update siblings
        if(K.previousSibling){
            K.previousSibling.nextSibling = K.nextSibling;
        }
        if(K.nextSibling){
            K.nextSibling.previousSibling = K.previousSibling;
        }

        // update child refs
        if(this.firstChild == K){
            this.setFirstChild(K.nextSibling);
        }
        if(this.lastChild == K){
            this.setLastChild(K.previousSibling);
        }


        K.setOwnerTree(null);
        // clear any references from the node
        K.parentNode = null;
        K.previousSibling = null;
        K.nextSibling = null;
        this.fireEvent("remove", this.ownerTree, this, K);
        return  K;
    },

    /**
     * Inserts the first node before the second node in this nodes childNodes collection.
     * @param {Node} node The node to insert
     * @param {Node} refNode The node to insert before (if null the node is appended)
     * @return {Node} The inserted node
     */
    insertBefore : function(M, N){
        if(!N){ // like standard Dom, refNode can be null for append
            return  this.appendChild(M);
        }
        // nothing to do
        if(M == N){
            return  false;
        }

        if(this.fireEvent("beforeinsert", this.ownerTree, this, M, N) === false){
            return  false;
        }
        var  O = this.childNodes.indexOf(N);
        var  P = M.parentNode;
        var  Q = O;

        // when moving internally, indexes will change after remove
        if(P == this && this.childNodes.indexOf(M) < O){
            Q--;
        }

        // it's a move, make sure we move it cleanly
        if(P){
            if(M.fireEvent("beforemove", M.getOwnerTree(), M, P, this, O, N) === false){
                return  false;
            }

            P.removeChild(M);
        }
        if(Q == 0){
            this.setFirstChild(M);
        }

        this.childNodes.splice(Q, 0, M);
        M.parentNode = this;
        var  ps = this.childNodes[Q-1];
        if(ps){
            M.previousSibling = ps;
            ps.nextSibling = M;
        }else {
            M.previousSibling = null;
        }

        M.nextSibling = N;
        N.previousSibling = M;
        M.setOwnerTree(this.getOwnerTree());
        this.fireEvent("insert", this.ownerTree, this, M, N);
        if(P){
            M.fireEvent("move", this.ownerTree, M, P, this, Q, N);
        }
        return  M;
    },

    /**
     * Returns the child node at the specified index.
     * @param {Number} index
     * @return {Node}
     */
    item : function(R){
        return  this.childNodes[R];
    },

    /**
     * Replaces one child node in this node with another.
     * @param {Node} newChild The replacement node
     * @param {Node} oldChild The node to replace
     * @return {Node} The replaced node
     */
    replaceChild : function(S, T){
        this.insertBefore(S, T);
        this.removeChild(T);
        return  T;
    },

    /**
     * Returns the index of a child node
     * @param {Node} node
     * @return {Number} The index of the node or -1 if it was not found
     */
    indexOf : function(U){
        return  this.childNodes.indexOf(U);
    },

    /**
     * Returns the tree this node is in.
     * @return {Tree}
     */
    getOwnerTree : function(){
        // if it doesn't have one, look for one
        if(!this.ownerTree){
            var  p = this;
            while(p){
                if(p.ownerTree){
                    this.ownerTree = p.ownerTree;
                    break;
                }

                p = p.parentNode;
            }
        }
        return  this.ownerTree;
    },

    /**
     * Returns depth of this node (the root node has a depth of 0)
     * @return {Number}
     */
    getDepth : function(){
        var  V = 0;
        var  p = this;
        while(p.parentNode){
            ++V;
            p = p.parentNode;
        }
        return  V;
    },

    // private
    setOwnerTree : function(W){
        // if it's move, we need to update everyone
        if(W != this.ownerTree){
            if(this.ownerTree){
                this.ownerTree.unregisterNode(this);
            }

            this.ownerTree = W;
            var  cs = this.childNodes;
            for(var  i = 0, len = cs.length; i < len; i++) {
            	cs[i].setOwnerTree(W);
            }
            if(W){
                W.registerNode(this);
            }
        }
    },

    /**
     * Returns the path for this node. The path can be used to expand or select this node programmatically.
     * @param {String} attr (optional) The attr to use for the path (defaults to the node's id)
     * @return {String} The path
     */
    getPath : function(X){
        X = X || "id";
        var  p = this.parentNode;
        var  b = [this.attributes[X]];
        while(p){
            b.unshift(p.attributes[X]);
            p = p.parentNode;
        }
        var  Y = this.getOwnerTree().pathSeparator;
        return  Y + b.join(Y);
    },

    /**
     * Bubbles up the tree from this node, calling the specified function with each node. The scope (<i>this</i>) of
     * function call will be the scope provided or the current node. The arguments to the function
     * will be the args provided or the current node. If the function returns false at any point,
     * the bubble is stopped.
     * @param {Function} fn The function to call
     * @param {Object} scope (optional) The scope of the function (defaults to current node)
     * @param {Array} args (optional) The args to call the function with (default to passing the current node)
     */
    bubble : function(fn, Z, a){
        var  p = this;
        while(p){
            if(fn.call(Z || p, a || p) === false){
                break;
            }

            p = p.parentNode;
        }
    },

    /**
     * Cascades down the tree from this node, calling the specified function with each node. The scope (<i>this</i>) of
     * function call will be the scope provided or the current node. The arguments to the function
     * will be the args provided or the current node. If the function returns false at any point,
     * the cascade is stopped on that branch.
     * @param {Function} fn The function to call
     * @param {Object} scope (optional) The scope of the function (defaults to current node)
     * @param {Array} args (optional) The args to call the function with (default to passing the current node)
     */
    cascade : function(fn, c, d){
        if(fn.call(c || this, d || this) !== false){
            var  cs = this.childNodes;
            for(var  i = 0, len = cs.length; i < len; i++) {
            	cs[i].cascade(fn, c, d);
            }
        }
    },

    /**
     * Interates the child nodes of this node, calling the specified function with each node. The scope (<i>this</i>) of
     * function call will be the scope provided or the current node. The arguments to the function
     * will be the args provided or the current node. If the function returns false at any point,
     * the iteration stops.
     * @param {Function} fn The function to call
     * @param {Object} scope (optional) The scope of the function (defaults to current node)
     * @param {Array} args (optional) The args to call the function with (default to passing the current node)
     */
    eachChild : function(fn, e, f){
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++) {
        	if(fn.call(e || this, f || cs[i]) === false){
        	    break;
        	}
        }
    },

    /**
     * Finds the first child that has the attribute with the specified value.
     * @param {String} attribute The attribute name
     * @param {Mixed} value The value to search for
     * @return {Node} The found child or null if none was found
     */
    findChild : function(g, h){
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++) {
        	if(cs[i].attributes[g] == h){
        	    return  cs[i];
        	}
        }
        return  null;
    },

    /**
     * Finds the first child by a custom function. The child matches if the function passed
     * returns true.
     * @param {Function} fn
     * @param {Object} scope (optional)
     * @return {Node} The found child or null if none was found
     */
    findChildBy : function(fn, j){
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++) {
        	if(fn.call(j||cs[i], cs[i]) === true){
        	    return  cs[i];
        	}
        }
        return  null;
    },

    /**
     * Sorts this nodes children using the supplied sort function
     * @param {Function} fn
     * @param {Object} scope (optional)
     */
    sort : function(fn, k){
        var  cs = this.childNodes;
        var  l = cs.length;
        if(l > 0){
            var  sortFn = k ? function(){fn.apply(k, arguments);} : fn;
            cs.sort(sortFn);
            for(var  i = 0; i < l; i++){
                var  n = cs[i];
                n.previousSibling = cs[i-1];
                n.nextSibling = cs[i+1];
                if(i == 0){
                    this.setFirstChild(n);
                }
                if(i == l-1){
                    this.setLastChild(n);
                }
            }
        }
    },

    /**
     * Returns true if this node is an ancestor (at any point) of the passed node.
     * @param {Node} node
     * @return {Boolean}
     */
    contains : function(m){
        return  m.isAncestor(this);
    },

    /**
     * Returns true if the passed node is an ancestor (at any point) of this node.
     * @param {Node} node
     * @return {Boolean}
     */
    isAncestor : function(o){
        var  p = this.parentNode;
        while(p){
            if(p == o){
                return  true;
            }

            p = p.parentNode;
        }
        return  false;
    },

    toString : function(){
        return  "[Node"+(this.id?" "+this.id:"")+"]";
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.ComponentMgr
 * Provides a common registry of all components on a page so that they can be easily accessed by component id (see {@link Roo.getCmp}).
 * @singleton
 */
Roo.ComponentMgr = function(){
    var  A = new  Roo.util.MixedCollection();

    return  {
        /**
         * Registers a component.
         * @param {Roo.Component} c The component
         */
        register : function(c){
            A.add(c);
        },

        /**
         * Unregisters a component.
         * @param {Roo.Component} c The component
         */
        unregister : function(c){
            A.remove(c);
        },

        /**
         * Returns a component by id
         * @param {String} id The component id
         */
        get : function(id){
            return  A.get(id);
        },

        /**
         * Registers a function that will be called when a specified component is added to ComponentMgr
         * @param {String} id The component id
         * @param {Funtction} fn The callback function
         * @param {Object} scope The scope of the callback
         */
        onAvailable : function(id, fn, C){
            A.on("add", function(D, o){
                if(o.id == id){
                    fn.call(C || o, o);
                    A.un("add", fn, C);
                }
            });
        }
    };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.Component
 * @extends Roo.util.Observable
 * Base class for all major Roo components.  All subclasses of Component can automatically participate in the standard
 * Roo component lifecycle of creation, rendering and destruction.  They also have automatic support for basic hide/show
 * and enable/disable behavior.  Component allows any subclass to be lazy-rendered into any {@link Roo.Container} and
 * to be automatically registered with the {@link Roo.ComponentMgr} so that it can be referenced at any time via {@link Roo.getCmp}.
 * All visual components (widgets) that require rendering into a layout should subclass Component.
 * @constructor
 * @param {Roo.Element/String/Object} config The configuration options.  If an element is passed, it is set as the internal
 * element and its id used as the component id.  If a string is passed, it is assumed to be the id of an existing element
 * and is used as the component id.  Otherwise, it is assumed to be a standard config object and is applied to the component.
 */
Roo.Component = function(A){
    A = A || {};
    if(A.tagName || A.dom || typeof  A == "string"){ // element object
        A = {el: A, id: A.id || A};
    }

    this.initialConfig = A;

    Roo.apply(this, A);
    this.addEvents({
        /**
         * @event disable
         * Fires after the component is disabled.
	     * @param {Roo.Component} this
	     */
        disable : true,
        /**
         * @event enable
         * Fires after the component is enabled.
	     * @param {Roo.Component} this
	     */
        enable : true,
        /**
         * @event beforeshow
         * Fires before the component is shown.  Return false to stop the show.
	     * @param {Roo.Component} this
	     */
        beforeshow : true,
        /**
         * @event show
         * Fires after the component is shown.
	     * @param {Roo.Component} this
	     */
        show : true,
        /**
         * @event beforehide
         * Fires before the component is hidden. Return false to stop the hide.
	     * @param {Roo.Component} this
	     */
        beforehide : true,
        /**
         * @event hide
         * Fires after the component is hidden.
	     * @param {Roo.Component} this
	     */
        hide : true,
        /**
         * @event beforerender
         * Fires before the component is rendered. Return false to stop the render.
	     * @param {Roo.Component} this
	     */
        beforerender : true,
        /**
         * @event render
         * Fires after the component is rendered.
	     * @param {Roo.Component} this
	     */
        render : true,
        /**
         * @event beforedestroy
         * Fires before the component is destroyed. Return false to stop the destroy.
	     * @param {Roo.Component} this
	     */
        beforedestroy : true,
        /**
         * @event destroy
         * Fires after the component is destroyed.
	     * @param {Roo.Component} this
	     */
        destroy : true
    });
    if(!this.id){
        this.id = "ext-comp-" + (++Roo.Component.AUTO_ID);
    }

    Roo.ComponentMgr.register(this);
    Roo.Component.superclass.constructor.call(this);
    this.initComponent();
    if(this.renderTo){ // not supported by all components yet. use at your own risk!
        this.render(this.renderTo);
        delete  this.renderTo;
    }
};

// private
Roo.Component.AUTO_ID = 1000;

Roo.extend(Roo.Component, Roo.util.Observable, {
    /**
     * @property {Boolean} hidden
     * true if this component is hidden. Read-only.
     */
    hidden : false,
    /**
     * true if this component is disabled. Read-only.
     */
    disabled : false,
    /**
     * true if this component has been rendered. Read-only.
     */
    rendered : false,
    
    /** @cfg {String} disableClass
     * CSS class added to the component when it is disabled (defaults to "x-item-disabled").
     */
    disabledClass : "x-item-disabled",
	/** @cfg {Boolean} allowDomMove
	 * Whether the component can move the Dom node when rendering (defaults to true).
	 */
    allowDomMove : true,
    /** @cfg {String} hideMode
     * How this component should hidden. Supported values are
     * "visibility" (css visibility), "offsets" (negative offset position) and
     * "display" (css display) - defaults to "display".
     */
    hideMode: 'display',

    // private
    ctype : "Roo.Component",

    /** @cfg {String} actionMode 
     * which property holds the element that used for  hide() / show() / disable() / enable()
     * default is 'el' 
     */
    actionMode : "el",

    // private
    getActionEl : function(){
        return  this[this.actionMode];
    },

    initComponent : Roo.emptyFn,
    /**
     * If this is a lazy rendering component, render it to its container element.
     * @param {String/HTMLElement/Element} container (optional) The element this component should be rendered into. If it is being applied to existing markup, this should be left off.
     */
    render : function(B, C){
        if(!this.rendered && this.fireEvent("beforerender", this) !== false){
            if(!B && this.el){
                this.el = Roo.get(this.el);
                B = this.el.dom.parentNode;
                this.allowDomMove = false;
            }

            this.container = Roo.get(B);
            this.rendered = true;
            if(C !== undefined){
                if(typeof  C == 'number'){
                    C = this.container.dom.childNodes[C];
                }else {
                    C = Roo.getDom(C);
                }
            }

            this.onRender(this.container, C || null);
            if(this.cls){
                this.el.addClass(this.cls);
                delete  this.cls;
            }
            if(this.style){
                this.el.applyStyles(this.style);
                delete  this.style;
            }

            this.fireEvent("render", this);
            this.afterRender(this.container);
            if(this.hidden){
                this.hide();
            }
            if(this.disabled){
                this.disable();
            }
        }
        return  this;
    },

    // private
    // default function is not really useful
    onRender : function(ct, D){
        if(this.el){
            this.el = Roo.get(this.el);
            if(this.allowDomMove !== false){
                ct.dom.insertBefore(this.el.dom, D);
            }
        }
    },

    // private
    getAutoCreate : function(){
        var  E = typeof  this.autoCreate == "object" ?
                      this.autoCreate : Roo.apply({}, this.defaultAutoCreate);
        if(this.id && !E.id){
            E.id = this.id;
        }
        return  E;
    },

    // private
    afterRender : Roo.emptyFn,

    /**
     * Destroys this component by purging any event listeners, removing the component's element from the DOM,
     * removing the component from its {@link Roo.Container} (if applicable) and unregistering it from {@link Roo.ComponentMgr}.
     */
    destroy : function(){
        if(this.fireEvent("beforedestroy", this) !== false){
            this.purgeListeners();
            this.beforeDestroy();
            if(this.rendered){
                this.el.removeAllListeners();
                this.el.remove();
                if(this.actionMode == "container"){
                    this.container.remove();
                }
            }

            this.onDestroy();
            Roo.ComponentMgr.unregister(this);
            this.fireEvent("destroy", this);
        }
    },

	// private
    beforeDestroy : function(){

    },

	// private
	onDestroy : function(){

    },

    /**
     * Returns the underlying {@link Roo.Element}.
     * @return {Roo.Element} The element
     */
    getEl : function(){
        return  this.el;
    },

    /**
     * Returns the id of this component.
     * @return {String}
     */
    getId : function(){
        return  this.id;
    },

    /**
     * Try to focus this component.
     * @param {Boolean} selectText True to also select the text in this component (if applicable)
     * @return {Roo.Component} this
     */
    focus : function(F){
        if(this.rendered){
            this.el.focus();
            if(F === true){
                this.el.dom.select();
            }
        }
        return  this;
    },

    // private
    blur : function(){
        if(this.rendered){
            this.el.blur();
        }
        return  this;
    },

    /**
     * Disable this component.
     * @return {Roo.Component} this
     */
    disable : function(){
        if(this.rendered){
            this.onDisable();
        }

        this.disabled = true;
        this.fireEvent("disable", this);
        return  this;
    },

	// private
    onDisable : function(){
        this.getActionEl().addClass(this.disabledClass);
        this.el.dom.disabled = true;
    },

    /**
     * Enable this component.
     * @return {Roo.Component} this
     */
    enable : function(){
        if(this.rendered){
            this.onEnable();
        }

        this.disabled = false;
        this.fireEvent("enable", this);
        return  this;
    },

	// private
    onEnable : function(){
        this.getActionEl().removeClass(this.disabledClass);
        this.el.dom.disabled = false;
    },

    /**
     * Convenience function for setting disabled/enabled by boolean.
     * @param {Boolean} disabled
     */
    setDisabled : function(G){
        this[G ? "disable" : "enable"]();
    },

    /**
     * Show this component.
     * @return {Roo.Component} this
     */
    show: function(){
        if(this.fireEvent("beforeshow", this) !== false){
            this.hidden = false;
            if(this.rendered){
                this.onShow();
            }

            this.fireEvent("show", this);
        }
        return  this;
    },

    // private
    onShow : function(){
        var  ae = this.getActionEl();
        if(this.hideMode == 'visibility'){
            ae.dom.style.visibility = "visible";
        }else  if(this.hideMode == 'offsets'){
            ae.removeClass('x-hidden');
        }else {
            ae.dom.style.display = "";
        }
    },

    /**
     * Hide this component.
     * @return {Roo.Component} this
     */
    hide: function(){
        if(this.fireEvent("beforehide", this) !== false){
            this.hidden = true;
            if(this.rendered){
                this.onHide();
            }

            this.fireEvent("hide", this);
        }
        return  this;
    },

    // private
    onHide : function(){
        var  ae = this.getActionEl();
        if(this.hideMode == 'visibility'){
            ae.dom.style.visibility = "hidden";
        }else  if(this.hideMode == 'offsets'){
            ae.addClass('x-hidden');
        }else {
            ae.dom.style.display = "none";
        }
    },

    /**
     * Convenience function to hide or show this component by boolean.
     * @param {Boolean} visible True to show, false to hide
     * @return {Roo.Component} this
     */
    setVisible: function(H){
        if(H) {
            this.show();
        }else {
            this.hide();
        }
        return  this;
    },

    /**
     * Returns true if this component is visible.
     */
    isVisible : function(){
        return  this.getActionEl().isVisible();
    },

    cloneConfig : function(I){
        I = I || {};
        var  id = I.id || Roo.id();
        var  J = Roo.applyIf(I, this.initialConfig);
        J.id = id; // prevent dup id
        return  new  this.constructor(J);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 (function(){ 
/**
 * @class Roo.Layer
 * @extends Roo.Element
 * An extended {@link Roo.Element} object that supports a shadow and shim, constrain to viewport and
 * automatic maintaining of shadow/shim positions.
 * @cfg {Boolean} shim False to disable the iframe shim in browsers which need one (defaults to true)
 * @cfg {String/Boolean} shadow True to create a shadow element with default class "x-layer-shadow", or
 * you can pass a string with a CSS class name. False turns off the shadow.
 * @cfg {Object} dh DomHelper object config to create element with (defaults to {tag: "div", cls: "x-layer"}).
 * @cfg {Boolean} constrain False to disable constrain to viewport (defaults to true)
 * @cfg {String} cls CSS class to add to the element
 * @cfg {Number} zindex Starting z-index (defaults to 11000)
 * @cfg {Number} shadowOffset Number of pixels to offset the shadow (defaults to 3)
 * @constructor
 * @param {Object} config An object with config options.
 * @param {String/HTMLElement} existingEl (optional) Uses an existing DOM element. If the element is not found it creates it.
 */

Roo.Layer = function(C, D){
    C = C || {};
    var  dh = Roo.DomHelper;
    var  cp = C.parentEl, E = cp ? Roo.getDom(cp) : document.body;
    if(D){
        this.dom = Roo.getDom(D);
    }
    if(!this.dom){
        var  o = C.dh || {tag: "div", cls: "x-layer"};
        this.dom = dh.append(E, o);
    }
    if(C.cls){
        this.addClass(C.cls);
    }

    this.constrain = C.constrain !== false;
    this.visibilityMode = Roo.Element.VISIBILITY;
    if(C.id){
        this.id = this.dom.id = C.id;
    }else {
        this.id = Roo.id(this.dom);
    }

    this.zindex = C.zindex || this.getZIndex();
    this.position("absolute", this.zindex);
    if(C.shadow){
        this.shadowOffset = C.shadowOffset || 4;
        this.shadow = new  Roo.Shadow({
            offset : this.shadowOffset,
            mode : C.shadow
        });
    }else {
        this.shadowOffset = 0;
    }

    this.useShim = C.shim !== false && Roo.useShims;
    this.useDisplay = C.useDisplay;
    this.hide();
};

var  A = Roo.Element.prototype;

// shims are shared among layer to keep from having 100 iframes
var  B = [];

Roo.extend(Roo.Layer, Roo.Element, {

    getZIndex : function(){
        return  this.zindex || parseInt(this.getStyle("z-index"), 10) || 11000;
    },

    getShim : function(){
        if(!this.useShim){
            return  null;
        }
        if(this.shim){
            return  this.shim;
        }
        var  C = B.shift();
        if(!C){
            C = this.createShim();
            C.enableDisplayMode('block');
            C.dom.style.display = 'none';
            C.dom.style.visibility = 'visible';
        }
        var  pn = this.dom.parentNode;
        if(C.dom.parentNode != pn){
            pn.insertBefore(C.dom, this.dom);
        }

        C.setStyle('z-index', this.getZIndex()-2);
        this.shim = C;
        return  C;
    },

    hideShim : function(){
        if(this.shim){
            this.shim.setDisplayed(false);
            B.push(this.shim);
            delete  this.shim;
        }
    },

    disableShadow : function(){
        if(this.shadow){
            this.shadowDisabled = true;
            this.shadow.hide();
            this.lastShadowOffset = this.shadowOffset;
            this.shadowOffset = 0;
        }
    },

    enableShadow : function(D){
        if(this.shadow){
            this.shadowDisabled = false;
            this.shadowOffset = this.lastShadowOffset;
            delete  this.lastShadowOffset;
            if(D){
                this.sync(true);
            }
        }
    },

    // private
    // this code can execute repeatedly in milliseconds (i.e. during a drag) so
    // code size was sacrificed for effeciency (e.g. no getBox/setBox, no XY calls)
    sync : function(E){
        var  sw = this.shadow;
        if(!this.updating && this.isVisible() && (sw || this.useShim)){
            var  sh = this.getShim();

            var  w = this.getWidth(),
                h = this.getHeight();

            var  l = this.getLeft(true),
                t = this.getTop(true);

            if(sw && !this.shadowDisabled){
                if(E && !sw.isVisible()){
                    sw.show(this);
                }else {
                    sw.realign(l, t, w, h);
                }
                if(sh){
                    if(E){
                       sh.show();
                    }
                    // fit the shim behind the shadow, so it is shimmed too
                    var  a = sw.adjusts, s = sh.dom.style;
                    s.left = (Math.min(l, l+a.l))+"px";
                    s.top = (Math.min(t, t+a.t))+"px";
                    s.width = (w+a.w)+"px";
                    s.height = (h+a.h)+"px";
                }
            }else  if(sh){
                if(E){
                   sh.show();
                }

                sh.setSize(w, h);
                sh.setLeftTop(l, t);
            }
            
        }
    },

    // private
    destroy : function(){
        this.hideShim();
        if(this.shadow){
            this.shadow.hide();
        }

        this.removeAllListeners();
        var  pn = this.dom.parentNode;
        if(pn){
            pn.removeChild(this.dom);
        }

        Roo.Element.uncache(this.id);
    },

    remove : function(){
        this.destroy();
    },

    // private
    beginUpdate : function(){
        this.updating = true;
    },

    // private
    endUpdate : function(){
        this.updating = false;
        this.sync(true);
    },

    // private
    hideUnders : function(F){
        if(this.shadow){
            this.shadow.hide();
        }

        this.hideShim();
    },

    // private
    constrainXY : function(){
        if(this.constrain){
            var  vw = Roo.lib.Dom.getViewWidth(),
                vh = Roo.lib.Dom.getViewHeight();
            var  s = Roo.get(document).getScroll();

            var  xy = this.getXY();
            var  x = xy[0], y = xy[1];   
            var  w = this.dom.offsetWidth+this.shadowOffset, h = this.dom.offsetHeight+this.shadowOffset;
            // only move it if it needs it
            var  moved = false;
            // first validate right/bottom
            if((x + w) > vw+s.left){
                x = vw - w - this.shadowOffset;
                moved = true;
            }
            if((y + h) > vh+s.top){
                y = vh - h - this.shadowOffset;
                moved = true;
            }
            // then make sure top/left isn't negative
            if(x < s.left){
                x = s.left;
                moved = true;
            }
            if(y < s.top){
                y = s.top;
                moved = true;
            }
            if(moved){
                if(this.avoidY){
                    var  ay = this.avoidY;
                    if(y <= ay && (y+h) >= ay){
                        y = ay-h-5;   
                    }
                }

                xy = [x, y];
                this.storeXY(xy);
                A.setXY.call(this, xy);
                this.sync();
            }
        }
    },

    isVisible : function(){
        return  this.visible;    
    },

    // private
    showAction : function(){
        this.visible = true; // track visibility to prevent getStyle calls
        if(this.useDisplay === true){
            this.setDisplayed("");
        }else  if(this.lastXY){
            A.setXY.call(this, this.lastXY);
        }else  if(this.lastLT){
            A.setLeftTop.call(this, this.lastLT[0], this.lastLT[1]);
        }
    },

    // private
    hideAction : function(){
        this.visible = false;
        if(this.useDisplay === true){
            this.setDisplayed(false);
        }else {
            this.setLeftTop(-10000,-10000);
        }
    },

    // overridden Element method
    setVisible : function(v, a, d, c, e){
        if(v){
            this.showAction();
        }
        if(a && v){
            var  cb = function(){
                this.sync(true);
                if(c){
                    c();
                }
            }.createDelegate(this);
            A.setVisible.call(this, true, true, d, cb, e);
        }else {
            if(!v){
                this.hideUnders(true);
            }
            var  cb = c;
            if(a){
                cb = function(){
                    this.hideAction();
                    if(c){
                        c();
                    }
                }.createDelegate(this);
            }

            A.setVisible.call(this, v, a, d, cb, e);
            if(v){
                this.sync(true);
            }else  if(!a){
                this.hideAction();
            }
        }
    },

    storeXY : function(xy){
        delete  this.lastLT;
        this.lastXY = xy;
    },

    storeLeftTop : function(G, H){
        delete  this.lastXY;
        this.lastLT = [G, H];
    },

    // private
    beforeFx : function(){
        this.beforeAction();
        return  Roo.Layer.superclass.beforeFx.apply(this, arguments);
    },

    // private
    afterFx : function(){
        Roo.Layer.superclass.afterFx.apply(this, arguments);
        this.sync(this.isVisible());
    },

    // private
    beforeAction : function(){
        if(!this.updating && this.shadow){
            this.shadow.hide();
        }
    },

    // overridden Element method
    setLeft : function(I){
        this.storeLeftTop(I, this.getTop(true));
        A.setLeft.apply(this, arguments);
        this.sync();
    },

    setTop : function(J){
        this.storeLeftTop(this.getLeft(true), J);
        A.setTop.apply(this, arguments);
        this.sync();
    },

    setLeftTop : function(K, L){
        this.storeLeftTop(K, L);
        A.setLeftTop.apply(this, arguments);
        this.sync();
    },

    setXY : function(xy, a, d, c, e){
        this.fixDisplay();
        this.beforeAction();
        this.storeXY(xy);
        var  cb = this.createCB(c);
        A.setXY.call(this, xy, a, d, cb, e);
        if(!a){
            cb();
        }
    },

    // private
    createCB : function(c){
        var  el = this;
        return  function(){
            el.constrainXY();
            el.sync(true);
            if(c){
                c();
            }
        };
    },

    // overridden Element method
    setX : function(x, a, d, c, e){
        this.setXY([x, this.getY()], a, d, c, e);
    },

    // overridden Element method
    setY : function(y, a, d, c, e){
        this.setXY([this.getX(), y], a, d, c, e);
    },

    // overridden Element method
    setSize : function(w, h, a, d, c, e){
        this.beforeAction();
        var  cb = this.createCB(c);
        A.setSize.call(this, w, h, a, d, cb, e);
        if(!a){
            cb();
        }
    },

    // overridden Element method
    setWidth : function(w, a, d, c, e){
        this.beforeAction();
        var  cb = this.createCB(c);
        A.setWidth.call(this, w, a, d, cb, e);
        if(!a){
            cb();
        }
    },

    // overridden Element method
    setHeight : function(h, a, d, c, e){
        this.beforeAction();
        var  cb = this.createCB(c);
        A.setHeight.call(this, h, a, d, cb, e);
        if(!a){
            cb();
        }
    },

    // overridden Element method
    setBounds : function(x, y, w, h, a, d, c, e){
        this.beforeAction();
        var  cb = this.createCB(c);
        if(!a){
            this.storeXY([x, y]);
            A.setXY.call(this, [x, y]);
            A.setSize.call(this, w, h, a, d, cb, e);
            cb();
        }else {
            A.setBounds.call(this, x, y, w, h, a, d, cb, e);
        }
        return  this;
    },
    
    /**
     * Sets the z-index of this layer and adjusts any shadow and shim z-indexes. The layer z-index is automatically
     * incremented by two more than the value passed in so that it always shows above any shadow or shim (the shadow
     * element, if any, will be assigned z-index + 1, and the shim element, if any, will be assigned the unmodified z-index).
     * @param {Number} zindex The new z-index to set
     * @return {this} The Layer
     */
    setZIndex : function(M){
        this.zindex = M;
        this.setStyle("z-index", M + 2);
        if(this.shadow){
            this.shadow.setZIndex(M + 1);
        }
        if(this.shim){
            this.shim.setStyle("z-index", M);
        }
    }
});
})();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.Shadow
 * Simple class that can provide a shadow effect for any element.  Note that the element MUST be absolutely positioned,
 * and the shadow does not provide any shimming.  This should be used only in simple cases -- for more advanced
 * functionality that can also provide the same shadow effect, see the {@link Roo.Layer} class.
 * @constructor
 * Create a new Shadow
 * @param {Object} config The config object
 */
Roo.Shadow = function(A){
    Roo.apply(this, A);
    if(typeof  this.mode != "string"){
        this.mode = this.defaultMode;
    }
    var  o = this.offset, a = {h: 0};
    var  B = Math.floor(this.offset/2);
    switch(this.mode.toLowerCase()){ // all this hideous nonsense calculates the various offsets for shadows
        case  "drop":
            a.w = 0;
            a.l = a.t = o;
            a.t -= 1;
            if(Roo.isIE){
                a.l -= this.offset + B;
                a.t -= this.offset + B;
                a.w -= B;
                a.h -= B;
                a.t += 1;
            }
        break;
        case  "sides":
            a.w = (o*2);
            a.l = -o;
            a.t = o-1;
            if(Roo.isIE){
                a.l -= (this.offset - B);
                a.t -= this.offset + B;
                a.l += 1;
                a.w -= (this.offset - B)*2;
                a.w -= B + 1;
                a.h -= 1;
            }
        break;
        case  "frame":
            a.w = a.h = (o*2);
            a.l = a.t = -o;
            a.t += 1;
            a.h -= 2;
            if(Roo.isIE){
                a.l -= (this.offset - B);
                a.t -= (this.offset - B);
                a.l += 1;
                a.w -= (this.offset + B + 1);
                a.h -= (this.offset + B);
                a.h += 1;
            }
        break;
    };

    this.adjusts = a;
};

Roo.Shadow.prototype = {
    /**
     * @cfg {String} mode
     * The shadow display mode.  Supports the following options:<br />
     * sides: Shadow displays on both sides and bottom only<br />
     * frame: Shadow displays equally on all four sides<br />
     * drop: Traditional bottom-right drop shadow (default)
     */
    /**
     * @cfg {String} offset
     * The number of pixels to offset the shadow from the element (defaults to 4)
     */
    offset: 4,

    // private
    defaultMode: "drop",

    /**
     * Displays the shadow under the target element
     * @param {String/HTMLElement/Element} targetEl The id or element under which the shadow should display
     */
    show : function(C){
        C = Roo.get(C);
        if(!this.el){
            this.el = Roo.Shadow.Pool.pull();
            if(this.el.dom.nextSibling != C.dom){
                this.el.insertBefore(C);
            }
        }

        this.el.setStyle("z-index", this.zIndex || parseInt(C.getStyle("z-index"), 10)-1);
        if(Roo.isIE){
            this.el.dom.style.filter="progid:DXImageTransform.Microsoft.alpha(opacity=50) progid:DXImageTransform.Microsoft.Blur(pixelradius="+(this.offset)+")";
        }

        this.realign(
            C.getLeft(true),
            C.getTop(true),
            C.getWidth(),
            C.getHeight()
        );
        this.el.dom.style.display = "block";
    },

    /**
     * Returns true if the shadow is visible, else false
     */
    isVisible : function(){
        return  this.el ? true : false;  
    },

    /**
     * Direct alignment when values are already available. Show must be called at least once before
     * calling this method to ensure it is initialized.
     * @param {Number} left The target element left position
     * @param {Number} top The target element top position
     * @param {Number} width The target element width
     * @param {Number} height The target element height
     */
    realign : function(l, t, w, h){
        if(!this.el){
            return;
        }
        var  a = this.adjusts, d = this.el.dom, s = d.style;
        var  D = 0;
        s.left = (l+a.l)+"px";
        s.top = (t+a.t)+"px";
        var  sw = (w+a.w), sh = (h+a.h), E = sw +"px", F = sh + "px";
        if(s.width != E || s.height != F){
            s.width = E;
            s.height = F;
            if(!Roo.isIE){
                var  cn = d.childNodes;
                var  sww = Math.max(0, (sw-12))+"px";
                cn[0].childNodes[1].style.width = sww;
                cn[1].childNodes[1].style.width = sww;
                cn[2].childNodes[1].style.width = sww;
                cn[1].style.height = Math.max(0, (sh-12))+"px";
            }
        }
    },

    /**
     * Hides this shadow
     */
    hide : function(){
        if(this.el){
            this.el.dom.style.display = "none";
            Roo.Shadow.Pool.push(this.el);
            delete  this.el;
        }
    },

    /**
     * Adjust the z-index of this shadow
     * @param {Number} zindex The new z-index
     */
    setZIndex : function(z){
        this.zIndex = z;
        if(this.el){
            this.el.setStyle("z-index", z);
        }
    }
};

// Private utility class that manages the internal Shadow cache
Roo.Shadow.Pool = function(){
    var  p = [];
    var  G = Roo.isIE ?
                 '<div class="x-ie-shadow"></div>' :
                 '<div class="x-shadow"><div class="xst"><div class="xstl"></div><div class="xstc"></div><div class="xstr"></div></div><div class="xsc"><div class="xsml"></div><div class="xsmc"></div><div class="xsmr"></div></div><div class="xsb"><div class="xsbl"></div><div class="xsbc"></div><div class="xsbr"></div></div></div>';
    return  {
        pull : function(){
            var  sh = p.shift();
            if(!sh){
                sh = Roo.get(Roo.DomHelper.insertHtml("beforeBegin", document.body.firstChild, G));
                sh.autoBoxAdjust = false;
            }
            return  sh;
        },

        push : function(sh){
            p.push(sh);
        }
    };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.BoxComponent
 * @extends Roo.Component
 * Base class for any visual {@link Roo.Component} that uses a box container.  BoxComponent provides automatic box
 * model adjustments for sizing and positioning and will work correctly withnin the Component rendering model.  All
 * container classes should subclass BoxComponent so that they will work consistently when nested within other Ext
 * layout containers.
 * @constructor
 * @param {Roo.Element/String/Object} config The configuration options.
 */
Roo.BoxComponent = function(A){
    Roo.Component.call(this, A);
    this.addEvents({
        /**
         * @event resize
         * Fires after the component is resized.
	     * @param {Roo.Component} this
	     * @param {Number} adjWidth The box-adjusted width that was set
	     * @param {Number} adjHeight The box-adjusted height that was set
	     * @param {Number} rawWidth The width that was originally specified
	     * @param {Number} rawHeight The height that was originally specified
	     */
        resize : true,
        /**
         * @event move
         * Fires after the component is moved.
	     * @param {Roo.Component} this
	     * @param {Number} x The new x position
	     * @param {Number} y The new y position
	     */
        move : true
    });
};

Roo.extend(Roo.BoxComponent, Roo.Component, {
    // private, set in afterRender to signify that the component has been rendered
    boxReady : false,
    // private, used to defer height settings to subclasses
    deferHeight: false,
    /** @cfg {Number} width
     * width (optional) size of component
     */
     /** @cfg {Number} height
     * height (optional) size of component
     */
     
    /**
     * Sets the width and height of the component.  This method fires the resize event.  This method can accept
     * either width and height as separate numeric arguments, or you can pass a size object like {width:10, height:20}.
     * @param {Number/Object} width The new width to set, or a size object in the format {width, height}
     * @param {Number} height The new height to set (not required if a size object is passed as the first arg)
     * @return {Roo.BoxComponent} this
     */
    setSize : function(w, h){
        // support for standard size objects
        if(typeof  w == 'object'){
            h = w.height;
            w = w.width;
        }
        // not rendered
        if(!this.boxReady){
            this.width = w;
            this.height = h;
            return  this;
        }

        // prevent recalcs when not needed
        if(this.lastSize && this.lastSize.width == w && this.lastSize.height == h){
            return  this;
        }

        this.lastSize = {width: w, height: h};

        var  B = this.adjustSize(w, h);
        var  aw = B.width, ah = B.height;
        if(aw !== undefined || ah !== undefined){ // this code is nasty but performs better with floaters
            var  rz = this.getResizeEl();
            if(!this.deferHeight && aw !== undefined && ah !== undefined){
                rz.setSize(aw, ah);
            }else  if(!this.deferHeight && ah !== undefined){
                rz.setHeight(ah);
            }else  if(aw !== undefined){
                rz.setWidth(aw);
            }

            this.onResize(aw, ah, w, h);
            this.fireEvent('resize', this, aw, ah, w, h);
        }
        return  this;
    },

    /**
     * Gets the current size of the component's underlying element.
     * @return {Object} An object containing the element's size {width: (element width), height: (element height)}
     */
    getSize : function(){
        return  this.el.getSize();
    },

    /**
     * Gets the current XY position of the component's underlying element.
     * @param {Boolean} local (optional) If true the element's left and top are returned instead of page XY (defaults to false)
     * @return {Array} The XY position of the element (e.g., [100, 200])
     */
    getPosition : function(C){
        if(C === true){
            return  [this.el.getLeft(true), this.el.getTop(true)];
        }
        return  this.xy || this.el.getXY();
    },

    /**
     * Gets the current box measurements of the component's underlying element.
     * @param {Boolean} local (optional) If true the element's left and top are returned instead of page XY (defaults to false)
     * @returns {Object} box An object in the format {x, y, width, height}
     */
    getBox : function(D){
        var  s = this.el.getSize();
        if(D){
            s.x = this.el.getLeft(true);
            s.y = this.el.getTop(true);
        }else {
            var  xy = this.xy || this.el.getXY();
            s.x = xy[0];
            s.y = xy[1];
        }
        return  s;
    },

    /**
     * Sets the current box measurements of the component's underlying element.
     * @param {Object} box An object in the format {x, y, width, height}
     * @returns {Roo.BoxComponent} this
     */
    updateBox : function(E){
        this.setSize(E.width, E.height);
        this.setPagePosition(E.x, E.y);
        return  this;
    },

    // protected
    getResizeEl : function(){
        return  this.resizeEl || this.el;
    },

    // protected
    getPositionEl : function(){
        return  this.positionEl || this.el;
    },

    /**
     * Sets the left and top of the component.  To set the page XY position instead, use {@link #setPagePosition}.
     * This method fires the move event.
     * @param {Number} left The new left
     * @param {Number} top The new top
     * @returns {Roo.BoxComponent} this
     */
    setPosition : function(x, y){
        this.x = x;
        this.y = y;
        if(!this.boxReady){
            return  this;
        }
        var  F = this.adjustPosition(x, y);
        var  ax = F.x, ay = F.y;

        var  el = this.getPositionEl();
        if(ax !== undefined || ay !== undefined){
            if(ax !== undefined && ay !== undefined){
                el.setLeftTop(ax, ay);
            }else  if(ax !== undefined){
                el.setLeft(ax);
            }else  if(ay !== undefined){
                el.setTop(ay);
            }

            this.onPosition(ax, ay);
            this.fireEvent('move', this, ax, ay);
        }
        return  this;
    },

    /**
     * Sets the page XY position of the component.  To set the left and top instead, use {@link #setPosition}.
     * This method fires the move event.
     * @param {Number} x The new x position
     * @param {Number} y The new y position
     * @returns {Roo.BoxComponent} this
     */
    setPagePosition : function(x, y){
        this.pageX = x;
        this.pageY = y;
        if(!this.boxReady){
            return;
        }
        if(x === undefined || y === undefined){ // cannot translate undefined points
            return;
        }
        var  p = this.el.translatePoints(x, y);
        this.setPosition(p.left, p.top);
        return  this;
    },

    // private
    onRender : function(ct, G){
        Roo.BoxComponent.superclass.onRender.call(this, ct, G);
        if(this.resizeEl){
            this.resizeEl = Roo.get(this.resizeEl);
        }
        if(this.positionEl){
            this.positionEl = Roo.get(this.positionEl);
        }
    },

    // private
    afterRender : function(){
        Roo.BoxComponent.superclass.afterRender.call(this);
        this.boxReady = true;
        this.setSize(this.width, this.height);
        if(this.x || this.y){
            this.setPosition(this.x, this.y);
        }
        if(this.pageX || this.pageY){
            this.setPagePosition(this.pageX, this.pageY);
        }
    },

    /**
     * Force the component's size to recalculate based on the underlying element's current height and width.
     * @returns {Roo.BoxComponent} this
     */
    syncSize : function(){
        delete  this.lastSize;
        this.setSize(this.el.getWidth(), this.el.getHeight());
        return  this;
    },

    /**
     * Called after the component is resized, this method is empty by default but can be implemented by any
     * subclass that needs to perform custom logic after a resize occurs.
     * @param {Number} adjWidth The box-adjusted width that was set
     * @param {Number} adjHeight The box-adjusted height that was set
     * @param {Number} rawWidth The width that was originally specified
     * @param {Number} rawHeight The height that was originally specified
     */
    onResize : function(H, I, J, K){

    },

    /**
     * Called after the component is moved, this method is empty by default but can be implemented by any
     * subclass that needs to perform custom logic after a move occurs.
     * @param {Number} x The new x position
     * @param {Number} y The new y position
     */
    onPosition : function(x, y){

    },

    // private
    adjustSize : function(w, h){
        if(this.autoWidth){
            w = 'auto';
        }
        if(this.autoHeight){
            h = 'auto';
        }
        return  {width : w, height: h};
    },

    // private
    adjustPosition : function(x, y){
        return  {x : x, y: y};
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


/**
 * @class Roo.SplitBar
 * @extends Roo.util.Observable
 * Creates draggable splitter bar functionality from two elements (element to be dragged and element to be resized).
 * <br><br>
 * Usage:
 * <pre><code>
var split = new Roo.SplitBar("elementToDrag", "elementToSize",
                   Roo.SplitBar.HORIZONTAL, Roo.SplitBar.LEFT);
split.setAdapter(new Roo.SplitBar.AbsoluteLayoutAdapter("container"));
split.minSize = 100;
split.maxSize = 600;
split.animate = true;
split.on('moved', splitterMoved);
</code></pre>
 * @constructor
 * Create a new SplitBar
 * @param {String/HTMLElement/Roo.Element} dragElement The element to be dragged and act as the SplitBar. 
 * @param {String/HTMLElement/Roo.Element} resizingElement The element to be resized based on where the SplitBar element is dragged 
 * @param {Number} orientation (optional) Either Roo.SplitBar.HORIZONTAL or Roo.SplitBar.VERTICAL. (Defaults to HORIZONTAL)
 * @param {Number} placement (optional) Either Roo.SplitBar.LEFT or Roo.SplitBar.RIGHT for horizontal or  
                        Roo.SplitBar.TOP or Roo.SplitBar.BOTTOM for vertical. (By default, this is determined automatically by the initial
                        position of the SplitBar).
 */
Roo.SplitBar = function(A, B, C, D, E){
    
    /** @private */
    this.el = Roo.get(A, true);
    this.el.dom.unselectable = "on";
    /** @private */
    this.resizingEl = Roo.get(B, true);

    /**
     * @private
     * The orientation of the split. Either Roo.SplitBar.HORIZONTAL or Roo.SplitBar.VERTICAL. (Defaults to HORIZONTAL)
     * Note: If this is changed after creating the SplitBar, the placement property must be manually updated
     * @type Number
     */
    this.orientation = C || Roo.SplitBar.HORIZONTAL;
    
    /**
     * The minimum size of the resizing element. (Defaults to 0)
     * @type Number
     */
    this.minSize = 0;
    
    /**
     * The maximum size of the resizing element. (Defaults to 2000)
     * @type Number
     */
    this.maxSize = 2000;
    
    /**
     * Whether to animate the transition to the new size
     * @type Boolean
     */
    this.animate = false;
    
    /**
     * Whether to create a transparent shim that overlays the page when dragging, enables dragging across iframes.
     * @type Boolean
     */
    this.useShim = false;
    
    /** @private */
    this.shim = null;
    
    if(!E){
        /** @private */
        this.proxy = Roo.SplitBar.createProxy(this.orientation);
    }else {
        this.proxy = Roo.get(E).dom;
    }

    /** @private */
    this.dd = new  Roo.dd.DDProxy(this.el.dom.id, "XSplitBars", {dragElId : this.proxy.id});
    
    /** @private */
    this.dd.b4StartDrag = this.onStartProxyDrag.createDelegate(this);
    
    /** @private */
    this.dd.endDrag = this.onEndProxyDrag.createDelegate(this);
    
    /** @private */
    this.dragSpecs = {};
    
    /**
     * @private The adapter to use to positon and resize elements
     */
    this.adapter = new  Roo.SplitBar.BasicLayoutAdapter();
    this.adapter.init(this);
    
    if(this.orientation == Roo.SplitBar.HORIZONTAL){
        /** @private */
        this.placement = D || (this.el.getX() > this.resizingEl.getX() ? Roo.SplitBar.LEFT : Roo.SplitBar.RIGHT);
        this.el.addClass("x-splitbar-h");
    }else {
        /** @private */
        this.placement = D || (this.el.getY() > this.resizingEl.getY() ? Roo.SplitBar.TOP : Roo.SplitBar.BOTTOM);
        this.el.addClass("x-splitbar-v");
    }

    
    this.addEvents({
        /**
         * @event resize
         * Fires when the splitter is moved (alias for {@link #event-moved})
         * @param {Roo.SplitBar} this
         * @param {Number} newSize the new width or height
         */
        "resize" : true,
        /**
         * @event moved
         * Fires when the splitter is moved
         * @param {Roo.SplitBar} this
         * @param {Number} newSize the new width or height
         */
        "moved" : true,
        /**
         * @event beforeresize
         * Fires before the splitter is dragged
         * @param {Roo.SplitBar} this
         */
        "beforeresize" : true,

        "beforeapply" : true
    });

    Roo.util.Observable.call(this);
};

Roo.extend(Roo.SplitBar, Roo.util.Observable, {
    onStartProxyDrag : function(x, y){
        this.fireEvent("beforeresize", this);
        if(!this.overlay){
            var  o = Roo.DomHelper.insertFirst(document.body,  {cls: "x-drag-overlay", html: "&#160;"}, true);
            o.unselectable();
            o.enableDisplayMode("block");
            // all splitbars share the same overlay
            Roo.SplitBar.prototype.overlay = o;
        }

        this.overlay.setSize(Roo.lib.Dom.getViewWidth(true), Roo.lib.Dom.getViewHeight(true));
        this.overlay.show();
        Roo.get(this.proxy).setDisplayed("block");
        var  F = this.adapter.getElementSize(this);
        this.activeMinSize = this.getMinimumSize();;
        this.activeMaxSize = this.getMaximumSize();;
        var  c1 = F - this.activeMinSize;
        var  c2 = Math.max(this.activeMaxSize - F, 0);
        if(this.orientation == Roo.SplitBar.HORIZONTAL){
            this.dd.resetConstraints();
            this.dd.setXConstraint(
                this.placement == Roo.SplitBar.LEFT ? c1 : c2, 
                this.placement == Roo.SplitBar.LEFT ? c2 : c1
            );
            this.dd.setYConstraint(0, 0);
        }else {
            this.dd.resetConstraints();
            this.dd.setXConstraint(0, 0);
            this.dd.setYConstraint(
                this.placement == Roo.SplitBar.TOP ? c1 : c2, 
                this.placement == Roo.SplitBar.TOP ? c2 : c1
            );
         }

        this.dragSpecs.startSize = F;
        this.dragSpecs.startPoint = [x, y];
        Roo.dd.DDProxy.prototype.b4StartDrag.call(this.dd, x, y);
    },
    
    /** 
     * @private Called after the drag operation by the DDProxy
     */
    onEndProxyDrag : function(e){
        Roo.get(this.proxy).setDisplayed(false);
        var  G = Roo.lib.Event.getXY(e);
        if(this.overlay){
            this.overlay.hide();
        }
        var  H;
        if(this.orientation == Roo.SplitBar.HORIZONTAL){
            H = this.dragSpecs.startSize + 
                (this.placement == Roo.SplitBar.LEFT ?
                    G[0] - this.dragSpecs.startPoint[0] :
                    this.dragSpecs.startPoint[0] - G[0]
                );
        }else {
            H = this.dragSpecs.startSize + 
                (this.placement == Roo.SplitBar.TOP ?
                    G[1] - this.dragSpecs.startPoint[1] :
                    this.dragSpecs.startPoint[1] - G[1]
                );
        }

        H = Math.min(Math.max(H, this.activeMinSize), this.activeMaxSize);
        if(H != this.dragSpecs.startSize){
            if(this.fireEvent('beforeapply', this, H) !== false){
                this.adapter.setElementSize(this, H);
                this.fireEvent("moved", this, H);
                this.fireEvent("resize", this, H);
            }
        }
    },
    
    /**
     * Get the adapter this SplitBar uses
     * @return The adapter object
     */
    getAdapter : function(){
        return  this.adapter;
    },
    
    /**
     * Set the adapter this SplitBar uses
     * @param {Object} adapter A SplitBar adapter object
     */
    setAdapter : function(I){
        this.adapter = I;
        this.adapter.init(this);
    },
    
    /**
     * Gets the minimum size for the resizing element
     * @return {Number} The minimum size
     */
    getMinimumSize : function(){
        return  this.minSize;
    },
    
    /**
     * Sets the minimum size for the resizing element
     * @param {Number} minSize The minimum size
     */
    setMinimumSize : function(J){
        this.minSize = J;
    },
    
    /**
     * Gets the maximum size for the resizing element
     * @return {Number} The maximum size
     */
    getMaximumSize : function(){
        return  this.maxSize;
    },
    
    /**
     * Sets the maximum size for the resizing element
     * @param {Number} maxSize The maximum size
     */
    setMaximumSize : function(K){
        this.maxSize = K;
    },
    
    /**
     * Sets the initialize size for the resizing element
     * @param {Number} size The initial size
     */
    setCurrentSize : function(L){
        var  M = this.animate;
        this.animate = false;
        this.adapter.setElementSize(this, L);
        this.animate = M;
    },
    
    /**
     * Destroy this splitbar. 
     * @param {Boolean} removeEl True to remove the element
     */
    destroy : function(N){
        if(this.shim){
            this.shim.remove();
        }

        this.dd.unreg();
        this.proxy.parentNode.removeChild(this.proxy);
        if(N){
            this.el.remove();
        }
    }
});

/**
 * @private static Create our own proxy element element. So it will be the same same size on all browsers, we won't use borders. Instead we use a background color.
 */
Roo.SplitBar.createProxy = function(O){
    var  P = new  Roo.Element(document.createElement("div"));
    P.unselectable();
    var  Q = 'x-splitbar-proxy';
    P.addClass(Q + ' ' + (O == Roo.SplitBar.HORIZONTAL ? Q +'-h' : Q + '-v'));
    document.body.appendChild(P.dom);
    return  P.dom;
};

/** 
 * @class Roo.SplitBar.BasicLayoutAdapter
 * Default Adapter. It assumes the splitter and resizing element are not positioned
 * elements and only gets/sets the width of the element. Generally used for table based layouts.
 */
Roo.SplitBar.BasicLayoutAdapter = function(){
};

Roo.SplitBar.BasicLayoutAdapter.prototype = {
    // do nothing for now
    init : function(s){
    
    },
    /**
     * Called before drag operations to get the current size of the resizing element. 
     * @param {Roo.SplitBar} s The SplitBar using this adapter
     */
     getElementSize : function(s){
        if(s.orientation == Roo.SplitBar.HORIZONTAL){
            return  s.resizingEl.getWidth();
        }else {
            return  s.resizingEl.getHeight();
        }
    },
    
    /**
     * Called after drag operations to set the size of the resizing element.
     * @param {Roo.SplitBar} s The SplitBar using this adapter
     * @param {Number} newSize The new size to set
     * @param {Function} onComplete A function to be invoked when resizing is complete
     */
    setElementSize : function(s, R, S){
        if(s.orientation == Roo.SplitBar.HORIZONTAL){
            if(!s.animate){
                s.resizingEl.setWidth(R);
                if(S){
                    S(s, R);
                }
            }else {
                s.resizingEl.setWidth(R, true, .1, S, 'easeOut');
            }
        }else {
            
            if(!s.animate){
                s.resizingEl.setHeight(R);
                if(S){
                    S(s, R);
                }
            }else {
                s.resizingEl.setHeight(R, true, .1, S, 'easeOut');
            }
        }
    }
};

/** 
 *@class Roo.SplitBar.AbsoluteLayoutAdapter
 * @extends Roo.SplitBar.BasicLayoutAdapter
 * Adapter that  moves the splitter element to align with the resized sizing element. 
 * Used with an absolute positioned SplitBar.
 * @param {String/HTMLElement/Roo.Element} container The container that wraps around the absolute positioned content. If it's
 * document.body, make sure you assign an id to the body element.
 */
Roo.SplitBar.AbsoluteLayoutAdapter = function(T){
    this.basic = new  Roo.SplitBar.BasicLayoutAdapter();
    this.container = Roo.get(T);
};

Roo.SplitBar.AbsoluteLayoutAdapter.prototype = {
    init : function(s){
        this.basic.init(s);
    },
    
    getElementSize : function(s){
        return  this.basic.getElementSize(s);
    },
    
    setElementSize : function(s, U, V){
        this.basic.setElementSize(s, U, this.moveSplitter.createDelegate(this, [s]));
    },
    
    moveSplitter : function(s){
        var  W = Roo.SplitBar;
        switch(s.placement){
            case  W.LEFT:
                s.el.setX(s.resizingEl.getRight());
                break;
            case  W.RIGHT:
                s.el.setStyle("right", (this.container.getWidth() - s.resizingEl.getLeft()) + "px");
                break;
            case  W.TOP:
                s.el.setY(s.resizingEl.getBottom());
                break;
            case  W.BOTTOM:
                s.el.setY(s.resizingEl.getTop() - s.el.getHeight());
                break;
        }
    }
};

/**
 * Orientation constant - Create a vertical SplitBar
 * @static
 * @type Number
 */
Roo.SplitBar.VERTICAL = 1;

/**
 * Orientation constant - Create a horizontal SplitBar
 * @static
 * @type Number
 */
Roo.SplitBar.HORIZONTAL = 2;

/**
 * Placement constant - The resizing element is to the left of the splitter element
 * @static
 * @type Number
 */
Roo.SplitBar.LEFT = 1;

/**
 * Placement constant - The resizing element is to the right of the splitter element
 * @static
 * @type Number
 */
Roo.SplitBar.RIGHT = 2;

/**
 * Placement constant - The resizing element is positioned above the splitter element
 * @static
 * @type Number
 */
Roo.SplitBar.TOP = 3;

/**
 * Placement constant - The resizing element is positioned under splitter element
 * @static
 * @type Number
 */
Roo.SplitBar.BOTTOM = 4;

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.View
 * @extends Roo.util.Observable
 * Create a "View" for an element based on a data model or UpdateManager and the supplied DomHelper template. 
 * This class also supports single and multi selection modes. <br>
 * Create a data model bound view:
 <pre><code>
 var store = new Roo.data.Store(...);

 var view = new Roo.View("my-element",
 '&lt;div id="{0}"&gt;{2} - {1}&lt;/div&gt;', // auto create template
 {
 singleSelect: true,
 selectedClass: "ydataview-selected",
 store: store
 });

 // listen for node click?
 view.on("click", function(vw, index, node, e){
 alert('Node "' + node.id + '" at index: ' + index + " was clicked.");
 });

 // load XML data
 dataModel.load("foobar.xml");
 </code></pre>
 For an example of creating a JSON/UpdateManager view, see {@link Roo.JsonView}.
 * <br><br>
 * <b>Note: The root of your template must be a single node. Table/row implementations may work but are not supported due to
 * IE"s limited insertion support with tables and Opera"s faulty event bubbling.</b>
 * @constructor
 * Create a new View
 * @param {String/HTMLElement/Element} container The container element where the view is to be rendered.
 * @param {String/DomHelper.Template} tpl The rendering template or a string to create a template with
 * @param {Object} config The config object
 */
Roo.View = function(A, B, C){
    this.el = Roo.get(A);
    if(typeof  B == "string"){
        B = new  Roo.Template(B);
    }

    B.compile();
    /**
     * The template used by this View
     * @type {Roo.DomHelper.Template}
     */
    this.tpl = B;

    Roo.apply(this, C);

    /** @private */
    this.addEvents({
    /**
     * @event beforeclick
     * Fires before a click is processed. Returns false to cancel the default action.
     * @param {Roo.View} this
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Roo.EventObject} e The raw event object
     */
        "beforeclick" : true,
    /**
     * @event click
     * Fires when a template node is clicked.
     * @param {Roo.View} this
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Roo.EventObject} e The raw event object
     */
        "click" : true,
    /**
     * @event dblclick
     * Fires when a template node is double clicked.
     * @param {Roo.View} this
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Roo.EventObject} e The raw event object
     */
        "dblclick" : true,
    /**
     * @event contextmenu
     * Fires when a template node is right clicked.
     * @param {Roo.View} this
     * @param {Number} index The index of the target node
     * @param {HTMLElement} node The target node
     * @param {Roo.EventObject} e The raw event object
     */
        "contextmenu" : true,
    /**
     * @event selectionchange
     * Fires when the selected nodes change.
     * @param {Roo.View} this
     * @param {Array} selections Array of the selected nodes
     */
        "selectionchange" : true,

    /**
     * @event beforeselect
     * Fires before a selection is made. If any handlers return false, the selection is cancelled.
     * @param {Roo.View} this
     * @param {HTMLElement} node The node to be selected
     * @param {Array} selections Array of currently selected nodes
     */
        "beforeselect" : true
    });

    this.el.on({
        "click": this.onClick,
        "dblclick": this.onDblClick,
        "contextmenu": this.onContextMenu,
        scope:this
    });

    this.selections = [];
    this.nodes = [];
    this.cmp = new  Roo.CompositeElementLite([]);
    if(this.store){
        this.store = Roo.factory(this.store, Roo.data);
        this.setStore(this.store, true);
    }

    Roo.View.superclass.constructor.call(this);
};

Roo.extend(Roo.View, Roo.util.Observable, {
    /**
     * The css class to add to selected nodes
     * @type {Roo.DomHelper.Template}
     */
    selectedClass : "x-view-selected",
    
    emptyText : "",
    /**
     * Returns the element this view is bound to.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.el;
    },

    /**
     * Refreshes the view.
     */
    refresh : function(){
        var  t = this.tpl;
        this.clearSelections();
        this.el.update("");
        var  D = [];
        var  E = this.store.getRange();
        if(E.length < 1){
            this.el.update(this.emptyText);
            return;
        }
        for(var  i = 0, len = E.length; i < len; i++){
            var  data = this.prepareData(E[i].data, i, E[i]);
            D[D.length] = t.apply(data);
        }

        this.el.update(D.join(""));
        this.nodes = this.el.dom.childNodes;
        this.updateIndexes(0);
    },

    /**
     * Function to override to reformat the data that is sent to
     * the template for each node.
     * @param {Array/Object} data The raw data (array of colData for a data model bound view or
     * a JSON object for an UpdateManager bound view).
     */
    prepareData : function(F){
        return  F;
    },

    onUpdate : function(ds, G){
        this.clearSelections();
        var  H = this.store.indexOf(G);
        var  n = this.nodes[H];
        this.tpl.insertBefore(n, this.prepareData(G.data));
        n.parentNode.removeChild(n);
        this.updateIndexes(H, H);
    },

    onAdd : function(ds, I, J){
        this.clearSelections();
        if(this.nodes.length == 0){
            this.refresh();
            return;
        }
        var  n = this.nodes[J];
        for(var  i = 0, len = I.length; i < len; i++){
            var  d = this.prepareData(I[i].data);
            if(n){
                this.tpl.insertBefore(n, d);
            }else {
                this.tpl.append(this.el, d);
            }
        }

        this.updateIndexes(J);
    },

    onRemove : function(ds, K, L){
        this.clearSelections();
        this.el.dom.removeChild(this.nodes[L]);
        this.updateIndexes(L);
    },

    /**
     * Refresh an individual node.
     * @param {Number} index
     */
    refreshNode : function(M){
        this.onUpdate(this.store, this.store.getAt(M));
    },

    updateIndexes : function(N, O){
        var  ns = this.nodes;
        N = N || 0;
        O = O || ns.length - 1;
        for(var  i = N; i <= O; i++){
            ns[i].nodeIndex = i;
        }
    },

    /**
     * Changes the data store this view uses and refresh the view.
     * @param {Store} store
     */
    setStore : function(P, Q){
        if(!Q && this.store){
            this.store.un("datachanged", this.refresh);
            this.store.un("add", this.onAdd);
            this.store.un("remove", this.onRemove);
            this.store.un("update", this.onUpdate);
            this.store.un("clear", this.refresh);
        }
        if(P){
          
            P.on("datachanged", this.refresh, this);
            P.on("add", this.onAdd, this);
            P.on("remove", this.onRemove, this);
            P.on("update", this.onUpdate, this);
            P.on("clear", this.refresh, this);
        }
        
        if(P){
            this.refresh();
        }
    },

    /**
     * Returns the template node the passed child belongs to or null if it doesn't belong to one.
     * @param {HTMLElement} node
     * @return {HTMLElement} The template node
     */
    findItemFromChild : function(R){
        var  el = this.el.dom;
        if(!R || R.parentNode == el){
		    return  R;
	    }
	    var  p = R.parentNode;
	    while(p && p != el){
            if(p.parentNode == el){
            	return  p;
            }

            p = p.parentNode;
        }
	    return  null;
    },

    /** @ignore */
    onClick : function(e){
        var  S = this.findItemFromChild(e.getTarget());
        if(S){
            var  M = this.indexOf(S);
            if(this.onItemClick(S, M, e) !== false){
                this.fireEvent("click", this, M, S, e);
            }
        }else {
            this.clearSelections();
        }
    },

    /** @ignore */
    onContextMenu : function(e){
        var  T = this.findItemFromChild(e.getTarget());
        if(T){
            this.fireEvent("contextmenu", this, this.indexOf(T), T, e);
        }
    },

    /** @ignore */
    onDblClick : function(e){
        var  U = this.findItemFromChild(e.getTarget());
        if(U){
            this.fireEvent("dblclick", this, this.indexOf(U), U, e);
        }
    },

    onItemClick : function(V, W, e){
        if(this.fireEvent("beforeclick", this, W, V, e) === false){
            return  false;
        }
        if(this.multiSelect || this.singleSelect){
            if(this.multiSelect && e.shiftKey && this.lastSelection){
                this.select(this.getNodes(this.indexOf(this.lastSelection), W), false);
            }else {
                this.select(V, this.multiSelect && e.ctrlKey);
                this.lastSelection = V;
            }

            e.preventDefault();
        }
        return  true;
    },

    /**
     * Get the number of selected nodes.
     * @return {Number}
     */
    getSelectionCount : function(){
        return  this.selections.length;
    },

    /**
     * Get the currently selected nodes.
     * @return {Array} An array of HTMLElements
     */
    getSelectedNodes : function(){
        return  this.selections;
    },

    /**
     * Get the indexes of the selected nodes.
     * @return {Array}
     */
    getSelectedIndexes : function(){
        var  X = [], s = this.selections;
        for(var  i = 0, len = s.length; i < len; i++){
            X.push(s[i].nodeIndex);
        }
        return  X;
    },

    /**
     * Clear all selections
     * @param {Boolean} suppressEvent (optional) true to skip firing of the selectionchange event
     */
    clearSelections : function(Y){
        if(this.nodes && (this.multiSelect || this.singleSelect) && this.selections.length > 0){
            this.cmp.elements = this.selections;
            this.cmp.removeClass(this.selectedClass);
            this.selections = [];
            if(!Y){
                this.fireEvent("selectionchange", this, this.selections);
            }
        }
    },

    /**
     * Returns true if the passed node is selected
     * @param {HTMLElement/Number} node The node or node index
     * @return {Boolean}
     */
    isSelected : function(Z){
        var  s = this.selections;
        if(s.length < 1){
            return  false;
        }

        Z = this.getNode(Z);
        return  s.indexOf(Z) !== -1;
    },

    /**
     * Selects nodes.
     * @param {Array/HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node, id of a template node or an array of any of those to select
     * @param {Boolean} keepExisting (optional) true to keep existing selections
     * @param {Boolean} suppressEvent (optional) true to skip firing of the selectionchange vent
     */
    select : function(a, b, c){
        if(a  instanceof  Array){
            if(!b){
                this.clearSelections(true);
            }
            for(var  i = 0, len = a.length; i < len; i++){
                this.select(a[i], true, true);
            }
        } else {
            var  Z = this.getNode(a);
            if(Z && !this.isSelected(Z)){
                if(!b){
                    this.clearSelections(true);
                }
                if(this.fireEvent("beforeselect", this, Z, this.selections) !== false){
                    Roo.fly(Z).addClass(this.selectedClass);
                    this.selections.push(Z);
                    if(!c){
                        this.fireEvent("selectionchange", this, this.selections);
                    }
                }
            }
        }
    },

    /**
     * Gets a template node.
     * @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node
     * @return {HTMLElement} The node or null if it wasn't found
     */
    getNode : function(f){
        if(typeof  f == "string"){
            return  document.getElementById(f);
        }else  if(typeof  f == "number"){
            return  this.nodes[f];
        }
        return  f;
    },

    /**
     * Gets a range template nodes.
     * @param {Number} startIndex
     * @param {Number} endIndex
     * @return {Array} An array of nodes
     */
    getNodes : function(g, h){
        var  ns = this.nodes;
        g = g || 0;
        h = typeof  h == "undefined" ? ns.length - 1 : h;
        var  j = [];
        if(g <= h){
            for(var  i = g; i <= h; i++){
                j.push(ns[i]);
            }
        } else {
            for(var  i = g; i >= h; i--){
                j.push(ns[i]);
            }
        }
        return  j;
    },

    /**
     * Finds the index of the passed node
     * @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node
     * @return {Number} The index of the node or -1
     */
    indexOf : function(k){
        k = this.getNode(k);
        if(typeof  k.nodeIndex == "number"){
            return  k.nodeIndex;
        }
        var  ns = this.nodes;
        for(var  i = 0, len = ns.length; i < len; i++){
            if(ns[i] == k){
                return  i;
            }
        }
        return  -1;
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.JsonView
 * @extends Roo.View
 * Shortcut class to create a JSON + {@link Roo.UpdateManager} template view. Usage:
<pre><code>
var view = new Roo.JsonView("my-element",
    '&lt;div id="{id}"&gt;{foo} - {bar}&lt;/div&gt;', // auto create template
    { multiSelect: true, jsonRoot: "data" }
);

// listen for node click?
view.on("click", function(vw, index, node, e){
    alert('Node "' + node.id + '" at index: ' + index + " was clicked.");
});

// direct load of JSON data
view.load("foobar.php");

// Example from my blog list
var tpl = new Roo.Template(
    '&lt;div class="entry"&gt;' +
    '&lt;a class="entry-title" href="{link}"&gt;{title}&lt;/a&gt;' +
    "&lt;h4&gt;{date} by {author} | {comments} Comments&lt;/h4&gt;{description}" +
    "&lt;/div&gt;&lt;hr /&gt;"
);

var moreView = new Roo.JsonView("entry-list", tpl, {
    jsonRoot: "posts"
});
moreView.on("beforerender", this.sortEntries, this);
moreView.load({
    url: "/blog/get-posts.php",
    params: "allposts=true",
    text: "Loading Blog Entries..."
});
</code></pre>
 * @constructor
 * Create a new JsonView
 * @param {String/HTMLElement/Element} container The container element where the view is to be rendered.
 * @param {Template} tpl The rendering template
 * @param {Object} config The config object
 */
Roo.JsonView = function(A, B, C){
    Roo.JsonView.superclass.constructor.call(this, A, B, C);

    var  um = this.el.getUpdateManager();
    um.setRenderer(this);
    um.on("update", this.onLoad, this);
    um.on("failure", this.onLoadException, this);

    /**
     * @event beforerender
     * Fires before rendering of the downloaded JSON data.
     * @param {Roo.JsonView} this
     * @param {Object} data The JSON data loaded
     */
    /**
     * @event load
     * Fires when data is loaded.
     * @param {Roo.JsonView} this
     * @param {Object} data The JSON data loaded
     * @param {Object} response The raw Connect response object
     */
    /**
     * @event loadexception
     * Fires when loading fails.
     * @param {Roo.JsonView} this
     * @param {Object} response The raw Connect response object
     */
    this.addEvents({
        'beforerender' : true,
        'load' : true,
        'loadexception' : true
    });
};
Roo.extend(Roo.JsonView, Roo.View, {
    /**
     * The root property in the loaded JSON object that contains the data
     * @type {String}
     */
    jsonRoot : "",

    /**
     * Refreshes the view.
     */
    refresh : function(){
        this.clearSelections();
        this.el.update("");
        var  D = [];
        var  o = this.jsonData;
        if(o && o.length > 0){
            for(var  i = 0, len = o.length; i < len; i++){
                var  data = this.prepareData(o[i], i, o);
                D[D.length] = this.tpl.apply(data);
            }
        }else {
            D.push(this.emptyText);
        }

        this.el.update(D.join(""));
        this.nodes = this.el.dom.childNodes;
        this.updateIndexes(0);
    },

    /**
     * Performs an async HTTP request, and loads the JSON from the response. If <i>params</i> are specified it uses POST, otherwise it uses GET.
     * @param {Object/String/Function} url The URL for this request, or a function to call to get the URL, or a config object containing any of the following options:
     <pre><code>
     view.load({
         url: "your-url.php",
         params: {param1: "foo", param2: "bar"}, // or a URL encoded string
         callback: yourFunction,
         scope: yourObject, //(optional scope)
         discardUrl: false,
         nocache: false,
         text: "Loading...",
         timeout: 30,
         scripts: false
     });
     </code></pre>
     * The only required property is <i>url</i>. The optional properties <i>nocache</i>, <i>text</i> and <i>scripts</i>
     * are respectively shorthand for <i>disableCaching</i>, <i>indicatorText</i>, and <i>loadScripts</i> and are used to set their associated property on this UpdateManager instance.
     * @param {String/Object} params (optional) The parameters to pass, as either a URL encoded string "param1=1&amp;param2=2" or an object {param1: 1, param2: 2}
     * @param {Function} callback (optional) Callback when transaction is complete - called with signature (oElement, bSuccess)
     * @param {Boolean} discardUrl (optional) By default when you execute an update the defaultUrl is changed to the last used URL. If true, it will not store the URL.
     */
    load : function(){
        var  um = this.el.getUpdateManager();
        um.update.apply(um, arguments);
    },

    render : function(el, E){
        this.clearSelections();
        this.el.update("");
        var  o;
        try{
            o = Roo.util.JSON.decode(E.responseText);
            if(this.jsonRoot){
                
                o = /** eval:var:o */ eval("o." + this.jsonRoot);
            }
        } catch(e){
        }

        /**
         * The current JSON data or null
         */
        this.jsonData = o;
        this.beforeRender();
        this.refresh();
    },

/**
 * Get the number of records in the current JSON dataset
 * @return {Number}
 */
    getCount : function(){
        return  this.jsonData ? this.jsonData.length : 0;
    },

/**
 * Returns the JSON object for the specified node(s)
 * @param {HTMLElement/Array} node The node or an array of nodes
 * @return {Object/Array} If you pass in an array, you get an array back, otherwise
 * you get the JSON object for the node
 */
    getNodeData : function(F){
        if(F  instanceof  Array){
            var  data = [];
            for(var  i = 0, len = F.length; i < len; i++){
                data.push(this.getNodeData(F[i]));
            }
            return  data;
        }
        return  this.jsonData[this.indexOf(F)] || null;
    },

    beforeRender : function(){
        this.snapshot = this.jsonData;
        if(this.sortInfo){
            this.sort.apply(this, this.sortInfo);
        }

        this.fireEvent("beforerender", this, this.jsonData);
    },

    onLoad : function(el, o){
        this.fireEvent("load", this, this.jsonData, o);
    },

    onLoadException : function(el, o){
        this.fireEvent("loadexception", this, o);
    },

/**
 * Filter the data by a specific property.
 * @param {String} property A property on your JSON objects
 * @param {String/RegExp} value Either string that the property values
 * should start with, or a RegExp to test against the property
 */
    filter : function(G, H){
        if(this.jsonData){
            var  data = [];
            var  ss = this.snapshot;
            if(typeof  H == "string"){
                var  vlen = H.length;
                if(vlen == 0){
                    this.clearFilter();
                    return;
                }

                H = H.toLowerCase();
                for(var  i = 0, len = ss.length; i < len; i++){
                    var  o = ss[i];
                    if(o[G].substr(0, vlen).toLowerCase() == H){
                        data.push(o);
                    }
                }
            } else  if(H.exec){ // regex?
                for(var  i = 0, len = ss.length; i < len; i++){
                    var  o = ss[i];
                    if(H.test(o[G])){
                        data.push(o);
                    }
                }
            } else {
                return;
            }

            this.jsonData = data;
            this.refresh();
        }
    },

/**
 * Filter by a function. The passed function will be called with each
 * object in the current dataset. If the function returns true the value is kept,
 * otherwise it is filtered.
 * @param {Function} fn
 * @param {Object} scope (optional) The scope of the function (defaults to this JsonView)
 */
    filterBy : function(fn, I){
        if(this.jsonData){
            var  data = [];
            var  ss = this.snapshot;
            for(var  i = 0, len = ss.length; i < len; i++){
                var  o = ss[i];
                if(fn.call(I || this, o)){
                    data.push(o);
                }
            }

            this.jsonData = data;
            this.refresh();
        }
    },

/**
 * Clears the current filter.
 */
    clearFilter : function(){
        if(this.snapshot && this.jsonData != this.snapshot){
            this.jsonData = this.snapshot;
            this.refresh();
        }
    },


/**
 * Sorts the data for this view and refreshes it.
 * @param {String} property A property on your JSON objects to sort on
 * @param {String} direction (optional) "desc" or "asc" (defaults to "asc")
 * @param {Function} sortType (optional) A function to call to convert the data to a sortable value.
 */
    sort : function(J, K, L){
        this.sortInfo = Array.prototype.slice.call(arguments, 0);
        if(this.jsonData){
            var  p = J;
            var  dsc = K && K.toLowerCase() == "desc";
            var  f = function(o1, o2){
                var  v1 = L ? L(o1[p]) : o1[p];
                var  v2 = L ? L(o2[p]) : o2[p];
                ;
                if(v1 < v2){
                    return  dsc ? +1 : -1;
                } else  if(v1 > v2){
                    return  dsc ? -1 : +1;
                } else {
                    return  0;
                }
            };
            this.jsonData.sort(f);
            this.refresh();
            if(this.jsonData != this.snapshot){
                this.snapshot.sort(f);
            }
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.ColorPalette
 * @extends Roo.Component
 * Simple color palette class for choosing colors.  The palette can be rendered to any container.<br />
 * Here's an example of typical usage:
 * <pre><code>
var cp = new Roo.ColorPalette({value:'993300'});  // initial selected color
cp.render('my-div');

cp.on('select', function(palette, selColor){
    // do something with selColor
});
</code></pre>
 * @constructor
 * Create a new ColorPalette
 * @param {Object} config The config object
 */
Roo.ColorPalette = function(A){
    Roo.ColorPalette.superclass.constructor.call(this, A);
    this.addEvents({
        /**
	     * @event select
	     * Fires when a color is selected
	     * @param {ColorPalette} this
	     * @param {String} color The 6-digit color hex code (without the # symbol)
	     */
        select: true
    });

    if(this.handler){
        this.on("select", this.handler, this.scope, true);
    }
};
Roo.extend(Roo.ColorPalette, Roo.Component, {
    /**
     * @cfg {String} itemCls
     * The CSS class to apply to the containing element (defaults to "x-color-palette")
     */
    itemCls : "x-color-palette",
    /**
     * @cfg {String} value
     * The initial color to highlight (should be a valid 6-digit color hex code without the # symbol).  Note that
     * the hex codes are case-sensitive.
     */
    value : null,
    clickEvent:'click',
    // private
    ctype: "Roo.ColorPalette",

    /**
     * @cfg {Boolean} allowReselect If set to true then reselecting a color that is already selected fires the selection event
     */
    allowReselect : false,

    /**
     * <p>An array of 6-digit color hex code strings (without the # symbol).  This array can contain any number
     * of colors, and each hex code should be unique.  The width of the palette is controlled via CSS by adjusting
     * the width property of the 'x-color-palette' class (or assigning a custom class), so you can balance the number
     * of colors with the width setting until the box is symmetrical.</p>
     * <p>You can override individual colors if needed:</p>
     * <pre><code>
var cp = new Roo.ColorPalette();
cp.colors[0] = "FF0000";  // change the first box to red
</code></pre>

Or you can provide a custom array of your own for complete control:
<pre><code>
var cp = new Roo.ColorPalette();
cp.colors = ["000000", "993300", "333300"];
</code></pre>
     * @type Array
     */
    colors : [
        "000000", "993300", "333300", "003300", "003366", "000080", "333399", "333333",
        "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080",
        "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "969696",
        "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0",
        "FF99CC", "FFCC99", "FFFF99", "CCFFCC", "CCFFFF", "99CCFF", "CC99FF", "FFFFFF"
    ],

    // private
    onRender : function(B, C){
        var  t = new  Roo.MasterTemplate(
            '<tpl><a href="#" class="color-{0}" hidefocus="on"><em><span style="background:#{0}" unselectable="on">&#160;</span></em></a></tpl>'
        );
        var  c = this.colors;
        for(var  i = 0, len = c.length; i < len; i++){
            t.add([c[i]]);
        }
        var  el = document.createElement("div");
        el.className = this.itemCls;
        t.overwrite(el);
        B.dom.insertBefore(el, C);
        this.el = Roo.get(el);
        this.el.on(this.clickEvent, this.handleClick,  this, {delegate: "a"});
        if(this.clickEvent != 'click'){
            this.el.on('click', Roo.emptyFn,  this, {delegate: "a", preventDefault:true});
        }
    },

    // private
    afterRender : function(){
        Roo.ColorPalette.superclass.afterRender.call(this);
        if(this.value){
            var  s = this.value;
            this.value = null;
            this.select(s);
        }
    },

    // private
    handleClick : function(e, t){
        e.preventDefault();
        if(!this.disabled){
            var  c = t.className.match(/(?:^|\s)color-(.{6})(?:\s|$)/)[1];
            this.select(c.toUpperCase());
        }
    },

    /**
     * Selects the specified color in the palette (fires the select event)
     * @param {String} color A valid 6-digit color hex code (# will be stripped if included)
     */
    select : function(D){
        D = D.replace("#", "");
        if(D != this.value || this.allowReselect){
            var  el = this.el;
            if(this.value){
                el.child("a.color-"+this.value).removeClass("x-color-palette-sel");
            }

            el.child("a.color-"+D).addClass("x-color-palette-sel");
            this.value = D;
            this.fireEvent("select", this, D);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.DatePicker
 * @extends Roo.Component
 * Simple date picker class.
 * @constructor
 * Create a new DatePicker
 * @param {Object} config The config object
 */
Roo.DatePicker = function(A){
    Roo.DatePicker.superclass.constructor.call(this, A);

    this.value = A && A.value ?
                 A.value.clearTime() : new  Date().clearTime();

    this.addEvents({
        /**
	     * @event select
	     * Fires when a date is selected
	     * @param {DatePicker} this
	     * @param {Date} date The selected date
	     */
        select: true
    });

    if(this.handler){
        this.on("select", this.handler,  this.scope || this);
    }
    // build the disabledDatesRE
    if(!this.disabledDatesRE && this.disabledDates){
        var  dd = this.disabledDates;
        var  re = "(?:";
        for(var  i = 0; i < dd.length; i++){
            re += dd[i];
            if(i != dd.length-1) re += "|";
        }

        this.disabledDatesRE = new  RegExp(re + ")");
    }
};

Roo.extend(Roo.DatePicker, Roo.Component, {
    /**
     * @cfg {String} todayText
     * The text to display on the button that selects the current date (defaults to "Today")
     */
    todayText : "Today",
    /**
     * @cfg {String} okText
     * The text to display on the ok button
     */
    okText : "&#160;OK&#160;", // &#160; to give the user extra clicking room
    /**
     * @cfg {String} cancelText
     * The text to display on the cancel button
     */
    cancelText : "Cancel",
    /**
     * @cfg {String} todayTip
     * The tooltip to display for the button that selects the current date (defaults to "{current date} (Spacebar)")
     */
    todayTip : "{0} (Spacebar)",
    /**
     * @cfg {Date} minDate
     * Minimum allowable date (JavaScript date object, defaults to null)
     */
    minDate : null,
    /**
     * @cfg {Date} maxDate
     * Maximum allowable date (JavaScript date object, defaults to null)
     */
    maxDate : null,
    /**
     * @cfg {String} minText
     * The error text to display if the minDate validation fails (defaults to "This date is before the minimum date")
     */
    minText : "This date is before the minimum date",
    /**
     * @cfg {String} maxText
     * The error text to display if the maxDate validation fails (defaults to "This date is after the maximum date")
     */
    maxText : "This date is after the maximum date",
    /**
     * @cfg {String} format
     * The default date format string which can be overriden for localization support.  The format must be
     * valid according to {@link Date#parseDate} (defaults to 'm/d/y').
     */
    format : "m/d/y",
    /**
     * @cfg {Array} disabledDays
     * An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
     */
    disabledDays : null,
    /**
     * @cfg {String} disabledDaysText
     * The tooltip to display when the date falls on a disabled day (defaults to "")
     */
    disabledDaysText : "",
    /**
     * @cfg {RegExp} disabledDatesRE
     * JavaScript regular expression used to disable a pattern of dates (defaults to null)
     */
    disabledDatesRE : null,
    /**
     * @cfg {String} disabledDatesText
     * The tooltip text to display when the date falls on a disabled date (defaults to "")
     */
    disabledDatesText : "",
    /**
     * @cfg {Boolean} constrainToViewport
     * True to constrain the date picker to the viewport (defaults to true)
     */
    constrainToViewport : true,
    /**
     * @cfg {Array} monthNames
     * An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
     */
    monthNames : Date.monthNames,
    /**
     * @cfg {Array} dayNames
     * An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
     */
    dayNames : Date.dayNames,
    /**
     * @cfg {String} nextText
     * The next month navigation button tooltip (defaults to 'Next Month (Control+Right)')
     */
    nextText: 'Next Month (Control+Right)',
    /**
     * @cfg {String} prevText
     * The previous month navigation button tooltip (defaults to 'Previous Month (Control+Left)')
     */
    prevText: 'Previous Month (Control+Left)',
    /**
     * @cfg {String} monthYearText
     * The header month selector tooltip (defaults to 'Choose a month (Control+Up/Down to move years)')
     */
    monthYearText: 'Choose a month (Control+Up/Down to move years)',
    /**
     * @cfg {Number} startDay
     * Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)
     */
    startDay : 0,
    /**
     * @cfg {Bool} showClear
     * Show a clear button (usefull for date form elements that can be blank.)
     */
    
    showClear: false,
    
    /**
     * Sets the value of the date field
     * @param {Date} value The date to set
     */
    setValue : function(B){
        var  C = this.value;
        this.value = B.clearTime(true);
        if(this.el){
            this.update(this.value);
        }
    },

    /**
     * Gets the current selected value of the date field
     * @return {Date} The selected date
     */
    getValue : function(){
        return  this.value;
    },

    // private
    focus : function(){
        if(this.el){
            this.update(this.activeDate);
        }
    },

    // private
    onRender : function(D, E){
        var  m = [
             '<table cellspacing="0">',
                '<tr><td class="x-date-left"><a href="#" title="', this.prevText ,'">&#160;</a></td><td class="x-date-middle" align="center"></td><td class="x-date-right"><a href="#" title="', this.nextText ,'">&#160;</a></td></tr>',
                '<tr><td colspan="3"><table class="x-date-inner" cellspacing="0"><thead><tr>'];
        var  dn = this.dayNames;
        for(var  i = 0; i < 7; i++){
            var  d = this.startDay+i;
            if(d > 6){
                d = d-7;
            }

            m.push("<th><span>", dn[d].substr(0,1), "</span></th>");
        }

        m[m.length] = "</tr></thead><tbody><tr>";
        for(var  i = 0; i < 42; i++) {
            if(i % 7 == 0 && i != 0){
                m[m.length] = "</tr><tr>";
            }

            m[m.length] = '<td><a href="#" hidefocus="on" class="x-date-date" tabIndex="1"><em><span></span></em></a></td>';
        }

        m[m.length] = '</tr></tbody></table></td></tr><tr>'+
            '<td colspan="3" class="x-date-bottom" align="center"></td></tr></table><div class="x-date-mp"></div>';

        var  el = document.createElement("div");
        el.className = "x-date-picker";
        el.innerHTML = m.join("");

        D.dom.insertBefore(el, E);

        this.el = Roo.get(el);
        this.eventEl = Roo.get(el.firstChild);

        new  Roo.util.ClickRepeater(this.el.child("td.x-date-left a"), {
            handler: this.showPrevMonth,
            scope: this,
            preventDefault:true,
            stopDefault:true
        });

        new  Roo.util.ClickRepeater(this.el.child("td.x-date-right a"), {
            handler: this.showNextMonth,
            scope: this,
            preventDefault:true,
            stopDefault:true
        });

        this.eventEl.on("mousewheel", this.handleMouseWheel,  this);

        this.monthPicker = this.el.down('div.x-date-mp');
        this.monthPicker.enableDisplayMode('block');
        
        var  kn = new  Roo.KeyNav(this.eventEl, {
            "left" : function(e){
                e.ctrlKey ?
                    this.showPrevMonth() :
                    this.update(this.activeDate.add("d", -1));
            },

            "right" : function(e){
                e.ctrlKey ?
                    this.showNextMonth() :
                    this.update(this.activeDate.add("d", 1));
            },

            "up" : function(e){
                e.ctrlKey ?
                    this.showNextYear() :
                    this.update(this.activeDate.add("d", -7));
            },

            "down" : function(e){
                e.ctrlKey ?
                    this.showPrevYear() :
                    this.update(this.activeDate.add("d", 7));
            },

            "pageUp" : function(e){
                this.showNextMonth();
            },

            "pageDown" : function(e){
                this.showPrevMonth();
            },

            "enter" : function(e){
                e.stopPropagation();
                return  true;
            },

            scope : this
        });

        this.eventEl.on("click", this.handleDateClick,  this, {delegate: "a.x-date-date"});

        this.eventEl.addKeyListener(Roo.EventObject.SPACE, this.selectToday,  this);

        this.el.unselectable();
        
        this.cells = this.el.select("table.x-date-inner tbody td");
        this.textNodes = this.el.query("table.x-date-inner tbody span");

        this.mbtn = new  Roo.Button(this.el.child("td.x-date-middle", true), {
            text: "&#160;",
            tooltip: this.monthYearText
        });

        this.mbtn.on('click', this.showMonthPicker, this);
        this.mbtn.el.child(this.mbtn.menuClassTarget).addClass("x-btn-with-menu");


        var  F = (new  Date()).dateFormat(this.format);
        
        var  G = new  Roo.Toolbar(this.el.child("td.x-date-bottom", true));
        G.add({
            text: String.format(this.todayText, F),
            tooltip: String.format(this.todayTip, F),
            handler: this.selectToday,
            scope: this
        });
        
        //var todayBtn = new Roo.Button(this.el.child("td.x-date-bottom", true), {
            
        //});
        if (this.showClear) {
            
            G.add( new  Roo.Toolbar.Fill());
            G.add({
                text: '&#160;',
                cls: 'x-btn-icon x-btn-clear',
                handler: function() {
                    //this.value = '';
                    this.fireEvent("select", this, '');
                },
                scope: this
            });
        }
        
        
        if(Roo.isIE){
            this.el.repaint();
        }

        this.update(this.value);
    },

    createMonthPicker : function(){
        if(!this.monthPicker.dom.firstChild){
            var  buf = ['<table border="0" cellspacing="0">'];
            for(var  i = 0; i < 6; i++){
                buf.push(
                    '<tr><td class="x-date-mp-month"><a href="#">', this.monthNames[i].substr(0, 3), '</a></td>',
                    '<td class="x-date-mp-month x-date-mp-sep"><a href="#">', this.monthNames[i+6].substr(0, 3), '</a></td>',
                    i == 0 ?
                    '<td class="x-date-mp-ybtn" align="center"><a class="x-date-mp-prev"></a></td><td class="x-date-mp-ybtn" align="center"><a class="x-date-mp-next"></a></td></tr>' :
                    '<td class="x-date-mp-year"><a href="#"></a></td><td class="x-date-mp-year"><a href="#"></a></td></tr>'
                );
            }

            buf.push(
                '<tr class="x-date-mp-btns"><td colspan="4"><button type="button" class="x-date-mp-ok">',
                    this.okText,
                    '</button><button type="button" class="x-date-mp-cancel">',
                    this.cancelText,
                    '</button></td></tr>',
                '</table>'
            );
            this.monthPicker.update(buf.join(''));
            this.monthPicker.on('click', this.onMonthClick, this);
            this.monthPicker.on('dblclick', this.onMonthDblClick, this);

            this.mpMonths = this.monthPicker.select('td.x-date-mp-month');
            this.mpYears = this.monthPicker.select('td.x-date-mp-year');

            this.mpMonths.each(function(m, a, i){
                i += 1;
                if((i%2) == 0){
                    m.dom.xmonth = 5 + Math.round(i * .5);
                }else {
                    m.dom.xmonth = Math.round((i-1) * .5);
                }
            });
        }
    },

    showMonthPicker : function(){
        this.createMonthPicker();
        var  H = this.el.getSize();
        this.monthPicker.setSize(H);
        this.monthPicker.child('table').setSize(H);

        this.mpSelMonth = (this.activeDate || this.value).getMonth();
        this.updateMPMonth(this.mpSelMonth);
        this.mpSelYear = (this.activeDate || this.value).getFullYear();
        this.updateMPYear(this.mpSelYear);

        this.monthPicker.slideIn('t', {duration:.2});
    },

    updateMPYear : function(y){
        this.mpyear = y;
        var  ys = this.mpYears.elements;
        for(var  i = 1; i <= 10; i++){
            var  td = ys[i-1], y2;
            if((i%2) == 0){
                y2 = y + Math.round(i * .5);
                td.firstChild.innerHTML = y2;
                td.xyear = y2;
            }else {
                y2 = y - (5-Math.round(i * .5));
                td.firstChild.innerHTML = y2;
                td.xyear = y2;
            }

            this.mpYears.item(i-1)[y2 == this.mpSelYear ? 'addClass' : 'removeClass']('x-date-mp-sel');
        }
    },

    updateMPMonth : function(sm){
        this.mpMonths.each(function(m, a, i){
            m[m.dom.xmonth == sm ? 'addClass' : 'removeClass']('x-date-mp-sel');
        });
    },

    selectMPMonth: function(m){
        
    },

    onMonthClick : function(e, t){
        e.stopEvent();
        var  el = new  Roo.Element(t), pn;
        if(el.is('button.x-date-mp-cancel')){
            this.hideMonthPicker();
        }
        else  if(el.is('button.x-date-mp-ok')){
            this.update(new  Date(this.mpSelYear, this.mpSelMonth, (this.activeDate || this.value).getDate()));
            this.hideMonthPicker();
        }
        else  if(pn = el.up('td.x-date-mp-month', 2)){
            this.mpMonths.removeClass('x-date-mp-sel');
            pn.addClass('x-date-mp-sel');
            this.mpSelMonth = pn.dom.xmonth;
        }
        else  if(pn = el.up('td.x-date-mp-year', 2)){
            this.mpYears.removeClass('x-date-mp-sel');
            pn.addClass('x-date-mp-sel');
            this.mpSelYear = pn.dom.xyear;
        }
        else  if(el.is('a.x-date-mp-prev')){
            this.updateMPYear(this.mpyear-10);
        }
        else  if(el.is('a.x-date-mp-next')){
            this.updateMPYear(this.mpyear+10);
        }
    },

    onMonthDblClick : function(e, t){
        e.stopEvent();
        var  el = new  Roo.Element(t), pn;
        if(pn = el.up('td.x-date-mp-month', 2)){
            this.update(new  Date(this.mpSelYear, pn.dom.xmonth, (this.activeDate || this.value).getDate()));
            this.hideMonthPicker();
        }
        else  if(pn = el.up('td.x-date-mp-year', 2)){
            this.update(new  Date(pn.dom.xyear, this.mpSelMonth, (this.activeDate || this.value).getDate()));
            this.hideMonthPicker();
        }
    },

    hideMonthPicker : function(I){
        if(this.monthPicker){
            if(I === true){
                this.monthPicker.hide();
            }else {
                this.monthPicker.slideOut('t', {duration:.2});
            }
        }
    },

    // private
    showPrevMonth : function(e){
        this.update(this.activeDate.add("mo", -1));
    },

    // private
    showNextMonth : function(e){
        this.update(this.activeDate.add("mo", 1));
    },

    // private
    showPrevYear : function(){
        this.update(this.activeDate.add("y", -1));
    },

    // private
    showNextYear : function(){
        this.update(this.activeDate.add("y", 1));
    },

    // private
    handleMouseWheel : function(e){
        var  J = e.getWheelDelta();
        if(J > 0){
            this.showPrevMonth();
            e.stopEvent();
        } else  if(J < 0){
            this.showNextMonth();
            e.stopEvent();
        }
    },

    // private
    handleDateClick : function(e, t){
        e.stopEvent();
        if(t.dateValue && !Roo.fly(t.parentNode).hasClass("x-date-disabled")){
            this.setValue(new  Date(t.dateValue));
            this.fireEvent("select", this, this.value);
        }
    },

    // private
    selectToday : function(){
        this.setValue(new  Date().clearTime());
        this.fireEvent("select", this, this.value);
    },

    // private
    update : function(K){
        var  vd = this.activeDate;
        this.activeDate = K;
        if(vd && this.el){
            var  t = K.getTime();
            if(vd.getMonth() == K.getMonth() && vd.getFullYear() == K.getFullYear()){
                this.cells.removeClass("x-date-selected");
                this.cells.each(function(c){
                   if(c.dom.firstChild.dateValue == t){
                       c.addClass("x-date-selected");
                       setTimeout(function(){
                            try{c.dom.firstChild.focus();}catch(e){}
                       }, 50);
                       return  false;
                   }
                });
                return;
            }
        }
        var  L = K.getDaysInMonth();
        var  M = K.getFirstDateOfMonth();
        var  N = M.getDay()-this.startDay;

        if(N <= this.startDay){
            N += 7;
        }

        var  pm = K.add("mo", -1);
        var  O = pm.getDaysInMonth()-N;

        var  P = this.cells.elements;
        var  Q = this.textNodes;
        L += N;

        // convert everything to numbers so it's fast
        var  R = 86400000;
        var  d = (new  Date(pm.getFullYear(), pm.getMonth(), O)).clearTime();
        var  S = new  Date().clearTime().getTime();
        var  T = K.clearTime().getTime();
        var  U = this.minDate ? this.minDate.clearTime() : Number.NEGATIVE_INFINITY;
        var  V = this.maxDate ? this.maxDate.clearTime() : Number.POSITIVE_INFINITY;
        var  W = this.disabledDatesRE;
        var  X = this.disabledDatesText;
        var  Y = this.disabledDays ? this.disabledDays.join("") : false;
        var  Z = this.disabledDaysText;
        var  a = this.format;

        var  b = function(f, g){
            g.title = "";
            var  t = d.getTime();
            g.firstChild.dateValue = t;
            if(t == S){
                g.className += " x-date-today";
                g.title = f.todayText;
            }
            if(t == T){
                g.className += " x-date-selected";
                setTimeout(function(){
                    try{g.firstChild.focus();}catch(e){}
                }, 50);
            }
            // disabling
            if(t < U) {
                g.className = " x-date-disabled";
                g.title = f.minText;
                return;
            }
            if(t > V) {
                g.className = " x-date-disabled";
                g.title = f.maxText;
                return;
            }
            if(Y){
                if(Y.indexOf(d.getDay()) != -1){
                    g.title = Z;
                    g.className = " x-date-disabled";
                }
            }
            if(W && a){
                var  fvalue = d.dateFormat(a);
                if(W.test(fvalue)){
                    g.title = X.replace("%0", fvalue);
                    g.className = " x-date-disabled";
                }
            }
        };

        var  i = 0;
        for(; i < N; i++) {
            Q[i].innerHTML = (++O);
            d.setDate(d.getDate()+1);
            P[i].className = "x-date-prevday";
            b(this, P[i]);
        }
        for(; i < L; i++){
            intDay = i - N + 1;
            Q[i].innerHTML = (intDay);
            d.setDate(d.getDate()+1);
            P[i].className = "x-date-active";
            b(this, P[i]);
        }
        var  c = 0;
        for(; i < 42; i++) {
             Q[i].innerHTML = (++c);
             d.setDate(d.getDate()+1);
             P[i].className = "x-date-nextday";
             b(this, P[i]);
        }


        this.mbtn.setText(this.monthNames[K.getMonth()] + " " + K.getFullYear());

        if(!this.internalRender){
            var  main = this.el.dom.firstChild;
            var  w = main.offsetWidth;
            this.el.setWidth(w + this.el.getBorderWidth("lr"));
            Roo.fly(main).setWidth(w);
            this.internalRender = true;
            // opera does not respect the auto grow header center column
            // then, after it gets a width opera refuses to recalculate
            // without a second pass
            if(Roo.isOpera && !this.secondPass){
                main.rows[0].cells[1].style.width = (w - (main.rows[0].cells[0].offsetWidth+main.rows[0].cells[2].offsetWidth)) + "px";
                this.secondPass = true;
                this.update.defer(10, this, [K]);
            }
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.TabPanel
 * @extends Roo.util.Observable
 * A lightweight tab container.
 * <br><br>
 * Usage:
 * <pre><code>
// basic tabs 1, built from existing content
var tabs = new Roo.TabPanel("tabs1");
tabs.addTab("script", "View Script");
tabs.addTab("markup", "View Markup");
tabs.activate("script");

// more advanced tabs, built from javascript
var jtabs = new Roo.TabPanel("jtabs");
jtabs.addTab("jtabs-1", "Normal Tab", "My content was added during construction.");

// set up the UpdateManager
var tab2 = jtabs.addTab("jtabs-2", "Ajax Tab 1");
var updater = tab2.getUpdateManager();
updater.setDefaultUrl("ajax1.htm");
tab2.on('activate', updater.refresh, updater, true);

// Use setUrl for Ajax loading
var tab3 = jtabs.addTab("jtabs-3", "Ajax Tab 2");
tab3.setUrl("ajax2.htm", null, true);

// Disabled tab
var tab4 = jtabs.addTab("tabs1-5", "Disabled Tab", "Can't see me cause I'm disabled");
tab4.disable();

jtabs.activate("jtabs-1");
 * </code></pre>
 * @constructor
 * Create a new TabPanel.
 * @param {String/HTMLElement/Roo.Element} container The id, DOM element or Roo.Element container where this TabPanel is to be rendered.
 * @param {Object/Boolean} config Config object to set any properties for this TabPanel, or true to render the tabs on the bottom.
 */
Roo.TabPanel = function(A, B){
    /**
    * The container element for this TabPanel.
    * @type Roo.Element
    */
    this.el = Roo.get(A, true);
    if(B){
        if(typeof  B == "boolean"){
            this.tabPosition = B ? "bottom" : "top";
        }else {
            Roo.apply(this, B);
        }
    }
    if(this.tabPosition == "bottom"){
        this.bodyEl = Roo.get(this.createBody(this.el.dom));
        this.el.addClass("x-tabs-bottom");
    }

    this.stripWrap = Roo.get(this.createStrip(this.el.dom), true);
    this.stripEl = Roo.get(this.createStripList(this.stripWrap.dom), true);
    this.stripBody = Roo.get(this.stripWrap.dom.firstChild.firstChild, true);
    if(Roo.isIE){
        Roo.fly(this.stripWrap.dom.firstChild).setStyle("overflow-x", "hidden");
    }
    if(this.tabPosition != "bottom"){
    /** The body element that contains {@link Roo.TabPanelItem} bodies.
     * @type Roo.Element
     */
      this.bodyEl = Roo.get(this.createBody(this.el.dom));
      this.el.addClass("x-tabs-top");
    }

    this.items = [];

    this.bodyEl.setStyle("position", "relative");

    this.active = null;
    this.activateDelegate = this.activate.createDelegate(this);

    this.addEvents({
        /**
         * @event tabchange
         * Fires when the active tab changes
         * @param {Roo.TabPanel} this
         * @param {Roo.TabPanelItem} activePanel The new active tab
         */
        "tabchange": true,
        /**
         * @event beforetabchange
         * Fires before the active tab changes, set cancel to true on the "e" parameter to cancel the change
         * @param {Roo.TabPanel} this
         * @param {Object} e Set cancel to true on this object to cancel the tab change
         * @param {Roo.TabPanelItem} tab The tab being changed to
         */
        "beforetabchange" : true
    });

    Roo.EventManager.onWindowResize(this.onResize, this);
    this.cpad = this.el.getPadding("lr");
    this.hiddenCount = 0;

    Roo.TabPanel.superclass.constructor.call(this);
};

Roo.extend(Roo.TabPanel, Roo.util.Observable, {
	/*
	 *@cfg {String} tabPosition "top" or "bottom" (defaults to "top")
	 */
    tabPosition : "top",
	/*
	 *@cfg {Number} currentTabWidth The width of the current tab (defaults to 0)
	 */
    currentTabWidth : 0,
	/*
	 *@cfg {Number} minTabWidth The minimum width of a tab (defaults to 40) (ignored if {@link #resizeTabs} is not true)
	 */
    minTabWidth : 40,
	/*
	 *@cfg {Number} maxTabWidth The maximum width of a tab (defaults to 250) (ignored if {@link #resizeTabs} is not true)
	 */
    maxTabWidth : 250,
	/*
	 *@cfg {Number} preferredTabWidth The preferred (default) width of a tab (defaults to 175) (ignored if {@link #resizeTabs} is not true)
	 */
    preferredTabWidth : 175,
	/*
	 *@cfg {Boolean} resizeTabs True to enable dynamic tab resizing (defaults to false)
	 */
    resizeTabs : false,
	/*
	 *@cfg {Boolean} monitorResize Set this to true to turn on window resize monitoring (ignored if {@link #resizeTabs} is not true) (defaults to true)
	 */
    monitorResize : true,

    /**
     * Creates a new {@link Roo.TabPanelItem} by looking for an existing element with the provided id -- if it's not found it creates one.
     * @param {String} id The id of the div to use <b>or create</b>
     * @param {String} text The text for the tab
     * @param {String} content (optional) Content to put in the TabPanelItem body
     * @param {Boolean} closable (optional) True to create a close icon on the tab
     * @return {Roo.TabPanelItem} The created TabPanelItem
     */
    addTab : function(id, C, D, E){
        var  F = new  Roo.TabPanelItem(this, id, C, E);
        this.addTabItem(F);
        if(D){
            F.setContent(D);
        }
        return  F;
    },

    /**
     * Returns the {@link Roo.TabPanelItem} with the specified id/index
     * @param {String/Number} id The id or index of the TabPanelItem to fetch.
     * @return {Roo.TabPanelItem}
     */
    getTab : function(id){
        return  this.items[id];
    },

    /**
     * Hides the {@link Roo.TabPanelItem} with the specified id/index
     * @param {String/Number} id The id or index of the TabPanelItem to hide.
     */
    hideTab : function(id){
        var  t = this.items[id];
        if(!t.isHidden()){
           t.setHidden(true);
           this.hiddenCount++;
           this.autoSizeTabs();
        }
    },

    /**
     * "Unhides" the {@link Roo.TabPanelItem} with the specified id/index.
     * @param {String/Number} id The id or index of the TabPanelItem to unhide.
     */
    unhideTab : function(id){
        var  t = this.items[id];
        if(t.isHidden()){
           t.setHidden(false);
           this.hiddenCount--;
           this.autoSizeTabs();
        }
    },

    /**
     * Adds an existing {@link Roo.TabPanelItem}.
     * @param {Roo.TabPanelItem} item The TabPanelItem to add
     */
    addTabItem : function(G){
        this.items[G.id] = G;
        this.items.push(G);
        if(this.resizeTabs){
           G.setWidth(this.currentTabWidth || this.preferredTabWidth);
           this.autoSizeTabs();
        }else {
            G.autoSize();
        }
    },

    /**
     * Removes a {@link Roo.TabPanelItem}.
     * @param {String/Number} id The id or index of the TabPanelItem to remove.
     */
    removeTab : function(id){
        var  H = this.items;
        var  I = H[id];
        if(!I) return;
        var  J = H.indexOf(I);
        if(this.active == I && H.length > 1){
            var  newTab = this.getNextAvailable(J);
            if(newTab)newTab.activate();
        }

        this.stripEl.dom.removeChild(I.pnode.dom);
        if(I.bodyEl.dom.parentNode == this.bodyEl.dom){ // if it was moved already prevent error
            this.bodyEl.dom.removeChild(I.bodyEl.dom);
        }

        H.splice(J, 1);
        delete  this.items[I.id];
        I.fireEvent("close", I);
        I.purgeListeners();
        this.autoSizeTabs();
    },

    getNextAvailable : function(K){
        var  L = this.items;
        var  M = K;
        // look for a next tab that will slide over to
        // replace the one being removed
        while(M < L.length){
            var  G = L[++M];
            if(G && !G.isHidden()){
                return  G;
            }
        }

        // if one isn't found select the previous tab (on the left)
        M = K;
        while(M >= 0){
            var  G = L[--M];
            if(G && !G.isHidden()){
                return  G;
            }
        }
        return  null;
    },

    /**
     * Disables a {@link Roo.TabPanelItem}. It cannot be the active tab, if it is this call is ignored.
     * @param {String/Number} id The id or index of the TabPanelItem to disable.
     */
    disableTab : function(id){
        var  N = this.items[id];
        if(N && this.active != N){
            N.disable();
        }
    },

    /**
     * Enables a {@link Roo.TabPanelItem} that is disabled.
     * @param {String/Number} id The id or index of the TabPanelItem to enable.
     */
    enableTab : function(id){
        var  O = this.items[id];
        O.enable();
    },

    /**
     * Activates a {@link Roo.TabPanelItem}. The currently active one will be deactivated.
     * @param {String/Number} id The id or index of the TabPanelItem to activate.
     * @return {Roo.TabPanelItem} The TabPanelItem.
     */
    activate : function(id){
        var  P = this.items[id];
        if(!P){
            return  null;
        }
        if(P == this.active || P.disabled){
            return  P;
        }
        var  e = {};
        this.fireEvent("beforetabchange", this, e, P);
        if(e.cancel !== true && !P.disabled){
            if(this.active){
                this.active.hide();
            }

            this.active = this.items[id];
            this.active.show();
            this.fireEvent("tabchange", this, this.active);
        }
        return  P;
    },

    /**
     * Gets the active {@link Roo.TabPanelItem}.
     * @return {Roo.TabPanelItem} The active TabPanelItem or null if none are active.
     */
    getActiveTab : function(){
        return  this.active;
    },

    /**
     * Updates the tab body element to fit the height of the container element
     * for overflow scrolling
     * @param {Number} targetHeight (optional) Override the starting height from the elements height
     */
    syncHeight : function(Q){
        var  R = (Q || this.el.getHeight())-this.el.getBorderWidth("tb")-this.el.getPadding("tb");
        var  bm = this.bodyEl.getMargins();
        var  S = R-(this.stripWrap.getHeight()||0)-(bm.top+bm.bottom);
        this.bodyEl.setHeight(S);
        return  S;
    },

    onResize : function(){
        if(this.monitorResize){
            this.autoSizeTabs();
        }
    },

    /**
     * Disables tab resizing while tabs are being added (if {@link #resizeTabs} is false this does nothing)
     */
    beginUpdate : function(){
        this.updating = true;
    },

    /**
     * Stops an update and resizes the tabs (if {@link #resizeTabs} is false this does nothing)
     */
    endUpdate : function(){
        this.updating = false;
        this.autoSizeTabs();
    },

    /**
     * Manual call to resize the tabs (if {@link #resizeTabs} is false this does nothing)
     */
    autoSizeTabs : function(){
        var  T = this.items.length;
        var  U = T - this.hiddenCount;
        if(!this.resizeTabs || T < 1 || U < 1 || this.updating) return;
        var  w = Math.max(this.el.getWidth() - this.cpad, 10);
        var  V = Math.floor(w / U);
        var  b = this.stripBody;
        if(b.getWidth() > w){
            var  tabs = this.items;
            this.setTabWidth(Math.max(V, this.minTabWidth)-2);
            if(V < this.minTabWidth){
                /*if(!this.sleft){    // incomplete scrolling code
                    this.createScrollButtons();
                }
                this.showScroll();
                this.stripClip.setWidth(w - (this.sleft.getWidth()+this.sright.getWidth()));*/
            }
        }else {
            if(this.currentTabWidth < this.preferredTabWidth){
                this.setTabWidth(Math.min(V, this.preferredTabWidth)-2);
            }
        }
    },

    /**
     * Returns the number of tabs in this TabPanel.
     * @return {Number}
     */
     getCount : function(){
         return  this.items.length;
     },

    /**
     * Resizes all the tabs to the passed width
     * @param {Number} The new width
     */
    setTabWidth : function(W){
        this.currentTabWidth = W;
        for(var  i = 0, len = this.items.length; i < len; i++) {
        	if(!this.items[i].isHidden())this.items[i].setWidth(W);
        }
    },

    /**
     * Destroys this TabPanel
     * @param {Boolean} removeEl (optional) True to remove the element from the DOM as well (defaults to undefined)
     */
    destroy : function(X){
        Roo.EventManager.removeResizeListener(this.onResize, this);
        for(var  i = 0, len = this.items.length; i < len; i++){
            this.items[i].purgeListeners();
        }
        if(X === true){
            this.el.update("");
            this.el.remove();
        }
    }
});

/**
 * @class Roo.TabPanelItem
 * @extends Roo.util.Observable
 * Represents an individual item (tab plus body) in a TabPanel.
 * @param {Roo.TabPanel} tabPanel The {@link Roo.TabPanel} this TabPanelItem belongs to
 * @param {String} id The id of this TabPanelItem
 * @param {String} text The text for the tab of this TabPanelItem
 * @param {Boolean} closable True to allow this TabPanelItem to be closable (defaults to false)
 */
Roo.TabPanelItem = function(Y, id, Z, a){
    /**
     * The {@link Roo.TabPanel} this TabPanelItem belongs to
     * @type Roo.TabPanel
     */
    this.tabPanel = Y;
    /**
     * The id for this TabPanelItem
     * @type String
     */
    this.id = id;
    /** @private */
    this.disabled = false;
    /** @private */
    this.text = Z;
    /** @private */
    this.loaded = false;
    this.closable = a;

    /**
     * The body element for this TabPanelItem.
     * @type Roo.Element
     */
    this.bodyEl = Roo.get(Y.createItemBody(Y.bodyEl.dom, id));
    this.bodyEl.setVisibilityMode(Roo.Element.VISIBILITY);
    this.bodyEl.setStyle("display", "block");
    this.bodyEl.setStyle("zoom", "1");
    this.hideAction();

    var  d = Y.createStripElements(Y.stripEl.dom, Z, a);
    /** @private */
    this.el = Roo.get(d.el, true);
    this.inner = Roo.get(d.inner, true);
    this.textEl = Roo.get(this.el.dom.firstChild.firstChild.firstChild, true);
    this.pnode = Roo.get(d.el.parentNode, true);
    this.el.on("mousedown", this.onTabMouseDown, this);
    this.el.on("click", this.onTabClick, this);
    /** @private */
    if(a){
        var  c = Roo.get(d.close, true);
        c.dom.title = this.closeText;
        c.addClassOnOver("close-over");
        c.on("click", this.closeClick, this);
     }


    this.addEvents({
         /**
         * @event activate
         * Fires when this tab becomes the active tab.
         * @param {Roo.TabPanel} tabPanel The parent TabPanel
         * @param {Roo.TabPanelItem} this
         */
        "activate": true,
        /**
         * @event beforeclose
         * Fires before this tab is closed. To cancel the close, set cancel to true on e (e.cancel = true).
         * @param {Roo.TabPanelItem} this
         * @param {Object} e Set cancel to true on this object to cancel the close.
         */
        "beforeclose": true,
        /**
         * @event close
         * Fires when this tab is closed.
         * @param {Roo.TabPanelItem} this
         */
         "close": true,
        /**
         * @event deactivate
         * Fires when this tab is no longer the active tab.
         * @param {Roo.TabPanel} tabPanel The parent TabPanel
         * @param {Roo.TabPanelItem} this
         */
         "deactivate" : true
    });
    this.hidden = false;

    Roo.TabPanelItem.superclass.constructor.call(this);
};

Roo.extend(Roo.TabPanelItem, Roo.util.Observable, {
    purgeListeners : function(){
       Roo.util.Observable.prototype.purgeListeners.call(this);
       this.el.removeAllListeners();
    },
    /**
     * Shows this TabPanelItem -- this <b>does not</b> deactivate the currently active TabPanelItem.
     */
    show : function(){
        this.pnode.addClass("on");
        this.showAction();
        if(Roo.isOpera){
            this.tabPanel.stripWrap.repaint();
        }

        this.fireEvent("activate", this.tabPanel, this);
    },

    /**
     * Returns true if this tab is the active tab.
     * @return {Boolean}
     */
    isActive : function(){
        return  this.tabPanel.getActiveTab() == this;
    },

    /**
     * Hides this TabPanelItem -- if you don't activate another TabPanelItem this could look odd.
     */
    hide : function(){
        this.pnode.removeClass("on");
        this.hideAction();
        this.fireEvent("deactivate", this.tabPanel, this);
    },

    hideAction : function(){
        this.bodyEl.hide();
        this.bodyEl.setStyle("position", "absolute");
        this.bodyEl.setLeft("-20000px");
        this.bodyEl.setTop("-20000px");
    },

    showAction : function(){
        this.bodyEl.setStyle("position", "relative");
        this.bodyEl.setTop("");
        this.bodyEl.setLeft("");
        this.bodyEl.show();
    },

    /**
     * Set the tooltip for the tab.
     * @param {String} tooltip The tab's tooltip
     */
    setTooltip : function(f){
        if(Roo.QuickTips && Roo.QuickTips.isEnabled()){
            this.textEl.dom.qtip = f;
            this.textEl.dom.removeAttribute('title');
        }else {
            this.textEl.dom.title = f;
        }
    },

    onTabClick : function(e){
        e.preventDefault();
        this.tabPanel.activate(this.id);
    },

    onTabMouseDown : function(e){
        e.preventDefault();
        this.tabPanel.activate(this.id);
    },

    getWidth : function(){
        return  this.inner.getWidth();
    },

    setWidth : function(g){
        var  h = g - this.pnode.getPadding("lr");
        this.inner.setWidth(h);
        this.textEl.setWidth(h-this.inner.getPadding("lr"));
        this.pnode.setWidth(g);
    },

    /**
     * Show or hide the tab
     * @param {Boolean} hidden True to hide or false to show.
     */
    setHidden : function(j){
        this.hidden = j;
        this.pnode.setStyle("display", j ? "none" : "");
    },

    /**
     * Returns true if this tab is "hidden"
     * @return {Boolean}
     */
    isHidden : function(){
        return  this.hidden;
    },

    /**
     * Returns the text for this tab
     * @return {String}
     */
    getText : function(){
        return  this.text;
    },

    autoSize : function(){
        //this.el.beginMeasure();
        this.textEl.setWidth(1);
        this.setWidth(this.textEl.dom.scrollWidth+this.pnode.getPadding("lr")+this.inner.getPadding("lr"));
        //this.el.endMeasure();
    },

    /**
     * Sets the text for the tab (Note: this also sets the tooltip text)
     * @param {String} text The tab's text and tooltip
     */
    setText : function(k){
        this.text = k;
        this.textEl.update(k);
        this.setTooltip(k);
        if(!this.tabPanel.resizeTabs){
            this.autoSize();
        }
    },
    /**
     * Activates this TabPanelItem -- this <b>does</b> deactivate the currently active TabPanelItem.
     */
    activate : function(){
        this.tabPanel.activate(this.id);
    },

    /**
     * Disables this TabPanelItem -- this does nothing if this is the active TabPanelItem.
     */
    disable : function(){
        if(this.tabPanel.active != this){
            this.disabled = true;
            this.pnode.addClass("disabled");
        }
    },

    /**
     * Enables this TabPanelItem if it was previously disabled.
     */
    enable : function(){
        this.disabled = false;
        this.pnode.removeClass("disabled");
    },

    /**
     * Sets the content for this TabPanelItem.
     * @param {String} content The content
     * @param {Boolean} loadScripts true to look for and load scripts
     */
    setContent : function(l, m){
        this.bodyEl.update(l, m);
    },

    /**
     * Gets the {@link Roo.UpdateManager} for the body of this TabPanelItem. Enables you to perform Ajax updates.
     * @return {Roo.UpdateManager} The UpdateManager
     */
    getUpdateManager : function(){
        return  this.bodyEl.getUpdateManager();
    },

    /**
     * Set a URL to be used to load the content for this TabPanelItem.
     * @param {String/Function} url The URL to load the content from, or a function to call to get the URL
     * @param {String/Object} params (optional) The string params for the update call or an object of the params. See {@link Roo.UpdateManager#update} for more details. (Defaults to null)
     * @param {Boolean} loadOnce (optional) Whether to only load the content once. If this is false it makes the Ajax call every time this TabPanelItem is activated. (Defaults to false)
     * @return {Roo.UpdateManager} The UpdateManager
     */
    setUrl : function(n, o, p){
        if(this.refreshDelegate){
            this.un('activate', this.refreshDelegate);
        }

        this.refreshDelegate = this._handleRefresh.createDelegate(this, [n, o, p]);
        this.on("activate", this.refreshDelegate);
        return  this.bodyEl.getUpdateManager();
    },

    /** @private */
    _handleRefresh : function(q, r, s){
        if(!s || !this.loaded){
            var  updater = this.bodyEl.getUpdateManager();
            updater.update(q, r, this._setLoaded.createDelegate(this));
        }
    },

    /**
     *   Forces a content refresh from the URL specified in the {@link #setUrl} method.
     *   Will fail silently if the setUrl method has not been called.
     *   This does not activate the panel, just updates its content.
     */
    refresh : function(){
        if(this.refreshDelegate){
           this.loaded = false;
           this.refreshDelegate();
        }
    },

    /** @private */
    _setLoaded : function(){
        this.loaded = true;
    },

    /** @private */
    closeClick : function(e){
        var  o = {};
        e.stopEvent();
        this.fireEvent("beforeclose", this, o);
        if(o.cancel !== true){
            this.tabPanel.removeTab(this.id);
        }
    },
    /**
     * The text displayed in the tooltip for the close icon.
     * @type String
     */
    closeText : "Close this tab"
});

/** @private */
Roo.TabPanel.prototype.createStrip = function(u){
    var  v = document.createElement("div");
    v.className = "x-tabs-wrap";
    u.appendChild(v);
    return  v;
};
/** @private */
Roo.TabPanel.prototype.createStripList = function(x){
    // div wrapper for retard IE
    x.innerHTML = '<div class="x-tabs-strip-wrap"><table class="x-tabs-strip" cellspacing="0" cellpadding="0" border="0"><tbody><tr></tr></tbody></table></div>';
    return  x.firstChild.firstChild.firstChild.firstChild;
};
/** @private */
Roo.TabPanel.prototype.createBody = function(y){
    var  z = document.createElement("div");
    Roo.id(z, "tab-body");
    Roo.fly(z).addClass("x-tabs-body");
    y.appendChild(z);
    return  z;
};
/** @private */
Roo.TabPanel.prototype.createItemBody = function(AA, id){
    var  AB = Roo.getDom(id);
    if(!AB){
        AB = document.createElement("div");
        AB.id = id;
    }

    Roo.fly(AB).addClass("x-tabs-item-body");
    AA.insertBefore(AB, AA.firstChild);
    return  AB;
};
/** @private */
Roo.TabPanel.prototype.createStripElements = function(AC, AD, AE){
    var  td = document.createElement("td");
    AC.appendChild(td);
    if(AE){
        td.className = "x-tabs-closable";
        if(!this.closeTpl){
            this.closeTpl = new  Roo.Template(
               '<a href="#" class="x-tabs-right"><span class="x-tabs-left"><em class="x-tabs-inner">' +
               '<span unselectable="on"' + (this.disableTooltips ? '' : ' title="{text}"') +' class="x-tabs-text">{text}</span>' +
               '<div unselectable="on" class="close-icon">&#160;</div></em></span></a>'
            );
        }
        var  el = this.closeTpl.overwrite(td, {"text": AD});
        var  close = el.getElementsByTagName("div")[0];
        var  inner = el.getElementsByTagName("em")[0];
        return  {"el": el, "close": close, "inner": inner};
    } else  {
        if(!this.tabTpl){
            this.tabTpl = new  Roo.Template(
               '<a href="#" class="x-tabs-right"><span class="x-tabs-left"><em class="x-tabs-inner">' +
               '<span unselectable="on"' + (this.disableTooltips ? '' : ' title="{text}"') +' class="x-tabs-text">{text}</span></em></span></a>'
            );
        }
        var  el = this.tabTpl.overwrite(td, {"text": AD});
        var  inner = el.getElementsByTagName("em")[0];
        return  {"el": el, "inner": inner};
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.Button
 * @extends Roo.util.Observable
 * Simple Button class
 * @cfg {String} text The button text
 * @cfg {String} icon The path to an image to display in the button (the image will be set as the background-image
 * CSS property of the button by default, so if you want a mixed icon/text button, set cls:"x-btn-text-icon")
 * @cfg {Function} handler A function called when the button is clicked (can be used instead of click event)
 * @cfg {Object} scope The scope of the handler
 * @cfg {Number} minWidth The minimum width for this button (used to give a set of buttons a common width)
 * @cfg {String/Object} tooltip The tooltip for the button - can be a string or QuickTips config object
 * @cfg {Boolean} hidden True to start hidden (defaults to false)
 * @cfg {Boolean} disabled True to start disabled (defaults to false)
 * @cfg {Boolean} pressed True to start pressed (only if enableToggle = true)
 * @cfg {String} toggleGroup The group this toggle button is a member of (only 1 per group can be pressed, only
   applies if enableToggle = true)
 * @cfg {String/HTMLElement/Element} renderTo The element to append the button to
 * @cfg {Boolean/Object} repeat True to repeat fire the click event while the mouse is down. This can also be
  an {@link Roo.util.ClickRepeater} config object (defaults to false).
 * @constructor
 * Create a new button
 * @param {Object} config The config object
 */
Roo.Button = function(A, B)
{
    if (!B) {
        B = A;
        A = B.renderTo || false;
    }

    
    Roo.apply(this, B);
    this.addEvents({
        /**
	     * @event click
	     * Fires when this button is clicked
	     * @param {Button} this
	     * @param {EventObject} e The click event
	     */
	    "click" : true,
        /**
	     * @event toggle
	     * Fires when the "pressed" state of this button changes (only if enableToggle = true)
	     * @param {Button} this
	     * @param {Boolean} pressed
	     */
	    "toggle" : true,
        /**
	     * @event mouseover
	     * Fires when the mouse hovers over the button
	     * @param {Button} this
	     * @param {Event} e The event object
	     */
        'mouseover' : true,
        /**
	     * @event mouseout
	     * Fires when the mouse exits the button
	     * @param {Button} this
	     * @param {Event} e The event object
	     */
        'mouseout': true,
         /**
	     * @event render
	     * Fires when the button is rendered
	     * @param {Button} this
	     */
        'render': true
    });
    if(this.menu){
        this.menu = Roo.menu.MenuMgr.get(this.menu);
    }
    if(A){
        this.render(A);
    }

    
    Roo.util.Observable.call(this);
};

Roo.extend(Roo.Button, Roo.util.Observable, {
    /**
     * 
     */
    
    /**
     * Read-only. True if this button is hidden
     * @type Boolean
     */
    hidden : false,
    /**
     * Read-only. True if this button is disabled
     * @type Boolean
     */
    disabled : false,
    /**
     * Read-only. True if this button is pressed (only if enableToggle = true)
     * @type Boolean
     */
    pressed : false,

    /**
     * @cfg {Number} tabIndex 
     * The DOM tabIndex for this button (defaults to undefined)
     */
    tabIndex : undefined,

    /**
     * @cfg {Boolean} enableToggle
     * True to enable pressed/not pressed toggling (defaults to false)
     */
    enableToggle: false,
    /**
     * @cfg {Mixed} menu
     * Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
     */
    menu : undefined,
    /**
     * @cfg {String} menuAlign
     * The position to align the menu to (see {@link Roo.Element#alignTo} for more details, defaults to 'tl-bl?').
     */
    menuAlign : "tl-bl?",

    /**
     * @cfg {String} iconCls
     * A css class which sets a background image to be used as the icon for this button (defaults to undefined).
     */
    iconCls : undefined,
    /**
     * @cfg {String} type
     * The button's type, corresponding to the DOM input element type attribute.  Either "submit," "reset" or "button" (default).
     */
    type : 'button',

    // private
    menuClassTarget: 'tr',

    /**
     * @cfg {String} clickEvent
     * The type of event to map to the button's event handler (defaults to 'click')
     */
    clickEvent : 'click',

    /**
     * @cfg {Boolean} handleMouseEvents
     * False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)
     */
    handleMouseEvents : true,

    /**
     * @cfg {String} tooltipType
     * The type of tooltip to use. Either "qtip" (default) for QuickTips or "title" for title attribute.
     */
    tooltipType : 'qtip',

    /**
     * @cfg {String} cls
     * A CSS class to apply to the button's main element.
     */
    
    /**
     * @cfg {Roo.Template} template (Optional)
     * An {@link Roo.Template} with which to create the Button's main element. This Template must
     * contain numeric substitution parameter 0 if it is to display the tRoo property. Changing the template could
     * require code modifications if required elements (e.g. a button) aren't present.
     */

    // private
    render : function(C){
        var  D;
        if(this.hideParent){
            this.parentEl = Roo.get(C);
        }
        if(!this.dhconfig){
            if(!this.template){
                if(!Roo.Button.buttonTemplate){
                    // hideous table template
                    Roo.Button.buttonTemplate = new  Roo.Template(
                        '<table border="0" cellpadding="0" cellspacing="0" class="x-btn-wrap"><tbody><tr>',
                        '<td class="x-btn-left"><i>&#160;</i></td><td class="x-btn-center"><em unselectable="on"><button class="x-btn-text" type="{1}">{0}</button></em></td><td class="x-btn-right"><i>&#160;</i></td>',
                        "</tr></tbody></table>");
                }

                this.template = Roo.Button.buttonTemplate;
            }

            D = this.template.append(C, [this.text || '&#160;', this.type], true);
            var  btnEl = D.child("button:first");
            btnEl.on('focus', this.onFocus, this);
            btnEl.on('blur', this.onBlur, this);
            if(this.cls){
                D.addClass(this.cls);
            }
            if(this.icon){
                btnEl.setStyle('background-image', 'url(' +this.icon +')');
            }
            if(this.iconCls){
                btnEl.addClass(this.iconCls);
                if(!this.cls){
                    D.addClass(this.text ? 'x-btn-text-icon' : 'x-btn-icon');
                }
            }
            if(this.tabIndex !== undefined){
                btnEl.dom.tabIndex = this.tabIndex;
            }
            if(this.tooltip){
                if(typeof  this.tooltip == 'object'){
                    Roo.QuickTips.tips(Roo.apply({
                          target: btnEl.id
                    }, this.tooltip));
                } else  {
                    btnEl.dom[this.tooltipType] = this.tooltip;
                }
            }
        }else {
            D = Roo.DomHelper.append(Roo.get(C).dom, this.dhconfig, true);
        }

        this.el = D;
        if(this.id){
            this.el.dom.id = this.el.id = this.id;
        }
        if(this.menu){
            this.el.child(this.menuClassTarget).addClass("x-btn-with-menu");
            this.menu.on("show", this.onMenuShow, this);
            this.menu.on("hide", this.onMenuHide, this);
        }

        D.addClass("x-btn");
        if(Roo.isIE && !Roo.isIE7){
            this.autoWidth.defer(1, this);
        }else {
            this.autoWidth();
        }
        if(this.handleMouseEvents){
            D.on("mouseover", this.onMouseOver, this);
            D.on("mouseout", this.onMouseOut, this);
            D.on("mousedown", this.onMouseDown, this);
        }

        D.on(this.clickEvent, this.onClick, this);
        //btn.on("mouseup", this.onMouseUp, this);
        if(this.hidden){
            this.hide();
        }
        if(this.disabled){
            this.disable();
        }

        Roo.ButtonToggleMgr.register(this);
        if(this.pressed){
            this.el.addClass("x-btn-pressed");
        }
        if(this.repeat){
            var  repeater = new  Roo.util.ClickRepeater(D,
                typeof  this.repeat == "object" ? this.repeat : {}
            );
            repeater.on("click", this.onClick,  this);
        }

        this.fireEvent('render', this);
        
    },
    /**
     * Returns the button's underlying element
     * @return {Roo.Element} The element
     */
    getEl : function(){
        return  this.el;  
    },
    
    /**
     * Destroys this Button and removes any listeners.
     */
    destroy : function(){
        Roo.ButtonToggleMgr.unregister(this);
        this.el.removeAllListeners();
        this.purgeListeners();
        this.el.remove();
    },

    // private
    autoWidth : function(){
        if(this.el){
            this.el.setWidth("auto");
            if(Roo.isIE7 && Roo.isStrict){
                var  ib = this.el.child('button');
                if(ib && ib.getWidth() > 20){
                    ib.clip();
                    ib.setWidth(Roo.util.TextMetrics.measure(ib, this.text).width+ib.getFrameWidth('lr'));
                }
            }
            if(this.minWidth){
                if(this.hidden){
                    this.el.beginMeasure();
                }
                if(this.el.getWidth() < this.minWidth){
                    this.el.setWidth(this.minWidth);
                }
                if(this.hidden){
                    this.el.endMeasure();
                }
            }
        }
    },

    /**
     * Assigns this button's click handler
     * @param {Function} handler The function to call when the button is clicked
     * @param {Object} scope (optional) Scope for the function passed in
     */
    setHandler : function(E, F){
        this.handler = E;
        this.scope = F;  
    },
    
    /**
     * Sets this button's text
     * @param {String} text The button text
     */
    setText : function(G){
        this.text = G;
        if(this.el){
            this.el.child("td.x-btn-center button.x-btn-text").update(G);
        }

        this.autoWidth();
    },
    
    /**
     * Gets the text for this button
     * @return {String} The button text
     */
    getText : function(){
        return  this.text;  
    },
    
    /**
     * Show this button
     */
    show: function(){
        this.hidden = false;
        if(this.el){
            this[this.hideParent? 'parentEl' : 'el'].setStyle("display", "");
        }
    },
    
    /**
     * Hide this button
     */
    hide: function(){
        this.hidden = true;
        if(this.el){
            this[this.hideParent? 'parentEl' : 'el'].setStyle("display", "none");
        }
    },
    
    /**
     * Convenience function for boolean show/hide
     * @param {Boolean} visible True to show, false to hide
     */
    setVisible: function(H){
        if(H) {
            this.show();
        }else {
            this.hide();
        }
    },
    
    /**
     * If a state it passed, it becomes the pressed state otherwise the current state is toggled.
     * @param {Boolean} state (optional) Force a particular state
     */
    toggle : function(I){
        I = I === undefined ? !this.pressed : I;
        if(I != this.pressed){
            if(I){
                this.el.addClass("x-btn-pressed");
                this.pressed = true;
                this.fireEvent("toggle", this, true);
            }else {
                this.el.removeClass("x-btn-pressed");
                this.pressed = false;
                this.fireEvent("toggle", this, false);
            }
            if(this.toggleHandler){
                this.toggleHandler.call(this.scope || this, this, I);
            }
        }
    },
    
    /**
     * Focus the button
     */
    focus : function(){
        this.el.child('button:first').focus();
    },
    
    /**
     * Disable this button
     */
    disable : function(){
        if(this.el){
            this.el.addClass("x-btn-disabled");
        }

        this.disabled = true;
    },
    
    /**
     * Enable this button
     */
    enable : function(){
        if(this.el){
            this.el.removeClass("x-btn-disabled");
        }

        this.disabled = false;
    },

    /**
     * Convenience function for boolean enable/disable
     * @param {Boolean} enabled True to enable, false to disable
     */
    setDisabled : function(v){
        this[v !== true ? "enable" : "disable"]();
    },

    // private
    onClick : function(e){
        if(e){
            e.preventDefault();
        }
        if(e.button != 0){
            return;
        }
        if(!this.disabled){
            if(this.enableToggle){
                this.toggle();
            }
            if(this.menu && !this.menu.isVisible()){
                this.menu.show(this.el, this.menuAlign);
            }

            this.fireEvent("click", this, e);
            if(this.handler){
                this.el.removeClass("x-btn-over");
                this.handler.call(this.scope || this, this, e);
            }
        }
    },
    // private
    onMouseOver : function(e){
        if(!this.disabled){
            this.el.addClass("x-btn-over");
            this.fireEvent('mouseover', this, e);
        }
    },
    // private
    onMouseOut : function(e){
        if(!e.within(this.el,  true)){
            this.el.removeClass("x-btn-over");
            this.fireEvent('mouseout', this, e);
        }
    },
    // private
    onFocus : function(e){
        if(!this.disabled){
            this.el.addClass("x-btn-focus");
        }
    },
    // private
    onBlur : function(e){
        this.el.removeClass("x-btn-focus");
    },
    // private
    onMouseDown : function(e){
        if(!this.disabled && e.button == 0){
            this.el.addClass("x-btn-click");
            Roo.get(document).on('mouseup', this.onMouseUp, this);
        }
    },
    // private
    onMouseUp : function(e){
        if(e.button == 0){
            this.el.removeClass("x-btn-click");
            Roo.get(document).un('mouseup', this.onMouseUp, this);
        }
    },
    // private
    onMenuShow : function(e){
        this.el.addClass("x-btn-menu-active");
    },
    // private
    onMenuHide : function(e){
        this.el.removeClass("x-btn-menu-active");
    }   
});

// Private utility class used by Button
Roo.ButtonToggleMgr = function(){
   var  J = {};
   
   function  K(L, M){
       if(M){
           var  g = J[L.toggleGroup];
           for(var  i = 0, l = g.length; i < l; i++){
               if(g[i] != L){
                   g[i].toggle(false);
               }
           }
       }
   }
   
   return  {
       register : function(N){
           if(!N.toggleGroup){
               return;
           }
           var  g = J[N.toggleGroup];
           if(!g){
               g = J[N.toggleGroup] = [];
           }

           g.push(N);
           N.on("toggle", K);
       },
       
       unregister : function(O){
           if(!O.toggleGroup){
               return;
           }
           var  g = J[O.toggleGroup];
           if(g){
               g.remove(O);
               O.un("toggle", K);
           }
       }
   };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.SplitButton
 * @extends Roo.Button
 * A split button that provides a built-in dropdown arrow that can fire an event separately from the default
 * click event of the button.  Typically this would be used to display a dropdown menu that provides additional
 * options to the primary button action, but any custom handler can provide the arrowclick implementation.
 * @cfg {Function} arrowHandler A function called when the arrow button is clicked (can be used instead of click event)
 * @cfg {String} arrowTooltip The title attribute of the arrow
 * @constructor
 * Create a new menu button
 * @param {String/HTMLElement/Element} renderTo The element to append the button to
 * @param {Object} config The config object
 */
Roo.SplitButton = function(A, B){
    Roo.SplitButton.superclass.constructor.call(this, A, B);
    /**
     * @event arrowclick
     * Fires when this button's arrow is clicked
     * @param {SplitButton} this
     * @param {EventObject} e The click event
     */
    this.addEvents({"arrowclick":true});
};

Roo.extend(Roo.SplitButton, Roo.Button, {
    render : function(C){
        // this is one sweet looking template!
        var  D = new  Roo.Template(
            '<table cellspacing="0" class="x-btn-menu-wrap x-btn"><tr><td>',
            '<table cellspacing="0" class="x-btn-wrap x-btn-menu-text-wrap"><tbody>',
            '<tr><td class="x-btn-left"><i>&#160;</i></td><td class="x-btn-center"><button class="x-btn-text" type="{1}">{0}</button></td></tr>',
            "</tbody></table></td><td>",
            '<table cellspacing="0" class="x-btn-wrap x-btn-menu-arrow-wrap"><tbody>',
            '<tr><td class="x-btn-center"><button class="x-btn-menu-arrow-el" type="button">&#160;</button></td><td class="x-btn-right"><i>&#160;</i></td></tr>',
            "</tbody></table></td></tr></table>"
        );
        var  E = D.append(C, [this.text, this.type], true);
        var  F = E.child("button");
        if(this.cls){
            E.addClass(this.cls);
        }
        if(this.icon){
            F.setStyle('background-image', 'url(' +this.icon +')');
        }
        if(this.iconCls){
            F.addClass(this.iconCls);
            if(!this.cls){
                E.addClass(this.text ? 'x-btn-text-icon' : 'x-btn-icon');
            }
        }

        this.el = E;
        if(this.handleMouseEvents){
            E.on("mouseover", this.onMouseOver, this);
            E.on("mouseout", this.onMouseOut, this);
            E.on("mousedown", this.onMouseDown, this);
            E.on("mouseup", this.onMouseUp, this);
        }

        E.on(this.clickEvent, this.onClick, this);
        if(this.tooltip){
            if(typeof  this.tooltip == 'object'){
                Roo.QuickTips.tips(Roo.apply({
                      target: F.id
                }, this.tooltip));
            } else  {
                F.dom[this.tooltipType] = this.tooltip;
            }
        }
        if(this.arrowTooltip){
            E.child("button:nth(2)").dom[this.tooltipType] = this.arrowTooltip;
        }
        if(this.hidden){
            this.hide();
        }
        if(this.disabled){
            this.disable();
        }
        if(this.pressed){
            this.el.addClass("x-btn-pressed");
        }
        if(Roo.isIE && !Roo.isIE7){
            this.autoWidth.defer(1, this);
        }else {
            this.autoWidth();
        }
        if(this.menu){
            this.menu.on("show", this.onMenuShow, this);
            this.menu.on("hide", this.onMenuHide, this);
        }

        this.fireEvent('render', this);
    },

    // private
    autoWidth : function(){
        if(this.el){
            var  tbl = this.el.child("table:first");
            var  tbl2 = this.el.child("table:last");
            this.el.setWidth("auto");
            tbl.setWidth("auto");
            if(Roo.isIE7 && Roo.isStrict){
                var  ib = this.el.child('button:first');
                if(ib && ib.getWidth() > 20){
                    ib.clip();
                    ib.setWidth(Roo.util.TextMetrics.measure(ib, this.text).width+ib.getFrameWidth('lr'));
                }
            }
            if(this.minWidth){
                if(this.hidden){
                    this.el.beginMeasure();
                }
                if((tbl.getWidth()+tbl2.getWidth()) < this.minWidth){
                    tbl.setWidth(this.minWidth-tbl2.getWidth());
                }
                if(this.hidden){
                    this.el.endMeasure();
                }
            }

            this.el.setWidth(tbl.getWidth()+tbl2.getWidth());
        } 
    },
    /**
     * Sets this button's click handler
     * @param {Function} handler The function to call when the button is clicked
     * @param {Object} scope (optional) Scope for the function passed above
     */
    setHandler : function(G, H){
        this.handler = G;
        this.scope = H;  
    },
    
    /**
     * Sets this button's arrow click handler
     * @param {Function} handler The function to call when the arrow is clicked
     * @param {Object} scope (optional) Scope for the function passed above
     */
    setArrowHandler : function(I, J){
        this.arrowHandler = I;
        this.scope = J;  
    },
    
    /**
     * Focus the button
     */
    focus : function(){
        if(this.el){
            this.el.child("button:first").focus();
        }
    },

    // private
    onClick : function(e){
        e.preventDefault();
        if(!this.disabled){
            if(e.getTarget(".x-btn-menu-arrow-wrap")){
                if(this.menu && !this.menu.isVisible()){
                    this.menu.show(this.el, this.menuAlign);
                }

                this.fireEvent("arrowclick", this, e);
                if(this.arrowHandler){
                    this.arrowHandler.call(this.scope || this, this, e);
                }
            }else {
                this.fireEvent("click", this, e);
                if(this.handler){
                    this.handler.call(this.scope || this, this, e);
                }
            }
        }
    },
    // private
    onMouseDown : function(e){
        if(!this.disabled){
            Roo.fly(e.getTarget("table")).addClass("x-btn-click");
        }
    },
    // private
    onMouseUp : function(e){
        Roo.fly(e.getTarget("table")).removeClass("x-btn-click");
    }   
});


// backwards compat
Roo.MenuButton = Roo.SplitButton;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.Toolbar
 * Basic Toolbar class.
 * @constructor
 * Creates a new Toolbar
 * @param {Object} config The config object
 */ 
Roo.Toolbar = function(A, B, C)
{
    /// old consturctor format still supported..
    if(A  instanceof  Array){ // omit the container for later rendering
        B = A;
        C = B;
        A = null;
    }
    if (typeof(A) == 'object' && A.xtype) {
        C = A;
        A = C.container;
        B = C.buttons; // not really - use items!!
    }
    var  D = [];
    if (C && C.items) {
        D = C.items;
        delete  C.items;
    }

    Roo.apply(this, C);
    this.buttons = B;
    
    if(A){
        this.render(A);
    }

    Roo.each(D, function(b) {
        this.add(b);
    }, this);
    
};

Roo.Toolbar.prototype = {
    /**
     * @cfg {Roo.data.Store} items
     * array of button configs or elements to add
     */
    
    /**
     * @cfg {String/HTMLElement/Element} container
     * The id or element that will contain the toolbar
     */
    // private
    render : function(ct){
        this.el = Roo.get(ct);
        if(this.cls){
            this.el.addClass(this.cls);
        }

        // using a table allows for vertical alignment
        // 100% width is needed by Safari...
        this.el.update('<div class="x-toolbar x-small-editor"><table cellspacing="0"><tr></tr></table></div>');
        this.tr = this.el.child("tr", true);
        var  E = 0;
        this.items = new  Roo.util.MixedCollection(false, function(o){
            return  o.id || ("item" + (++E));
        });
        if(this.buttons){
            this.add.apply(this, this.buttons);
            delete  this.buttons;
        }
    },

    /**
     * Adds element(s) to the toolbar -- this function takes a variable number of 
     * arguments of mixed type and adds them to the toolbar.
     * @param {Mixed} arg1 The following types of arguments are all valid:<br />
     * <ul>
     * <li>{@link Roo.Toolbar.Button} config: A valid button config object (equivalent to {@link #addButton})</li>
     * <li>HtmlElement: Any standard HTML element (equivalent to {@link #addElement})</li>
     * <li>Field: Any form field (equivalent to {@link #addField})</li>
     * <li>Item: Any subclass of {@link Roo.Toolbar.Item} (equivalent to {@link #addItem})</li>
     * <li>String: Any generic string (gets wrapped in a {@link Roo.Toolbar.TextItem}, equivalent to {@link #addText}).
     * Note that there are a few special strings that are treated differently as explained nRoo.</li>
     * <li>'separator' or '-': Creates a separator element (equivalent to {@link #addSeparator})</li>
     * <li>' ': Creates a spacer element (equivalent to {@link #addSpacer})</li>
     * <li>'->': Creates a fill element (equivalent to {@link #addFill})</li>
     * </ul>
     * @param {Mixed} arg2
     * @param {Mixed} etc.
     */
    add : function(){
        var  a = arguments, l = a.length;
        for(var  i = 0; i < l; i++){
            this._add(a[i]);
        }
    },
    // private..
    _add : function(el) {
        
        if (el.xtype) {
            el = Roo.factory(el, typeof(Roo.Toolbar[el.xtype]) == 'undefined' ? Roo.form : Roo.Toolbar);
        }
        
        if (el.applyTo){ // some kind of form field
            return  this.addField(el);
        } 
        if (el.render){ // some kind of Toolbar.Item
            return  this.addItem(el);
        }
        if (typeof  el == "string"){ // string
            if(el == "separator" || el == "-"){
                return  this.addSeparator();
            }
            if (el == " "){
                return  this.addSpacer();
            }
            if(el == "->"){
                return  this.addFill();
            }
            return  this.addText(el);
            
        }
        if(el.tagName){ // element
            return  this.addElement(el);
        }
        if(typeof  el == "object"){ // must be button config?
            return  this.addButton(el);
        }
        // and now what?!?!
        return  false;
        
    },
    
    /**
     * Add an Xtype element
     * @param {Object} xtype Xtype Object
     * @return {Object} created Object
     */
    addxtype : function(e){
        return  this.add(e);  
    },
    
    /**
     * Returns the Element for this toolbar.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.el;  
    },
    
    /**
     * Adds a separator
     * @return {Roo.Toolbar.Item} The separator item
     */
    addSeparator : function(){
        return  this.addItem(new  Roo.Toolbar.Separator());
    },

    /**
     * Adds a spacer element
     * @return {Roo.Toolbar.Spacer} The spacer item
     */
    addSpacer : function(){
        return  this.addItem(new  Roo.Toolbar.Spacer());
    },

    /**
     * Adds a fill element that forces subsequent additions to the right side of the toolbar
     * @return {Roo.Toolbar.Fill} The fill item
     */
    addFill : function(){
        return  this.addItem(new  Roo.Toolbar.Fill());
    },

    /**
     * Adds any standard HTML element to the toolbar
     * @param {String/HTMLElement/Element} el The element or id of the element to add
     * @return {Roo.Toolbar.Item} The element's item
     */
    addElement : function(el){
        return  this.addItem(new  Roo.Toolbar.Item(el));
    },
    /**
     * Collection of items on the toolbar.. (only Toolbar Items, so use fields to retrieve fields)
     * @type Roo.util.MixedCollection  
     */
    items : false,
     
    /**
     * Adds any Toolbar.Item or subclass
     * @param {Roo.Toolbar.Item} item
     * @return {Roo.Toolbar.Item} The item
     */
    addItem : function(F){
        var  td = this.nextBlock();
        F.render(td);
        this.items.add(F);
        return  F;
    },
    
    /**
     * Adds a button (or buttons). See {@link Roo.Toolbar.Button} for more info on the config.
     * @param {Object/Array} config A button config or array of configs
     * @return {Roo.Toolbar.Button/Array}
     */
    addButton : function(G){
        if(G  instanceof  Array){
            var  B = [];
            for(var  i = 0, len = G.length; i < len; i++) {
                B.push(this.addButton(G[i]));
            }
            return  B;
        }
        var  b = G;
        if(!(G  instanceof  Roo.Toolbar.Button)){
            b = G.split ?
                new  Roo.Toolbar.SplitButton(G) :
                new  Roo.Toolbar.Button(G);
        }
        var  td = this.nextBlock();
        b.render(td);
        this.items.add(b);
        return  b;
    },
    
    /**
     * Adds text to the toolbar
     * @param {String} text The text to add
     * @return {Roo.Toolbar.Item} The element's item
     */
    addText : function(H){
        return  this.addItem(new  Roo.Toolbar.TextItem(H));
    },
    
    /**
     * Inserts any {@link Roo.Toolbar.Item}/{@link Roo.Toolbar.Button} at the specified index.
     * @param {Number} index The index where the item is to be inserted
     * @param {Object/Roo.Toolbar.Item/Roo.Toolbar.Button (may be Array)} item The button, or button config object to be inserted.
     * @return {Roo.Toolbar.Button/Item}
     */
    insertButton : function(I, J){
        if(J  instanceof  Array){
            var  B = [];
            for(var  i = 0, len = J.length; i < len; i++) {
               B.push(this.insertButton(I + i, J[i]));
            }
            return  B;
        }
        if (!(J  instanceof  Roo.Toolbar.Button)){
           J = new  Roo.Toolbar.Button(J);
        }
        var  td = document.createElement("td");
        this.tr.insertBefore(td, this.tr.childNodes[I]);
        J.render(td);
        this.items.insert(I, J);
        return  J;
    },
    
    /**
     * Adds a new element to the toolbar from the passed {@link Roo.DomHelper} config.
     * @param {Object} config
     * @return {Roo.Toolbar.Item} The element's item
     */
    addDom : function(K, L){
        var  td = this.nextBlock();
        Roo.DomHelper.overwrite(td, K);
        var  ti = new  Roo.Toolbar.Item(td.firstChild);
        ti.render(td);
        this.items.add(ti);
        return  ti;
    },

    /**
     * Collection of fields on the toolbar.. usefull for quering (value is false if there are no fields)
     * @type Roo.util.MixedCollection  
     */
    fields : false,
    
    /**
     * Adds a dynamically rendered Roo.form field (TextField, ComboBox, etc). Note: the field should not have
     * been rendered yet. For a field that has already been rendered, use {@link #addElement}.
     * @param {Roo.form.Field} field
     * @return {Roo.ToolbarItem}
     */
     
      
    addField : function(M) {
        if (!this.fields) {
            var  E = 0;
            this.fields = new  Roo.util.MixedCollection(false, function(o){
                return  o.id || ("item" + (++E));
            });

        }
        
        var  td = this.nextBlock();
        M.render(td);
        var  ti = new  Roo.Toolbar.Item(td.firstChild);
        ti.render(td);
        this.items.add(ti);
        this.fields.add(M);
        return  ti;
    },
    /**
     * Hide the toolbar
     * @method hide
     */
     
      
    hide : function()
    {
        this.el.child('div').setVisibilityMode(Roo.Element.DISPLAY);
        this.el.child('div').hide();
    },
    /**
     * Show the toolbar
     * @method show
     */
    show : function()
    {
        this.el.child('div').show();
    },
      
    // private
    nextBlock : function(){
        var  td = document.createElement("td");
        this.tr.appendChild(td);
        return  td;
    },

    // private
    destroy : function(){
        if(this.items){ // rendered?
            Roo.destroy.apply(Roo, this.items.items);
        }
        if(this.fields){ // rendered?
            Roo.destroy.apply(Roo, this.fields.items);
        }

        Roo.Element.uncache(this.el, this.tr);
    }
};

/**
 * @class Roo.Toolbar.Item
 * The base class that other classes should extend in order to get some basic common toolbar item functionality.
 * @constructor
 * Creates a new Item
 * @param {HTMLElement} el 
 */
Roo.Toolbar.Item = function(el){
    this.el = Roo.getDom(el);
    this.id = Roo.id(this.el);
    this.hidden = false;
};

Roo.Toolbar.Item.prototype = {
    
    /**
     * Get this item's HTML Element
     * @return {HTMLElement}
     */
    getEl : function(){
       return  this.el;  
    },

    // private
    render : function(td){
        this.td = td;
        td.appendChild(this.el);
    },
    
    /**
     * Removes and destroys this item.
     */
    destroy : function(){
        this.td.parentNode.removeChild(this.td);
    },
    
    /**
     * Shows this item.
     */
    show: function(){
        this.hidden = false;
        this.td.style.display = "";
    },
    
    /**
     * Hides this item.
     */
    hide: function(){
        this.hidden = true;
        this.td.style.display = "none";
    },
    
    /**
     * Convenience function for boolean show/hide.
     * @param {Boolean} visible true to show/false to hide
     */
    setVisible: function(N){
        if(N) {
            this.show();
        }else {
            this.hide();
        }
    },
    
    /**
     * Try to focus this item.
     */
    focus : function(){
        Roo.fly(this.el).focus();
    },
    
    /**
     * Disables this item.
     */
    disable : function(){
        Roo.fly(this.td).addClass("x-item-disabled");
        this.disabled = true;
        this.el.disabled = true;
    },
    
    /**
     * Enables this item.
     */
    enable : function(){
        Roo.fly(this.td).removeClass("x-item-disabled");
        this.disabled = false;
        this.el.disabled = false;
    }
};


/**
 * @class Roo.Toolbar.Separator
 * @extends Roo.Toolbar.Item
 * A simple toolbar separator class
 * @constructor
 * Creates a new Separator
 */
Roo.Toolbar.Separator = function(){
    var  s = document.createElement("span");
    s.className = "ytb-sep";
    Roo.Toolbar.Separator.superclass.constructor.call(this, s);
};
Roo.extend(Roo.Toolbar.Separator, Roo.Toolbar.Item, {
    enable:Roo.emptyFn,
    disable:Roo.emptyFn,
    focus:Roo.emptyFn
});

/**
 * @class Roo.Toolbar.Spacer
 * @extends Roo.Toolbar.Item
 * A simple element that adds extra horizontal space to a toolbar.
 * @constructor
 * Creates a new Spacer
 */
Roo.Toolbar.Spacer = function(){
    var  s = document.createElement("div");
    s.className = "ytb-spacer";
    Roo.Toolbar.Spacer.superclass.constructor.call(this, s);
};
Roo.extend(Roo.Toolbar.Spacer, Roo.Toolbar.Item, {
    enable:Roo.emptyFn,
    disable:Roo.emptyFn,
    focus:Roo.emptyFn
});

/**
 * @class Roo.Toolbar.Fill
 * @extends Roo.Toolbar.Spacer
 * A simple element that adds a greedy (100% width) horizontal space to a toolbar.
 * @constructor
 * Creates a new Spacer
 */
Roo.Toolbar.Fill = Roo.extend(Roo.Toolbar.Spacer, {
    // private
    render : function(td){
        td.style.width = '100%';
        Roo.Toolbar.Fill.superclass.render.call(this, td);
    }
});

/**
 * @class Roo.Toolbar.TextItem
 * @extends Roo.Toolbar.Item
 * A simple class that renders text directly into a toolbar.
 * @constructor
 * Creates a new TextItem
 * @param {String} text
 */
Roo.Toolbar.TextItem = function(O){
    if (typeof(O) == 'object') {
        O = O.text;
    }
    var  s = document.createElement("span");
    s.className = "ytb-text";
    s.innerHTML = O;
    Roo.Toolbar.TextItem.superclass.constructor.call(this, s);
};
Roo.extend(Roo.Toolbar.TextItem, Roo.Toolbar.Item, {
    enable:Roo.emptyFn,
    disable:Roo.emptyFn,
    focus:Roo.emptyFn
});

/**
 * @class Roo.Toolbar.Button
 * @extends Roo.Button
 * A button that renders into a toolbar.
 * @constructor
 * Creates a new Button
 * @param {Object} config A standard {@link Roo.Button} config object
 */
Roo.Toolbar.Button = function(P){
    Roo.Toolbar.Button.superclass.constructor.call(this, null, P);
};
Roo.extend(Roo.Toolbar.Button, Roo.Button, {
    render : function(td){
        this.td = td;
        Roo.Toolbar.Button.superclass.render.call(this, td);
    },
    
    /**
     * Removes and destroys this button
     */
    destroy : function(){
        Roo.Toolbar.Button.superclass.destroy.call(this);
        this.td.parentNode.removeChild(this.td);
    },
    
    /**
     * Shows this button
     */
    show: function(){
        this.hidden = false;
        this.td.style.display = "";
    },
    
    /**
     * Hides this button
     */
    hide: function(){
        this.hidden = true;
        this.td.style.display = "none";
    },

    /**
     * Disables this item
     */
    disable : function(){
        Roo.fly(this.td).addClass("x-item-disabled");
        this.disabled = true;
    },

    /**
     * Enables this item
     */
    enable : function(){
        Roo.fly(this.td).removeClass("x-item-disabled");
        this.disabled = false;
    }
});
// backwards compat
Roo.ToolbarButton = Roo.Toolbar.Button;

/**
 * @class Roo.Toolbar.SplitButton
 * @extends Roo.SplitButton
 * A menu button that renders into a toolbar.
 * @constructor
 * Creates a new SplitButton
 * @param {Object} config A standard {@link Roo.SplitButton} config object
 */
Roo.Toolbar.SplitButton = function(Q){
    Roo.Toolbar.SplitButton.superclass.constructor.call(this, null, Q);
};
Roo.extend(Roo.Toolbar.SplitButton, Roo.SplitButton, {
    render : function(td){
        this.td = td;
        Roo.Toolbar.SplitButton.superclass.render.call(this, td);
    },
    
    /**
     * Removes and destroys this button
     */
    destroy : function(){
        Roo.Toolbar.SplitButton.superclass.destroy.call(this);
        this.td.parentNode.removeChild(this.td);
    },
    
    /**
     * Shows this button
     */
    show: function(){
        this.hidden = false;
        this.td.style.display = "";
    },
    
    /**
     * Hides this button
     */
    hide: function(){
        this.hidden = true;
        this.td.style.display = "none";
    }
});

// backwards compat
Roo.Toolbar.MenuButton = Roo.Toolbar.SplitButton;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.PagingToolbar
 * @extends Roo.Toolbar
 * A specialized toolbar that is bound to a {@link Roo.data.Store} and provides automatic paging controls.
 * @constructor
 * Create a new PagingToolbar
 * @param {Object} config The config object
 */
Roo.PagingToolbar = function(el, ds, A)
{
    // old args format still supported... - xtype is prefered..
    if (typeof(el) == 'object' && el.xtype) {
        // created from xtype...
        A = el;
        ds = el.dataSource;
        el = A.container;
    }

    
    
    Roo.PagingToolbar.superclass.constructor.call(this, el, null, A);
    this.ds = ds;
    this.cursor = 0;
    this.renderButtons(this.el);
    this.bind(ds);
};

Roo.extend(Roo.PagingToolbar, Roo.Toolbar, {
    /**
     * @cfg {Roo.data.Store} dataSource
     * The underlying data store providing the paged data
     */
    /**
     * @cfg {String/HTMLElement/Element} container
     * container The id or element that will contain the toolbar
     */
    /**
     * @cfg {Boolean} displayInfo
     * True to display the displayMsg (defaults to false)
     */
    /**
     * @cfg {Number} pageSize
     * The number of records to display per page (defaults to 20)
     */
    pageSize: 20,
    /**
     * @cfg {String} displayMsg
     * The paging status message to display (defaults to "Displaying {start} - {end} of {total}")
     */
    displayMsg : 'Displaying {0} - {1} of {2}',
    /**
     * @cfg {String} emptyMsg
     * The message to display when no records are found (defaults to "No data to display")
     */
    emptyMsg : 'No data to display',
    /**
     * Customizable piece of the default paging text (defaults to "Page")
     * @type String
     */
    beforePageText : "Page",
    /**
     * Customizable piece of the default paging text (defaults to "of %0")
     * @type String
     */
    afterPageText : "of {0}",
    /**
     * Customizable piece of the default paging text (defaults to "First Page")
     * @type String
     */
    firstText : "First Page",
    /**
     * Customizable piece of the default paging text (defaults to "Previous Page")
     * @type String
     */
    prevText : "Previous Page",
    /**
     * Customizable piece of the default paging text (defaults to "Next Page")
     * @type String
     */
    nextText : "Next Page",
    /**
     * Customizable piece of the default paging text (defaults to "Last Page")
     * @type String
     */
    lastText : "Last Page",
    /**
     * Customizable piece of the default paging text (defaults to "Refresh")
     * @type String
     */
    refreshText : "Refresh",

    // private
    renderButtons : function(el){
        Roo.PagingToolbar.superclass.render.call(this, el);
        this.first = this.addButton({
            tooltip: this.firstText,
            cls: "x-btn-icon x-grid-page-first",
            disabled: true,
            handler: this.onClick.createDelegate(this, ["first"])
        });
        this.prev = this.addButton({
            tooltip: this.prevText,
            cls: "x-btn-icon x-grid-page-prev",
            disabled: true,
            handler: this.onClick.createDelegate(this, ["prev"])
        });
        this.addSeparator();
        this.add(this.beforePageText);
        this.field = Roo.get(this.addDom({
           tag: "input",
           type: "text",
           size: "3",
           value: "1",
           cls: "x-grid-page-number"
        }).el);
        this.field.on("keydown", this.onPagingKeydown, this);
        this.field.on("focus", function(){this.dom.select();});
        this.afterTextEl = this.addText(String.format(this.afterPageText, 1));
        this.field.setHeight(18);
        this.addSeparator();
        this.next = this.addButton({
            tooltip: this.nextText,
            cls: "x-btn-icon x-grid-page-next",
            disabled: true,
            handler: this.onClick.createDelegate(this, ["next"])
        });
        this.last = this.addButton({
            tooltip: this.lastText,
            cls: "x-btn-icon x-grid-page-last",
            disabled: true,
            handler: this.onClick.createDelegate(this, ["last"])
        });
        this.addSeparator();
        this.loading = this.addButton({
            tooltip: this.refreshText,
            cls: "x-btn-icon x-grid-loading",
            handler: this.onClick.createDelegate(this, ["refresh"])
        });

        if(this.displayInfo){
            this.displayEl = Roo.fly(this.el.dom.firstChild).createChild({cls:'x-paging-info'});
        }
    },

    // private
    updateInfo : function(){
        if(this.displayEl){
            var  count = this.ds.getCount();
            var  msg = count == 0 ?
                this.emptyMsg :
                String.format(
                    this.displayMsg,
                    this.cursor+1, this.cursor+count, this.ds.getTotalCount()    
                );
            this.displayEl.update(msg);
        }
    },

    // private
    onLoad : function(ds, r, o){
       this.cursor = o.params ? o.params.start : 0;
       var  d = this.getPageData(), ap = d.activePage, ps = d.pages;

       this.afterTextEl.el.innerHTML = String.format(this.afterPageText, d.pages);
       this.field.dom.value = ap;
       this.first.setDisabled(ap == 1);
       this.prev.setDisabled(ap == 1);
       this.next.setDisabled(ap == ps);
       this.last.setDisabled(ap == ps);
       this.loading.enable();
       this.updateInfo();
    },

    // private
    getPageData : function(){
        var  B = this.ds.getTotalCount();
        return  {
            total : B,
            activePage : Math.ceil((this.cursor+this.pageSize)/this.pageSize),
            pages :  B < this.pageSize ? 1 : Math.ceil(B/this.pageSize)
        };
    },

    // private
    onLoadError : function(){
        this.loading.enable();
    },

    // private
    onPagingKeydown : function(e){
        var  k = e.getKey();
        var  d = this.getPageData();
        if(k == e.RETURN ){
            var  v = this.field.dom.value, pageNum;
            if(!v || isNaN(pageNum = parseInt(v, 10))){
                this.field.dom.value = d.activePage;
                return;
            }

            pageNum = Math.min(Math.max(1, pageNum), d.pages) - 1;
            this.ds.load({params:{start: pageNum * this.pageSize, limit: this.pageSize}});
            e.stopEvent();
        }
        else  if(k == e.HOME || (k == e.UP && e.ctrlKey) || (k == e.PAGEUP && e.ctrlKey) || (k == e.RIGHT && e.ctrlKey) || k == e.END || (k == e.DOWN && e.ctrlKey) || (k == e.LEFT && e.ctrlKey) || (k == e.PAGEDOWN && e.ctrlKey))
        {
          var  pageNum = (k == e.HOME || (k == e.DOWN && e.ctrlKey) || (k == e.LEFT && e.ctrlKey) || (k == e.PAGEDOWN && e.ctrlKey)) ? 1 : d.pages;
          this.field.dom.value = pageNum;
          this.ds.load({params:{start: (pageNum - 1) * this.pageSize, limit: this.pageSize}});
          e.stopEvent();
        }
        else  if(k == e.UP || k == e.RIGHT || k == e.PAGEUP || k == e.DOWN || k == e.LEFT || k == e.PAGEDOWN)
        {
          var  v = this.field.dom.value, pageNum; 
          var  increment = (e.shiftKey) ? 10 : 1;
          if(k == e.DOWN || k == e.LEFT || k == e.PAGEDOWN)
            increment *= -1;
          if(!v || isNaN(pageNum = parseInt(v, 10))) {
            this.field.dom.value = d.activePage;
            return;
          }
          else  if(parseInt(v, 10) + increment >= 1 & parseInt(v, 10) + increment <= d.pages)
          {
            this.field.dom.value = parseInt(v, 10) + increment;
            pageNum = Math.min(Math.max(1, pageNum + increment), d.pages) - 1;
            this.ds.load({params:{start: pageNum * this.pageSize, limit: this.pageSize}});
          }

          e.stopEvent();
        }
    },

    // private
    beforeLoad : function(){
        if(this.loading){
            this.loading.disable();
        }
    },

    // private
    onClick : function(C){
        var  ds = this.ds;
        switch(C){
            case  "first":
                ds.load({params:{start: 0, limit: this.pageSize}});
            break;
            case  "prev":
                ds.load({params:{start: Math.max(0, this.cursor-this.pageSize), limit: this.pageSize}});
            break;
            case  "next":
                ds.load({params:{start: this.cursor+this.pageSize, limit: this.pageSize}});
            break;
            case  "last":
                var  B = ds.getTotalCount();
                var  extra = B % this.pageSize;
                var  lastStart = extra ? (B - extra) : B-this.pageSize;
                ds.load({params:{start: lastStart, limit: this.pageSize}});
            break;
            case  "refresh":
                ds.load({params:{start: this.cursor, limit: this.pageSize}});
            break;
        }
    },

    /**
     * Unbinds the paging toolbar from the specified {@link Roo.data.Store}
     * @param {Roo.data.Store} store The data store to unbind
     */
    unbind : function(ds){
        ds.un("beforeload", this.beforeLoad, this);
        ds.un("load", this.onLoad, this);
        ds.un("loadexception", this.onLoadError, this);
        ds.un("remove", this.updateInfo, this);
        ds.un("add", this.updateInfo, this);
        this.ds = undefined;
    },

    /**
     * Binds the paging toolbar to the specified {@link Roo.data.Store}
     * @param {Roo.data.Store} store The data store to bind
     */
    bind : function(ds){
        ds.on("beforeload", this.beforeLoad, this);
        ds.on("load", this.onLoad, this);
        ds.on("loadexception", this.onLoadError, this);
        ds.on("remove", this.updateInfo, this);
        ds.on("add", this.updateInfo, this);
        this.ds = ds;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.Resizable
 * @extends Roo.util.Observable
 * <p>Applies drag handles to an element to make it resizable. The drag handles are inserted into the element
 * and positioned absolute. Some elements, such as a textarea or image, don't support this. To overcome that, you can wrap
 * the textarea in a div and set "resizeChild" to true (or to the id of the element), <b>or</b> set wrap:true in your config and
 * the element will be wrapped for you automatically.</p>
 * <p>Here is the list of valid resize handles:</p>
 * <pre>
Value   Description
------  -------------------
 'n'     north
 's'     south
 'e'     east
 'w'     west
 'nw'    northwest
 'sw'    southwest
 'se'    southeast
 'ne'    northeast
 'all'   all
</pre>
 * <p>Here's an example showing the creation of a typical Resizable:</p>
 * <pre><code>
var resizer = new Roo.Resizable("element-id", {
    handles: 'all',
    minWidth: 200,
    minHeight: 100,
    maxWidth: 500,
    maxHeight: 400,
    pinned: true
});
resizer.on("resize", myHandler);
</code></pre>
 * <p>To hide a particular handle, set its display to none in CSS, or through script:<br>
 * resizer.east.setDisplayed(false);</p>
 * @cfg {Boolean/String/Element} resizeChild True to resize the first child, or id/element to resize (defaults to false)
 * @cfg {Array/String} adjustments String "auto" or an array [width, height] with values to be <b>added</b> to the
 * resize operation's new size (defaults to [0, 0])
 * @cfg {Number} minWidth The minimum width for the element (defaults to 5)
 * @cfg {Number} minHeight The minimum height for the element (defaults to 5)
 * @cfg {Number} maxWidth The maximum width for the element (defaults to 10000)
 * @cfg {Number} maxHeight The maximum height for the element (defaults to 10000)
 * @cfg {Boolean} enabled False to disable resizing (defaults to true)
 * @cfg {Boolean} wrap True to wrap an element with a div if needed (required for textareas and images, defaults to false)
 * @cfg {Number} width The width of the element in pixels (defaults to null)
 * @cfg {Number} height The height of the element in pixels (defaults to null)
 * @cfg {Boolean} animate True to animate the resize (not compatible with dynamic sizing, defaults to false)
 * @cfg {Number} duration Animation duration if animate = true (defaults to .35)
 * @cfg {Boolean} dynamic True to resize the element while dragging instead of using a proxy (defaults to false)
 * @cfg {String} handles String consisting of the resize handles to display (defaults to undefined)
 * @cfg {Boolean} multiDirectional <b>Deprecated</b>.  The old style of adding multi-direction resize handles, deprecated
 * in favor of the handles config option (defaults to false)
 * @cfg {Boolean} disableTrackOver True to disable mouse tracking. This is only applied at config time. (defaults to false)
 * @cfg {String} easing Animation easing if animate = true (defaults to 'easingOutStrong')
 * @cfg {Number} widthIncrement The increment to snap the width resize in pixels (dynamic must be true, defaults to 0)
 * @cfg {Number} heightIncrement The increment to snap the height resize in pixels (dynamic must be true, defaults to 0)
 * @cfg {Boolean} pinned True to ensure that the resize handles are always visible, false to display them only when the
 * user mouses over the resizable borders. This is only applied at config time. (defaults to false)
 * @cfg {Boolean} preserveRatio True to preserve the original ratio between height and width during resize (defaults to false)
 * @cfg {Boolean} transparent True for transparent handles. This is only applied at config time. (defaults to false)
 * @cfg {Number} minX The minimum allowed page X for the element (only used for west resizing, defaults to 0)
 * @cfg {Number} minY The minimum allowed page Y for the element (only used for north resizing, defaults to 0)
 * @cfg {Boolean} draggable Convenience to initialize drag drop (defaults to false)
 * @constructor
 * Create a new resizable component
 * @param {String/HTMLElement/Roo.Element} el The id or element to resize
 * @param {Object} config configuration options
  */
Roo.Resizable = function(el, A){
    this.el = Roo.get(el);

    if(A && A.wrap){
        A.resizeChild = this.el;
        this.el = this.el.wrap(typeof  A.wrap == "object" ? A.wrap : {cls:"xresizable-wrap"});
        this.el.id = this.el.dom.id = A.resizeChild.id + "-rzwrap";
        this.el.setStyle("overflow", "hidden");
        this.el.setPositioning(A.resizeChild.getPositioning());
        A.resizeChild.clearPositioning();
        if(!A.width || !A.height){
            var  csize = A.resizeChild.getSize();
            this.el.setSize(csize.width, csize.height);
        }
        if(A.pinned && !A.adjustments){
            A.adjustments = "auto";
        }
    }


    this.proxy = this.el.createProxy({tag: "div", cls: "x-resizable-proxy", id: this.el.id + "-rzproxy"});
    this.proxy.unselectable();
    this.proxy.enableDisplayMode('block');

    Roo.apply(this, A);

    if(this.pinned){
        this.disableTrackOver = true;
        this.el.addClass("x-resizable-pinned");
    }
    // if the element isn't positioned, make it relative
    var  B = this.el.getStyle("position");
    if(B != "absolute" && B != "fixed"){
        this.el.setStyle("position", "relative");
    }
    if(!this.handles){ // no handles passed, must be legacy style
        this.handles = 's,e,se';
        if(this.multiDirectional){
            this.handles += ',n,w';
        }
    }
    if(this.handles == "all"){
        this.handles = "n s e w ne nw se sw";
    }
    var  hs = this.handles.split(/\s*?[,;]\s*?| /);
    var  ps = Roo.Resizable.positions;
    for(var  i = 0, len = hs.length; i < len; i++){
        if(hs[i] && ps[hs[i]]){
            var  pos = ps[hs[i]];
            this[pos] = new  Roo.Resizable.Handle(this, pos, this.disableTrackOver, this.transparent);
        }
    }

    // legacy
    this.corner = this.southeast;

    if(this.handles.indexOf("n") != -1 || this.handles.indexOf("w") != -1){
        this.updateBox = true;
    }


    this.activeHandle = null;

    if(this.resizeChild){
        if(typeof  this.resizeChild == "boolean"){
            this.resizeChild = Roo.get(this.el.dom.firstChild, true);
        }else {
            this.resizeChild = Roo.get(this.resizeChild, true);
        }
    }

    if(this.adjustments == "auto"){
        var  rc = this.resizeChild;
        var  hw = this.west, he = this.east, hn = this.north, hs = this.south;
        if(rc && (hw || hn)){
            rc.position("relative");
            rc.setLeft(hw ? hw.el.getWidth() : 0);
            rc.setTop(hn ? hn.el.getHeight() : 0);
        }

        this.adjustments = [
            (he ? -he.el.getWidth() : 0) + (hw ? -hw.el.getWidth() : 0),
            (hn ? -hn.el.getHeight() : 0) + (hs ? -hs.el.getHeight() : 0) -1
        ];
    }

    if(this.draggable){
        this.dd = this.dynamic ?
            this.el.initDD(null) : this.el.initDDProxy(null, {dragElId: this.proxy.id});
        this.dd.setHandleElId(this.resizeChild ? this.resizeChild.id : this.el.id);
    }


    // public events
    this.addEvents({
        /**
         * @event beforeresize
         * Fired before resize is allowed. Set enabled to false to cancel resize.
         * @param {Roo.Resizable} this
         * @param {Roo.EventObject} e The mousedown event
         */
        "beforeresize" : true,
        /**
         * @event resize
         * Fired after a resize.
         * @param {Roo.Resizable} this
         * @param {Number} width The new width
         * @param {Number} height The new height
         * @param {Roo.EventObject} e The mouseup event
         */
        "resize" : true
    });

    if(this.width !== null && this.height !== null){
        this.resizeTo(this.width, this.height);
    }else {
        this.updateChildSize();
    }
    if(Roo.isIE){
        this.el.dom.style.zoom = 1;
    }

    Roo.Resizable.superclass.constructor.call(this);
};

Roo.extend(Roo.Resizable, Roo.util.Observable, {
        resizeChild : false,
        adjustments : [0, 0],
        minWidth : 5,
        minHeight : 5,
        maxWidth : 10000,
        maxHeight : 10000,
        enabled : true,
        animate : false,
        duration : .35,
        dynamic : false,
        handles : false,
        multiDirectional : false,
        disableTrackOver : false,
        easing : 'easeOutStrong',
        widthIncrement : 0,
        heightIncrement : 0,
        pinned : false,
        width : null,
        height : null,
        preserveRatio : false,
        transparent: false,
        minX: 0,
        minY: 0,
        draggable: false,

        /**
         * @cfg {String/HTMLElement/Element} constrainTo Constrain the resize to a particular element
         */
        constrainTo: undefined,
        /**
         * @cfg {Roo.lib.Region} resizeRegion Constrain the resize to a particular region
         */
        resizeRegion: undefined,


    /**
     * Perform a manual resize
     * @param {Number} width
     * @param {Number} height
     */
    resizeTo : function(C, D){
        this.el.setSize(C, D);
        this.updateChildSize();
        this.fireEvent("resize", this, C, D, null);
    },

    // private
    startSizing : function(e, E){
        this.fireEvent("beforeresize", this, e);
        if(this.enabled){ // 2nd enabled check in case disabled before beforeresize handler

            if(!this.overlay){
                this.overlay = this.el.createProxy({tag: "div", cls: "x-resizable-overlay", html: "&#160;"});
                this.overlay.unselectable();
                this.overlay.enableDisplayMode("block");
                this.overlay.on("mousemove", this.onMouseMove, this);
                this.overlay.on("mouseup", this.onMouseUp, this);
            }

            this.overlay.setStyle("cursor", E.el.getStyle("cursor"));

            this.resizing = true;
            this.startBox = this.el.getBox();
            this.startPoint = e.getXY();
            this.offsets = [(this.startBox.x + this.startBox.width) - this.startPoint[0],
                            (this.startBox.y + this.startBox.height) - this.startPoint[1]];

            this.overlay.setSize(Roo.lib.Dom.getViewWidth(true), Roo.lib.Dom.getViewHeight(true));
            this.overlay.show();

            if(this.constrainTo) {
                var  ct = Roo.get(this.constrainTo);
                this.resizeRegion = ct.getRegion().adjust(
                    ct.getFrameWidth('t'),
                    ct.getFrameWidth('l'),
                    -ct.getFrameWidth('b'),
                    -ct.getFrameWidth('r')
                );
            }


            this.proxy.setStyle('visibility', 'hidden'); // workaround display none
            this.proxy.show();
            this.proxy.setBox(this.startBox);
            if(!this.dynamic){
                this.proxy.setStyle('visibility', 'visible');
            }
        }
    },

    // private
    onMouseDown : function(F, e){
        if(this.enabled){
            e.stopEvent();
            this.activeHandle = F;
            this.startSizing(e, F);
        }
    },

    // private
    onMouseUp : function(e){
        var  G = this.resizeElement();
        this.resizing = false;
        this.handleOut();
        this.overlay.hide();
        this.proxy.hide();
        this.fireEvent("resize", this, G.width, G.height, e);
    },

    // private
    updateChildSize : function(){
        if(this.resizeChild){
            var  el = this.el;
            var  child = this.resizeChild;
            var  adj = this.adjustments;
            if(el.dom.offsetWidth){
                var  b = el.getSize(true);
                child.setSize(b.width+adj[0], b.height+adj[1]);
            }
            // Second call here for IE
            // The first call enables instant resizing and
            // the second call corrects scroll bars if they
            // exist
            if(Roo.isIE){
                setTimeout(function(){
                    if(el.dom.offsetWidth){
                        var  b = el.getSize(true);
                        child.setSize(b.width+adj[0], b.height+adj[1]);
                    }
                }, 10);
            }
        }
    },

    // private
    snap : function(H, I, J){
        if(!I || !H) return  H;
        var  K = H;
        var  m = H % I;
        if(m > 0){
            if(m > (I/2)){
                K = H + (I-m);
            }else {
                K = H - m;
            }
        }
        return  Math.max(J, K);
    },

    // private
    resizeElement : function(){
        var  L = this.proxy.getBox();
        if(this.updateBox){
            this.el.setBox(L, false, this.animate, this.duration, null, this.easing);
        }else {
            this.el.setSize(L.width, L.height, this.animate, this.duration, null, this.easing);
        }

        this.updateChildSize();
        if(!this.dynamic){
            this.proxy.hide();
        }
        return  L;
    },

    // private
    constrain : function(v, M, m, mx){
        if(v - M < m){
            M = v - m;
        }else  if(v - M > mx){
            M = mx - v;
        }
        return  M;
    },

    // private
    onMouseMove : function(e){
        if(this.enabled){
            try{// try catch so if something goes wrong the user doesn't get hung

            if(this.resizeRegion && !this.resizeRegion.contains(e.getPoint())) {
            	return;
            }

            //var curXY = this.startPoint;
            var  curSize = this.curSize || this.startBox;
            var  x = this.startBox.x, y = this.startBox.y;
            var  ox = x, oy = y;
            var  w = curSize.width, h = curSize.height;
            var  ow = w, oh = h;
            var  mw = this.minWidth, mh = this.minHeight;
            var  mxw = this.maxWidth, mxh = this.maxHeight;
            var  wi = this.widthIncrement;
            var  hi = this.heightIncrement;

            var  eventXY = e.getXY();
            var  diffX = -(this.startPoint[0] - Math.max(this.minX, eventXY[0]));
            var  diffY = -(this.startPoint[1] - Math.max(this.minY, eventXY[1]));

            var  pos = this.activeHandle.position;

            switch(pos){
                case  "east":
                    w += diffX;
                    w = Math.min(Math.max(mw, w), mxw);
                    break;
                case  "south":
                    h += diffY;
                    h = Math.min(Math.max(mh, h), mxh);
                    break;
                case  "southeast":
                    w += diffX;
                    h += diffY;
                    w = Math.min(Math.max(mw, w), mxw);
                    h = Math.min(Math.max(mh, h), mxh);
                    break;
                case  "north":
                    diffY = this.constrain(h, diffY, mh, mxh);
                    y += diffY;
                    h -= diffY;
                    break;
                case  "west":
                    diffX = this.constrain(w, diffX, mw, mxw);
                    x += diffX;
                    w -= diffX;
                    break;
                case  "northeast":
                    w += diffX;
                    w = Math.min(Math.max(mw, w), mxw);
                    diffY = this.constrain(h, diffY, mh, mxh);
                    y += diffY;
                    h -= diffY;
                    break;
                case  "northwest":
                    diffX = this.constrain(w, diffX, mw, mxw);
                    diffY = this.constrain(h, diffY, mh, mxh);
                    y += diffY;
                    h -= diffY;
                    x += diffX;
                    w -= diffX;
                    break;
               case  "southwest":
                    diffX = this.constrain(w, diffX, mw, mxw);
                    h += diffY;
                    h = Math.min(Math.max(mh, h), mxh);
                    x += diffX;
                    w -= diffX;
                    break;
            }

            var  sw = this.snap(w, wi, mw);
            var  sh = this.snap(h, hi, mh);
            if(sw != w || sh != h){
                switch(pos){
                    case  "northeast":
                        y -= sh - h;
                    break;
                    case  "north":
                        y -= sh - h;
                        break;
                    case  "southwest":
                        x -= sw - w;
                    break;
                    case  "west":
                        x -= sw - w;
                        break;
                    case  "northwest":
                        x -= sw - w;
                        y -= sh - h;
                    break;
                }

                w = sw;
                h = sh;
            }

            if(this.preserveRatio){
                switch(pos){
                    case  "southeast":
                    case  "east":
                        h = oh * (w/ow);
                        h = Math.min(Math.max(mh, h), mxh);
                        w = ow * (h/oh);
                       break;
                    case  "south":
                        w = ow * (h/oh);
                        w = Math.min(Math.max(mw, w), mxw);
                        h = oh * (w/ow);
                        break;
                    case  "northeast":
                        w = ow * (h/oh);
                        w = Math.min(Math.max(mw, w), mxw);
                        h = oh * (w/ow);
                    break;
                    case  "north":
                        var  tw = w;
                        w = ow * (h/oh);
                        w = Math.min(Math.max(mw, w), mxw);
                        h = oh * (w/ow);
                        x += (tw - w) / 2;
                        break;
                    case  "southwest":
                        h = oh * (w/ow);
                        h = Math.min(Math.max(mh, h), mxh);
                        var  tw = w;
                        w = ow * (h/oh);
                        x += tw - w;
                        break;
                    case  "west":
                        var  th = h;
                        h = oh * (w/ow);
                        h = Math.min(Math.max(mh, h), mxh);
                        y += (th - h) / 2;
                        var  tw = w;
                        w = ow * (h/oh);
                        x += tw - w;
                       break;
                    case  "northwest":
                        var  tw = w;
                        var  th = h;
                        h = oh * (w/ow);
                        h = Math.min(Math.max(mh, h), mxh);
                        w = ow * (h/oh);
                        y += th - h;
                         x += tw - w;
                       break;

                }
            }

            this.proxy.setBounds(x, y, w, h);
            if(this.dynamic){
                this.resizeElement();
            }
            }catch(e){}
        }
    },

    // private
    handleOver : function(){
        if(this.enabled){
            this.el.addClass("x-resizable-over");
        }
    },

    // private
    handleOut : function(){
        if(!this.resizing){
            this.el.removeClass("x-resizable-over");
        }
    },

    /**
     * Returns the element this component is bound to.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.el;
    },

    /**
     * Returns the resizeChild element (or null).
     * @return {Roo.Element}
     */
    getResizeChild : function(){
        return  this.resizeChild;
    },

    /**
     * Destroys this resizable. If the element was wrapped and
     * removeEl is not true then the element remains.
     * @param {Boolean} removeEl (optional) true to remove the element from the DOM
     */
    destroy : function(N){
        this.proxy.remove();
        if(this.overlay){
            this.overlay.removeAllListeners();
            this.overlay.remove();
        }
        var  ps = Roo.Resizable.positions;
        for(var  k  in  ps){
            if(typeof  ps[k] != "function" && this[ps[k]]){
                var  h = this[ps[k]];
                h.el.removeAllListeners();
                h.el.remove();
            }
        }
        if(N){
            this.el.update("");
            this.el.remove();
        }
    }
});

// private
// hash to map config positions to true positions
Roo.Resizable.positions = {
    n: "north", s: "south", e: "east", w: "west", se: "southeast", sw: "southwest", nw: "northwest", ne: "northeast"
};

// private
Roo.Resizable.Handle = function(rz, O, P, Q){
    if(!this.tpl){
        // only initialize the template if resizable is used
        var  tpl = Roo.DomHelper.createTemplate(
            {tag: "div", cls: "x-resizable-handle x-resizable-handle-{0}"}
        );
        tpl.compile();
        Roo.Resizable.Handle.prototype.tpl = tpl;
    }

    this.position = O;
    this.rz = rz;
    this.el = this.tpl.append(rz.el.dom, [this.position], true);
    this.el.unselectable();
    if(Q){
        this.el.setOpacity(0);
    }

    this.el.on("mousedown", this.onMouseDown, this);
    if(!P){
        this.el.on("mouseover", this.onMouseOver, this);
        this.el.on("mouseout", this.onMouseOut, this);
    }
};

// private
Roo.Resizable.Handle.prototype = {
    afterResize : function(rz){
        // do nothing
    },
    // private
    onMouseDown : function(e){
        this.rz.onMouseDown(this, e);
    },
    // private
    onMouseOver : function(e){
        this.rz.handleOver(this, e);
    },
    // private
    onMouseOut : function(e){
        this.rz.handleOut(this, e);
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.Editor
 * @extends Roo.Component
 * A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.
 * @constructor
 * Create a new Editor
 * @param {Roo.form.Field} field The Field object (or descendant)
 * @param {Object} config The config object
 */
Roo.Editor = function(A, B){
    Roo.Editor.superclass.constructor.call(this, B);
    this.field = A;
    this.addEvents({
        /**
	     * @event beforestartedit
	     * Fires when editing is initiated, but before the value changes.  Editing can be canceled by returning
	     * false from the handler of this event.
	     * @param {Editor} this
	     * @param {Roo.Element} boundEl The underlying element bound to this editor
	     * @param {Mixed} value The field value being set
	     */
        "beforestartedit" : true,
        /**
	     * @event startedit
	     * Fires when this editor is displayed
	     * @param {Roo.Element} boundEl The underlying element bound to this editor
	     * @param {Mixed} value The starting field value
	     */
        "startedit" : true,
        /**
	     * @event beforecomplete
	     * Fires after a change has been made to the field, but before the change is reflected in the underlying
	     * field.  Saving the change to the field can be canceled by returning false from the handler of this event.
	     * Note that if the value has not changed and ignoreNoChange = true, the editing will still end but this
	     * event will not fire since no edit actually occurred.
	     * @param {Editor} this
	     * @param {Mixed} value The current field value
	     * @param {Mixed} startValue The original field value
	     */
        "beforecomplete" : true,
        /**
	     * @event complete
	     * Fires after editing is complete and any changed value has been written to the underlying field.
	     * @param {Editor} this
	     * @param {Mixed} value The current field value
	     * @param {Mixed} startValue The original field value
	     */
        "complete" : true,
        /**
         * @event specialkey
         * Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed.  You can check
         * {@link Roo.EventObject#getKey} to determine which key was pressed.
         * @param {Roo.form.Field} this
         * @param {Roo.EventObject} e The event object
         */
        "specialkey" : true
    });
};

Roo.extend(Roo.Editor, Roo.Component, {
    /**
     * @cfg {Boolean/String} autosize
     * True for the editor to automatically adopt the size of the underlying field, "width" to adopt the width only,
     * or "height" to adopt the height only (defaults to false)
     */
    /**
     * @cfg {Boolean} revertInvalid
     * True to automatically revert the field value and cancel the edit when the user completes an edit and the field
     * validation fails (defaults to true)
     */
    /**
     * @cfg {Boolean} ignoreNoChange
     * True to skip the the edit completion process (no save, no events fired) if the user completes an edit and
     * the value has not changed (defaults to false).  Applies only to string values - edits for other data types
     * will never be ignored.
     */
    /**
     * @cfg {Boolean} hideEl
     * False to keep the bound element visible while the editor is displayed (defaults to true)
     */
    /**
     * @cfg {Mixed} value
     * The data value of the underlying field (defaults to "")
     */
    value : "",
    /**
     * @cfg {String} alignment
     * The position to align to (see {@link Roo.Element#alignTo} for more details, defaults to "c-c?").
     */
    alignment: "c-c?",
    /**
     * @cfg {Boolean/String} shadow "sides" for sides/bottom only, "frame" for 4-way shadow, and "drop"
     * for bottom-right shadow (defaults to "frame")
     */
    shadow : "frame",
    /**
     * @cfg {Boolean} constrain True to constrain the editor to the viewport
     */
    constrain : false,
    /**
     * @cfg {Boolean} completeOnEnter True to complete the edit when the enter key is pressed (defaults to false)
     */
    completeOnEnter : false,
    /**
     * @cfg {Boolean} cancelOnEsc True to cancel the edit when the escape key is pressed (defaults to false)
     */
    cancelOnEsc : false,
    /**
     * @cfg {Boolean} updateEl True to update the innerHTML of the bound element when the update completes (defaults to false)
     */
    updateEl : false,

    // private
    onRender : function(ct, C){
        this.el = new  Roo.Layer({
            shadow: this.shadow,
            cls: "x-editor",
            parentEl : ct,
            shim : this.shim,
            shadowOffset:4,
            id: this.id,
            constrain: this.constrain
        });
        this.el.setStyle("overflow", Roo.isGecko ? "auto" : "hidden");
        if(this.field.msgTarget != 'title'){
            this.field.msgTarget = 'qtip';
        }

        this.field.render(this.el);
        if(Roo.isGecko){
            this.field.el.dom.setAttribute('autocomplete', 'off');
        }

        this.field.on("specialkey", this.onSpecialKey, this);
        if(this.swallowKeys){
            this.field.el.swallowEvent(['keydown','keypress']);
        }

        this.field.show();
        this.field.on("blur", this.onBlur, this);
        if(this.field.grow){
            this.field.on("autosize", this.el.sync,  this.el, {delay:1});
        }
    },

    onSpecialKey : function(D, e){
        if(this.completeOnEnter && e.getKey() == e.ENTER){
            e.stopEvent();
            this.completeEdit();
        }else  if(this.cancelOnEsc && e.getKey() == e.ESC){
            this.cancelEdit();
        }else {
            this.fireEvent('specialkey', D, e);
        }
    },

    /**
     * Starts the editing process and shows the editor.
     * @param {String/HTMLElement/Element} el The element to edit
     * @param {String} value (optional) A value to initialize the editor with. If a value is not provided, it defaults
      * to the innerHTML of el.
     */
    startEdit : function(el, E){
        if(this.editing){
            this.completeEdit();
        }

        this.boundEl = Roo.get(el);
        var  v = E !== undefined ? E : this.boundEl.dom.innerHTML;
        if(!this.rendered){
            this.render(this.parentEl || document.body);
        }
        if(this.fireEvent("beforestartedit", this, this.boundEl, v) === false){
            return;
        }

        this.startValue = v;
        this.field.setValue(v);
        if(this.autoSize){
            var  sz = this.boundEl.getSize();
            switch(this.autoSize){
                case  "width":
                this.setSize(sz.width,  "");
                break;
                case  "height":
                this.setSize("",  sz.height);
                break;
                default:
                this.setSize(sz.width,  sz.height);
            }
        }

        this.el.alignTo(this.boundEl, this.alignment);
        this.editing = true;
        if(Roo.QuickTips){
            Roo.QuickTips.disable();
        }

        this.show();
    },

    /**
     * Sets the height and width of this editor.
     * @param {Number} width The new width
     * @param {Number} height The new height
     */
    setSize : function(w, h){
        this.field.setSize(w, h);
        if(this.el){
            this.el.sync();
        }
    },

    /**
     * Realigns the editor to the bound field based on the current alignment config value.
     */
    realign : function(){
        this.el.alignTo(this.boundEl, this.alignment);
    },

    /**
     * Ends the editing process, persists the changed value to the underlying field, and hides the editor.
     * @param {Boolean} remainVisible Override the default behavior and keep the editor visible after edit (defaults to false)
     */
    completeEdit : function(F){
        if(!this.editing){
            return;
        }
        var  v = this.getValue();
        if(this.revertInvalid !== false && !this.field.isValid()){
            v = this.startValue;
            this.cancelEdit(true);
        }
        if(String(v) === String(this.startValue) && this.ignoreNoChange){
            this.editing = false;
            this.hide();
            return;
        }
        if(this.fireEvent("beforecomplete", this, v, this.startValue) !== false){
            this.editing = false;
            if(this.updateEl && this.boundEl){
                this.boundEl.update(v);
            }
            if(F !== true){
                this.hide();
            }

            this.fireEvent("complete", this, v, this.startValue);
        }
    },

    // private
    onShow : function(){
        this.el.show();
        if(this.hideEl !== false){
            this.boundEl.hide();
        }

        this.field.show();
        if(Roo.isIE && !this.fixIEFocus){ // IE has problems with focusing the first time
            this.fixIEFocus = true;
            this.deferredFocus.defer(50, this);
        }else {
            this.field.focus();
        }

        this.fireEvent("startedit", this.boundEl, this.startValue);
    },

    deferredFocus : function(){
        if(this.editing){
            this.field.focus();
        }
    },

    /**
     * Cancels the editing process and hides the editor without persisting any changes.  The field value will be
     * reverted to the original starting value.
     * @param {Boolean} remainVisible Override the default behavior and keep the editor visible after
     * cancel (defaults to false)
     */
    cancelEdit : function(G){
        if(this.editing){
            this.setValue(this.startValue);
            if(G !== true){
                this.hide();
            }
        }
    },

    // private
    onBlur : function(){
        if(this.allowBlur !== true && this.editing){
            this.completeEdit();
        }
    },

    // private
    onHide : function(){
        if(this.editing){
            this.completeEdit();
            return;
        }

        this.field.blur();
        if(this.field.collapse){
            this.field.collapse();
        }

        this.el.hide();
        if(this.hideEl !== false){
            this.boundEl.show();
        }
        if(Roo.QuickTips){
            Roo.QuickTips.enable();
        }
    },

    /**
     * Sets the data value of the editor
     * @param {Mixed} value Any valid value supported by the underlying field
     */
    setValue : function(v){
        this.field.setValue(v);
    },

    /**
     * Gets the data value of the editor
     * @return {Mixed} The data value
     */
    getValue : function(){
        return  this.field.getValue();
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.BasicDialog
 * @extends Roo.util.Observable
 * Lightweight Dialog Class.  The code below shows the creation of a typical dialog using existing HTML markup:
 * <pre><code>
var dlg = new Roo.BasicDialog("my-dlg", {
    height: 200,
    width: 300,
    minHeight: 100,
    minWidth: 150,
    modal: true,
    proxyDrag: true,
    shadow: true
});
dlg.addKeyListener(27, dlg.hide, dlg); // ESC can also close the dialog
dlg.addButton('OK', dlg.hide, dlg);    // Could call a save function instead of hiding
dlg.addButton('Cancel', dlg.hide, dlg);
dlg.show();
</code></pre>
  <b>A Dialog should always be a direct child of the body element.</b>
 * @cfg {Boolean/DomHelper} autoCreate True to auto create from scratch, or using a DomHelper Object (defaults to false)
 * @cfg {String} title Default text to display in the title bar (defaults to null)
 * @cfg {Number} width Width of the dialog in pixels (can also be set via CSS).  Determined by browser if unspecified.
 * @cfg {Number} height Height of the dialog in pixels (can also be set via CSS).  Determined by browser if unspecified.
 * @cfg {Number} x The default left page coordinate of the dialog (defaults to center screen)
 * @cfg {Number} y The default top page coordinate of the dialog (defaults to center screen)
 * @cfg {String/Element} animateTarget Id or element from which the dialog should animate while opening
 * (defaults to null with no animation)
 * @cfg {Boolean} resizable False to disable manual dialog resizing (defaults to true)
 * @cfg {String} resizeHandles Which resize handles to display - see the {@link Roo.Resizable} handles config
 * property for valid values (defaults to 'all')
 * @cfg {Number} minHeight The minimum allowable height for a resizable dialog (defaults to 80)
 * @cfg {Number} minWidth The minimum allowable width for a resizable dialog (defaults to 200)
 * @cfg {Boolean} modal True to show the dialog modally, preventing user interaction with the rest of the page (defaults to false)
 * @cfg {Boolean} autoScroll True to allow the dialog body contents to overflow and display scrollbars (defaults to false)
 * @cfg {Boolean} closable False to remove the built-in top-right corner close button (defaults to true)
 * @cfg {Boolean} collapsible False to remove the built-in top-right corner collapse button (defaults to true)
 * @cfg {Boolean} constraintoviewport True to keep the dialog constrained within the visible viewport boundaries (defaults to true)
 * @cfg {Boolean} syncHeightBeforeShow True to cause the dimensions to be recalculated before the dialog is shown (defaults to false)
 * @cfg {Boolean} draggable False to disable dragging of the dialog within the viewport (defaults to true)
 * @cfg {Boolean} autoTabs If true, all elements with class 'x-dlg-tab' will get automatically converted to tabs (defaults to false)
 * @cfg {String} tabTag The tag name of tab elements, used when autoTabs = true (defaults to 'div')
 * @cfg {Boolean} proxyDrag True to drag a lightweight proxy element rather than the dialog itself, used when
 * draggable = true (defaults to false)
 * @cfg {Boolean} fixedcenter True to ensure that anytime the dialog is shown or resized it gets centered (defaults to false)
 * @cfg {Boolean/String} shadow True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right
 * shadow (defaults to false)
 * @cfg {Number} shadowOffset The number of pixels to offset the shadow if displayed (defaults to 5)
 * @cfg {String} buttonAlign Valid values are "left," "center" and "right" (defaults to "right")
 * @cfg {Number} minButtonWidth Minimum width of all dialog buttons (defaults to 75)
 * @cfg {Array} buttons Array of buttons
 * @cfg {Boolean} shim True to create an iframe shim that prevents selects from showing through (defaults to false)
 * @constructor
 * Create a new BasicDialog.
 * @param {String/HTMLElement/Roo.Element} el The container element or DOM node, or its id
 * @param {Object} config Configuration options
 */
Roo.BasicDialog = function(el, A){
    this.el = Roo.get(el);
    var  dh = Roo.DomHelper;
    if(!this.el && A && A.autoCreate){
        if(typeof  A.autoCreate == "object"){
            if(!A.autoCreate.id){
                A.autoCreate.id = el;
            }

            this.el = dh.append(document.body,
                        A.autoCreate, true);
        }else {
            this.el = dh.append(document.body,
                        {tag: "div", id: el, style:'visibility:hidden;'}, true);
        }
    }

    el = this.el;
    el.setDisplayed(true);
    el.hide = this.hideAction;
    this.id = el.id;
    el.addClass("x-dlg");

    Roo.apply(this, A);

    this.proxy = el.createProxy("x-dlg-proxy");
    this.proxy.hide = this.hideAction;
    this.proxy.setOpacity(.5);
    this.proxy.hide();

    if(A.width){
        el.setWidth(A.width);
    }
    if(A.height){
        el.setHeight(A.height);
    }

    this.size = el.getSize();
    if(typeof  A.x != "undefined" && typeof  A.y != "undefined"){
        this.xy = [A.x,A.y];
    }else {
        this.xy = el.getCenterXY(true);
    }

    /** The header element @type Roo.Element */
    this.header = el.child("> .x-dlg-hd");
    /** The body element @type Roo.Element */
    this.body = el.child("> .x-dlg-bd");
    /** The footer element @type Roo.Element */
    this.footer = el.child("> .x-dlg-ft");

    if(!this.header){
        this.header = el.createChild({tag: "div", cls:"x-dlg-hd", html: "&#160;"}, this.body ? this.body.dom : null);
    }
    if(!this.body){
        this.body = el.createChild({tag: "div", cls:"x-dlg-bd"});
    }


    this.header.unselectable();
    if(this.title){
        this.header.update(this.title);
    }

    // this element allows the dialog to be focused for keyboard event
    this.focusEl = el.createChild({tag: "a", href:"#", cls:"x-dlg-focus", tabIndex:"-1"});
    this.focusEl.swallowEvent("click", true);

    this.header.wrap({cls:"x-dlg-hd-right"}).wrap({cls:"x-dlg-hd-left"}, true);

    // wrap the body and footer for special rendering
    this.bwrap = this.body.wrap({tag: "div", cls:"x-dlg-dlg-body"});
    if(this.footer){
        this.bwrap.dom.appendChild(this.footer.dom);
    }


    this.bg = this.el.createChild({
        tag: "div", cls:"x-dlg-bg",
        html: '<div class="x-dlg-bg-left"><div class="x-dlg-bg-right"><div class="x-dlg-bg-center">&#160;</div></div></div>'
    });
    this.centerBg = this.bg.child("div.x-dlg-bg-center");


    if(this.autoScroll !== false && !this.autoTabs){
        this.body.setStyle("overflow", "auto");
    }


    this.toolbox = this.el.createChild({cls: "x-dlg-toolbox"});

    if(this.closable !== false){
        this.el.addClass("x-dlg-closable");
        this.close = this.toolbox.createChild({cls:"x-dlg-close"});
        this.close.on("click", this.closeClick, this);
        this.close.addClassOnOver("x-dlg-close-over");
    }
    if(this.collapsible !== false){
        this.collapseBtn = this.toolbox.createChild({cls:"x-dlg-collapse"});
        this.collapseBtn.on("click", this.collapseClick, this);
        this.collapseBtn.addClassOnOver("x-dlg-collapse-over");
        this.header.on("dblclick", this.collapseClick, this);
    }
    if(this.resizable !== false){
        this.el.addClass("x-dlg-resizable");
        this.resizer = new  Roo.Resizable(el, {
            minWidth: this.minWidth || 80,
            minHeight:this.minHeight || 80,
            handles: this.resizeHandles || "all",
            pinned: true
        });
        this.resizer.on("beforeresize", this.beforeResize, this);
        this.resizer.on("resize", this.onResize, this);
    }
    if(this.draggable !== false){
        el.addClass("x-dlg-draggable");
        if (!this.proxyDrag) {
            var  dd = new  Roo.dd.DD(el.dom.id, "WindowDrag");
        }
        else  {
            var  dd = new  Roo.dd.DDProxy(el.dom.id, "WindowDrag", {dragElId: this.proxy.id});
        }

        dd.setHandleElId(this.header.id);
        dd.endDrag = this.endMove.createDelegate(this);
        dd.startDrag = this.startMove.createDelegate(this);
        dd.onDrag = this.onDrag.createDelegate(this);
        dd.scroll = false;
        this.dd = dd;
    }
    if(this.modal){
        this.mask = dh.append(document.body, {tag: "div", cls:"x-dlg-mask"}, true);
        this.mask.enableDisplayMode("block");
        this.mask.hide();
        this.el.addClass("x-dlg-modal");
    }
    if(this.shadow){
        this.shadow = new  Roo.Shadow({
            mode : typeof  this.shadow == "string" ? this.shadow : "sides",
            offset : this.shadowOffset
        });
    }else {
        this.shadowOffset = 0;
    }
    if(Roo.useShims && this.shim !== false){
        this.shim = this.el.createShim();
        this.shim.hide = this.hideAction;
        this.shim.hide();
    }else {
        this.shim = false;
    }
    if(this.autoTabs){
        this.initTabs();
    }
    if (this.buttons) { 
        var  bts= this.buttons;
        this.buttons = [];
        Roo.each(bts, function(b) {
            this.addButton(b);
        }, this);
    }

    
    
    this.addEvents({
        /**
         * @event keydown
         * Fires when a key is pressed
         * @param {Roo.BasicDialog} this
         * @param {Roo.EventObject} e
         */
        "keydown" : true,
        /**
         * @event move
         * Fires when this dialog is moved by the user.
         * @param {Roo.BasicDialog} this
         * @param {Number} x The new page X
         * @param {Number} y The new page Y
         */
        "move" : true,
        /**
         * @event resize
         * Fires when this dialog is resized by the user.
         * @param {Roo.BasicDialog} this
         * @param {Number} width The new width
         * @param {Number} height The new height
         */
        "resize" : true,
        /**
         * @event beforehide
         * Fires before this dialog is hidden.
         * @param {Roo.BasicDialog} this
         */
        "beforehide" : true,
        /**
         * @event hide
         * Fires when this dialog is hidden.
         * @param {Roo.BasicDialog} this
         */
        "hide" : true,
        /**
         * @event beforeshow
         * Fires before this dialog is shown.
         * @param {Roo.BasicDialog} this
         */
        "beforeshow" : true,
        /**
         * @event show
         * Fires when this dialog is shown.
         * @param {Roo.BasicDialog} this
         */
        "show" : true
    });
    el.on("keydown", this.onKeyDown, this);
    el.on("mousedown", this.toFront, this);
    Roo.EventManager.onWindowResize(this.adjustViewport, this, true);
    this.el.hide();
    Roo.DialogManager.register(this);
    Roo.BasicDialog.superclass.constructor.call(this);
};

Roo.extend(Roo.BasicDialog, Roo.util.Observable, {
    shadowOffset: Roo.isIE ? 6 : 5,
    minHeight: 80,
    minWidth: 200,
    minButtonWidth: 75,
    defaultButton: null,
    buttonAlign: "right",
    tabTag: 'div',
    firstShow: true,

    /**
     * Sets the dialog title text
     * @param {String} text The title text to display
     * @return {Roo.BasicDialog} this
     */
    setTitle : function(B){
        this.header.update(B);
        return  this;
    },

    // private
    closeClick : function(){
        this.hide();
    },

    // private
    collapseClick : function(){
        this[this.collapsed ? "expand" : "collapse"]();
    },

    /**
     * Collapses the dialog to its minimized state (only the title bar is visible).
     * Equivalent to the user clicking the collapse dialog button.
     */
    collapse : function(){
        if(!this.collapsed){
            this.collapsed = true;
            this.el.addClass("x-dlg-collapsed");
            this.restoreHeight = this.el.getHeight();
            this.resizeTo(this.el.getWidth(), this.header.getHeight());
        }
    },

    /**
     * Expands a collapsed dialog back to its normal state.  Equivalent to the user
     * clicking the expand dialog button.
     */
    expand : function(){
        if(this.collapsed){
            this.collapsed = false;
            this.el.removeClass("x-dlg-collapsed");
            this.resizeTo(this.el.getWidth(), this.restoreHeight);
        }
    },

    /**
     * Reinitializes the tabs component, clearing out old tabs and finding new ones.
     * @return {Roo.TabPanel} The tabs component
     */
    initTabs : function(){
        var  C = this.getTabs();
        while(C.getTab(0)){
            C.removeTab(0);
        }

        this.el.select(this.tabTag+'.x-dlg-tab').each(function(el){
            var  D = el.dom;
            C.addTab(Roo.id(D), D.title);
            D.title = "";
        });
        C.activate(0);
        return  C;
    },

    // private
    beforeResize : function(){
        this.resizer.minHeight = Math.max(this.minHeight, this.getHeaderFooterHeight(true)+40);
    },

    // private
    onResize : function(){
        this.refreshSize();
        this.syncBodyHeight();
        this.adjustAssets();
        this.focus();
        this.fireEvent("resize", this, this.size.width, this.size.height);
    },

    // private
    onKeyDown : function(e){
        if(this.isVisible()){
            this.fireEvent("keydown", this, e);
        }
    },

    /**
     * Resizes the dialog.
     * @param {Number} width
     * @param {Number} height
     * @return {Roo.BasicDialog} this
     */
    resizeTo : function(D, E){
        this.el.setSize(D, E);
        this.size = {width: D, height: E};
        this.syncBodyHeight();
        if(this.fixedcenter){
            this.center();
        }
        if(this.isVisible()){
            this.constrainXY();
            this.adjustAssets();
        }

        this.fireEvent("resize", this, D, E);
        return  this;
    },


    /**
     * Resizes the dialog to fit the specified content size.
     * @param {Number} width
     * @param {Number} height
     * @return {Roo.BasicDialog} this
     */
    setContentSize : function(w, h){
        h += this.getHeaderFooterHeight() + this.body.getMargins("tb");
        w += this.body.getMargins("lr") + this.bwrap.getMargins("lr") + this.centerBg.getPadding("lr");
        //if(!this.el.isBorderBox()){
            h +=  this.body.getPadding("tb") + this.bwrap.getBorderWidth("tb") + this.body.getBorderWidth("tb") + this.el.getBorderWidth("tb");
            w += this.body.getPadding("lr") + this.bwrap.getBorderWidth("lr") + this.body.getBorderWidth("lr") + this.bwrap.getPadding("lr") + this.el.getBorderWidth("lr");
        //}
        if(this.tabs){
            h += this.tabs.stripWrap.getHeight() + this.tabs.bodyEl.getMargins("tb") + this.tabs.bodyEl.getPadding("tb");
            w += this.tabs.bodyEl.getMargins("lr") + this.tabs.bodyEl.getPadding("lr");
        }

        this.resizeTo(w, h);
        return  this;
    },

    /**
     * Adds a key listener for when this dialog is displayed.  This allows you to hook in a function that will be
     * executed in response to a particular key being pressed while the dialog is active.
     * @param {Number/Array/Object} key Either the numeric key code, array of key codes or an object with the following options:
     *                                  {key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}
     * @param {Function} fn The function to call
     * @param {Object} scope (optional) The scope of the function
     * @return {Roo.BasicDialog} this
     */
    addKeyListener : function(F, fn, G){
        var  H, I, J, K;
        if(typeof  F == "object" && !(F  instanceof  Array)){
            H = F["key"];
            I = F["shift"];
            J = F["ctrl"];
            K = F["alt"];
        }else {
            H = F;
        }
        var  L = function(M, e){
            if((!I || e.shiftKey) && (!J || e.ctrlKey) &&  (!K || e.altKey)){
                var  k = e.getKey();
                if(H  instanceof  Array){
                    for(var  i = 0, len = H.length; i < len; i++){
                        if(H[i] == k){
                          fn.call(G || window, M, k, e);
                          return;
                        }
                    }
                }else {
                    if(k == H){
                        fn.call(G || window, M, k, e);
                    }
                }
            }
        };
        this.on("keydown", L);
        return  this;
    },

    /**
     * Returns the TabPanel component (creates it if it doesn't exist).
     * Note: If you wish to simply check for the existence of tabs without creating them,
     * check for a null 'tabs' property.
     * @return {Roo.TabPanel} The tabs component
     */
    getTabs : function(){
        if(!this.tabs){
            this.el.addClass("x-dlg-auto-tabs");
            this.body.addClass(this.tabPosition == "bottom" ? "x-tabs-bottom" : "x-tabs-top");
            this.tabs = new  Roo.TabPanel(this.body.dom, this.tabPosition == "bottom");
        }
        return  this.tabs;
    },

    /**
     * Adds a button to the footer section of the dialog.
     * @param {String/Object} config A string becomes the button text, an object can either be a Button config
     * object or a valid Roo.DomHelper element config
     * @param {Function} handler The function called when the button is clicked
     * @param {Object} scope (optional) The scope of the handler function (accepts position as a property)
     * @return {Roo.Button} The new button
     */
    addButton : function(M, N, O){
        var  dh = Roo.DomHelper;
        if(!this.footer){
            this.footer = dh.append(this.bwrap, {tag: "div", cls:"x-dlg-ft"}, true);
        }
        if(!this.btnContainer){
            var  tb = this.footer.createChild({

                cls:"x-dlg-btns x-dlg-btns-"+this.buttonAlign,
                html:'<table cellspacing="0"><tbody><tr></tr></tbody></table><div class="x-clear"></div>'
            }, null, true);
            this.btnContainer = tb.firstChild.firstChild.firstChild;
        }
        var  P = {
            handler: N,
            scope: O,
            minWidth: this.minButtonWidth,
            hideParent:true
        };
        if(typeof  M == "string"){
            P.text = M;
        }else {
            if(M.tag){
                P.dhconfig = M;
            }else {
                Roo.apply(P, M);
            }
        }
        var  fc = false;
        if ((typeof(P.position) != 'undefined') && P.position < this.btnContainer.childNodes.length-1) {
            P.position = Math.max(0, P.position);
            fc = this.btnContainer.childNodes[P.position];
        }
         
        var  Q = new  Roo.Button(
            fc ? 
                this.btnContainer.insertBefore(document.createElement("td"),fc)
                : this.btnContainer.appendChild(document.createElement("td")),
            //Roo.get(this.btnContainer).createChild( { tag: 'td'},  fc ),
            P
        );
        this.syncBodyHeight();
        if(!this.buttons){
            /**
             * Array of all the buttons that have been added to this dialog via addButton
             * @type Array
             */
            this.buttons = [];
        }

        this.buttons.push(Q);
        return  Q;
    },

    /**
     * Sets the default button to be focused when the dialog is displayed.
     * @param {Roo.BasicDialog.Button} btn The button object returned by {@link #addButton}
     * @return {Roo.BasicDialog} this
     */
    setDefaultButton : function(R){
        this.defaultButton = R;
        return  this;
    },

    // private
    getHeaderFooterHeight : function(S){
        var  T = 0;
        if(this.header){
           T += this.header.getHeight();
        }
        if(this.footer){
           var  fm = this.footer.getMargins();
            T += (this.footer.getHeight()+fm.top+fm.bottom);
        }

        T += this.bwrap.getPadding("tb")+this.bwrap.getBorderWidth("tb");
        T += this.centerBg.getPadding("tb");
        return  T;
    },

    // private
    syncBodyHeight : function(){
        var  bd = this.body, cb = this.centerBg, bw = this.bwrap;
        var  U = this.size.height - this.getHeaderFooterHeight(false);
        bd.setHeight(U-bd.getMargins("tb"));
        var  hh = this.header.getHeight();
        var  h = this.size.height-hh;
        cb.setHeight(h);
        bw.setLeftTop(cb.getPadding("l"), hh+cb.getPadding("t"));
        bw.setHeight(h-cb.getPadding("tb"));
        bw.setWidth(this.el.getWidth(true)-cb.getPadding("lr"));
        bd.setWidth(bw.getWidth(true));
        if(this.tabs){
            this.tabs.syncHeight();
            if(Roo.isIE){
                this.tabs.el.repaint();
            }
        }
    },

    /**
     * Restores the previous state of the dialog if Roo.state is configured.
     * @return {Roo.BasicDialog} this
     */
    restoreState : function(){
        var  V = Roo.state.Manager.get(this.stateId || (this.el.id + "-state"));
        if(V && V.width){
            this.xy = [V.x, V.y];
            this.resizeTo(V.width, V.height);
        }
        return  this;
    },

    // private
    beforeShow : function(){
        this.expand();
        if(this.fixedcenter){
            this.xy = this.el.getCenterXY(true);
        }
        if(this.modal){
            Roo.get(document.body).addClass("x-body-masked");
            this.mask.setSize(Roo.lib.Dom.getViewWidth(true), Roo.lib.Dom.getViewHeight(true));
            this.mask.show();
        }

        this.constrainXY();
    },

    // private
    animShow : function(){
        var  b = Roo.get(this.animateTarget, true).getBox();
        this.proxy.setSize(b.width, b.height);
        this.proxy.setLocation(b.x, b.y);
        this.proxy.show();
        this.proxy.setBounds(this.xy[0], this.xy[1], this.size.width, this.size.height,
                    true, .35, this.showEl.createDelegate(this));
    },

    /**
     * Shows the dialog.
     * @param {String/HTMLElement/Roo.Element} animateTarget (optional) Reset the animation target
     * @return {Roo.BasicDialog} this
     */
    show : function(W){
        if (this.fireEvent("beforeshow", this) === false){
            return;
        }
        if(this.syncHeightBeforeShow){
            this.syncBodyHeight();
        }else  if(this.firstShow){
            this.firstShow = false;
            this.syncBodyHeight(); // sync the height on the first show instead of in the constructor
        }

        this.animateTarget = W || this.animateTarget;
        if(!this.el.isVisible()){
            this.beforeShow();
            if(this.animateTarget){
                this.animShow();
            }else {
                this.showEl();
            }
        }
        return  this;
    },

    // private
    showEl : function(){
        this.proxy.hide();
        this.el.setXY(this.xy);
        this.el.show();
        this.adjustAssets(true);
        this.toFront();
        this.focus();
        // IE peekaboo bug - fix found by Dave Fenwick
        if(Roo.isIE){
            this.el.repaint();
        }

        this.fireEvent("show", this);
    },

    /**
     * Focuses the dialog.  If a defaultButton is set, it will receive focus, otherwise the
     * dialog itself will receive focus.
     */
    focus : function(){
        if(this.defaultButton){
            this.defaultButton.focus();
        }else {
            this.focusEl.focus();
        }
    },

    // private
    constrainXY : function(){
        if(this.constraintoviewport !== false){
            if(!this.viewSize){
                if(this.container){
                    var  s = this.container.getSize();
                    this.viewSize = [s.width, s.height];
                }else {
                    this.viewSize = [Roo.lib.Dom.getViewWidth(),Roo.lib.Dom.getViewHeight()];
                }
            }
            var  s = Roo.get(this.container||document).getScroll();

            var  x = this.xy[0], y = this.xy[1];
            var  w = this.size.width, h = this.size.height;
            var  vw = this.viewSize[0], vh = this.viewSize[1];
            // only move it if it needs it
            var  moved = false;
            // first validate right/bottom
            if(x + w > vw+s.left){
                x = vw - w;
                moved = true;
            }
            if(y + h > vh+s.top){
                y = vh - h;
                moved = true;
            }
            // then make sure top/left isn't negative
            if(x < s.left){
                x = s.left;
                moved = true;
            }
            if(y < s.top){
                y = s.top;
                moved = true;
            }
            if(moved){
                // cache xy
                this.xy = [x, y];
                if(this.isVisible()){
                    this.el.setLocation(x, y);
                    this.adjustAssets();
                }
            }
        }
    },

    // private
    onDrag : function(){
        if(!this.proxyDrag){
            this.xy = this.el.getXY();
            this.adjustAssets();
        }
    },

    // private
    adjustAssets : function(X){
        var  x = this.xy[0], y = this.xy[1];
        var  w = this.size.width, h = this.size.height;
        if(X === true){
            if(this.shadow){
                this.shadow.show(this.el);
            }
            if(this.shim){
                this.shim.show();
            }
        }
        if(this.shadow && this.shadow.isVisible()){
            this.shadow.show(this.el);
        }
        if(this.shim && this.shim.isVisible()){
            this.shim.setBounds(x, y, w, h);
        }
    },

    // private
    adjustViewport : function(w, h){
        if(!w || !h){
            w = Roo.lib.Dom.getViewWidth();
            h = Roo.lib.Dom.getViewHeight();
        }

        // cache the size
        this.viewSize = [w, h];
        if(this.modal && this.mask.isVisible()){
            this.mask.setSize(w, h); // first make sure the mask isn't causing overflow
            this.mask.setSize(Roo.lib.Dom.getViewWidth(true), Roo.lib.Dom.getViewHeight(true));
        }
        if(this.isVisible()){
            this.constrainXY();
        }
    },

    /**
     * Destroys this dialog and all its supporting elements (including any tabs, shim,
     * shadow, proxy, mask, etc.)  Also removes all event listeners.
     * @param {Boolean} removeEl (optional) true to remove the element from the DOM
     */
    destroy : function(Y){
        if(this.isVisible()){
            this.animateTarget = null;
            this.hide();
        }

        Roo.EventManager.removeResizeListener(this.adjustViewport, this);
        if(this.tabs){
            this.tabs.destroy(Y);
        }

        Roo.destroy(
             this.shim,
             this.proxy,
             this.resizer,
             this.close,
             this.mask
        );
        if(this.dd){
            this.dd.unreg();
        }
        if(this.buttons){
           for(var  i = 0, len = this.buttons.length; i < len; i++){
               this.buttons[i].destroy();
           }
        }

        this.el.removeAllListeners();
        if(Y === true){
            this.el.update("");
            this.el.remove();
        }

        Roo.DialogManager.unregister(this);
    },

    // private
    startMove : function(){
        if(this.proxyDrag){
            this.proxy.show();
        }
        if(this.constraintoviewport !== false){
            this.dd.constrainTo(document.body, {right: this.shadowOffset, bottom: this.shadowOffset});
        }
    },

    // private
    endMove : function(){
        if(!this.proxyDrag){
            Roo.dd.DD.prototype.endDrag.apply(this.dd, arguments);
        }else {
            Roo.dd.DDProxy.prototype.endDrag.apply(this.dd, arguments);
            this.proxy.hide();
        }

        this.refreshSize();
        this.adjustAssets();
        this.focus();
        this.fireEvent("move", this, this.xy[0], this.xy[1]);
    },

    /**
     * Brings this dialog to the front of any other visible dialogs
     * @return {Roo.BasicDialog} this
     */
    toFront : function(){
        Roo.DialogManager.bringToFront(this);
        return  this;
    },

    /**
     * Sends this dialog to the back (under) of any other visible dialogs
     * @return {Roo.BasicDialog} this
     */
    toBack : function(){
        Roo.DialogManager.sendToBack(this);
        return  this;
    },

    /**
     * Centers this dialog in the viewport
     * @return {Roo.BasicDialog} this
     */
    center : function(){
        var  xy = this.el.getCenterXY(true);
        this.moveTo(xy[0], xy[1]);
        return  this;
    },

    /**
     * Moves the dialog's top-left corner to the specified point
     * @param {Number} x
     * @param {Number} y
     * @return {Roo.BasicDialog} this
     */
    moveTo : function(x, y){
        this.xy = [x,y];
        if(this.isVisible()){
            this.el.setXY(this.xy);
            this.adjustAssets();
        }
        return  this;
    },

    /**
     * Aligns the dialog to the specified element
     * @param {String/HTMLElement/Roo.Element} element The element to align to.
     * @param {String} position The position to align to (see {@link Roo.Element#alignTo} for more details).
     * @param {Array} offsets (optional) Offset the positioning by [x, y]
     * @return {Roo.BasicDialog} this
     */
    alignTo : function(Z, a, c){
        this.xy = this.el.getAlignToXY(Z, a, c);
        if(this.isVisible()){
            this.el.setXY(this.xy);
            this.adjustAssets();
        }
        return  this;
    },

    /**
     * Anchors an element to another element and realigns it when the window is resized.
     * @param {String/HTMLElement/Roo.Element} element The element to align to.
     * @param {String} position The position to align to (see {@link Roo.Element#alignTo} for more details)
     * @param {Array} offsets (optional) Offset the positioning by [x, y]
     * @param {Boolean/Number} monitorScroll (optional) true to monitor body scroll and reposition. If this parameter
     * is a number, it is used as the buffer delay (defaults to 50ms).
     * @return {Roo.BasicDialog} this
     */
    anchorTo : function(el, d, f, g){
        var  j = function(){
            this.alignTo(el, d, f);
        };
        Roo.EventManager.onWindowResize(j, this);
        var  tm = typeof  g;
        if(tm != 'undefined'){
            Roo.EventManager.on(window, 'scroll', j, this,
                {buffer: tm == 'number' ? g : 50});
        }

        j.call(this);
        return  this;
    },

    /**
     * Returns true if the dialog is visible
     * @return {Boolean}
     */
    isVisible : function(){
        return  this.el.isVisible();
    },

    // private
    animHide : function(l){
        var  b = Roo.get(this.animateTarget).getBox();
        this.proxy.show();
        this.proxy.setBounds(this.xy[0], this.xy[1], this.size.width, this.size.height);
        this.el.hide();
        this.proxy.setBounds(b.x, b.y, b.width, b.height, true, .35,
                    this.hideEl.createDelegate(this, [l]));
    },

    /**
     * Hides the dialog.
     * @param {Function} callback (optional) Function to call when the dialog is hidden
     * @return {Roo.BasicDialog} this
     */
    hide : function(m){
        if (this.fireEvent("beforehide", this) === false){
            return;
        }
        if(this.shadow){
            this.shadow.hide();
        }
        if(this.shim) {
          this.shim.hide();
        }
        if(this.animateTarget){
           this.animHide(m);
        }else {
            this.el.hide();
            this.hideEl(m);
        }
        return  this;
    },

    // private
    hideEl : function(n){
        this.proxy.hide();
        if(this.modal){
            this.mask.hide();
            Roo.get(document.body).removeClass("x-body-masked");
        }

        this.fireEvent("hide", this);
        if(typeof  n == "function"){
            n();
        }
    },

    // private
    hideAction : function(){
        this.setLeft("-10000px");
        this.setTop("-10000px");
        this.setStyle("visibility", "hidden");
    },

    // private
    refreshSize : function(){
        this.size = this.el.getSize();
        this.xy = this.el.getXY();
        Roo.state.Manager.set(this.stateId || this.el.id + "-state", this.el.getBox());
    },

    // private
    // z-index is managed by the DialogManager and may be overwritten at any time
    setZIndex : function(o){
        if(this.modal){
            this.mask.setStyle("z-index", o);
        }
        if(this.shim){
            this.shim.setStyle("z-index", ++o);
        }
        if(this.shadow){
            this.shadow.setZIndex(++o);
        }

        this.el.setStyle("z-index", ++o);
        if(this.proxy){
            this.proxy.setStyle("z-index", ++o);
        }
        if(this.resizer){
            this.resizer.proxy.setStyle("z-index", ++o);
        }


        this.lastZIndex = o;
    },

    /**
     * Returns the element for this dialog
     * @return {Roo.Element} The underlying dialog Element
     */
    getEl : function(){
        return  this.el;
    }
});

/**
 * @class Roo.DialogManager
 * Provides global access to BasicDialogs that have been created and
 * support for z-indexing (layering) multiple open dialogs.
 */
Roo.DialogManager = function(){
    var  p = {};
    var  q = [];
    var  r = null;

    // private
    var  t = function(d1, d2){
        return  (!d1._lastAccess || d1._lastAccess < d2._lastAccess) ? -1 : 1;
    };

    // private
    var  u = function(){
        q.sort(t);
        var  v = Roo.DialogManager.zseed;
        for(var  i = 0, len = q.length; i < len; i++){
            var  dlg = q[i];
            if(dlg){
                dlg.setZIndex(v + (i*10));
            }
        }
    };

    return  {
        /**
         * The starting z-index for BasicDialogs (defaults to 9000)
         * @type Number The z-index value
         */
        zseed : 9000,

        // private
        register : function(AD){
            p[AD.id] = AD;
            q.push(AD);
        },

        // private
        unregister : function(AE){
            delete  p[AE.id];
            var  i=0;
            var  AF=0;
            if(!q.indexOf){
                for(  i = 0, AF = q.length; i < AF; i++){
                    if(q[i] == AE){
                        q.splice(i, 1);
                        return;
                    }
                }
            }else {
                 i = q.indexOf(AE);
                if(i != -1){
                    q.splice(i, 1);
                }
            }
        },

        /**
         * Gets a registered dialog by id
         * @param {String/Object} id The id of the dialog or a dialog
         * @return {Roo.BasicDialog} this
         */
        get : function(id){
            return  typeof  id == "object" ? id : p[id];
        },

        /**
         * Brings the specified dialog to the front
         * @param {String/Object} dlg The id of the dialog or a dialog
         * @return {Roo.BasicDialog} this
         */
        bringToFront : function(AG){
            AG = this.get(AG);
            if(AG != r){
                r = AG;
                AG._lastAccess = new  Date().getTime();
                u();
            }
            return  AG;
        },

        /**
         * Sends the specified dialog to the back
         * @param {String/Object} dlg The id of the dialog or a dialog
         * @return {Roo.BasicDialog} this
         */
        sendToBack : function(AH){
            AH = this.get(AH);
            AH._lastAccess = -(new  Date().getTime());
            u();
            return  AH;
        },

        /**
         * Hides all dialogs
         */
        hideAll : function(){
            for(var  id  in  p){
                if(p[id] && typeof  p[id] != "function" && p[id].isVisible()){
                    p[id].hide();
                }
            }
        }
    };
}();

/**
 * @class Roo.LayoutDialog
 * @extends Roo.BasicDialog
 * Dialog which provides adjustments for working with a layout in a Dialog.
 * Add your necessary layout config options to the dialog's config.<br>
 * Example usage (including a nested layout):
 * <pre><code>
if(!dialog){
    dialog = new Roo.LayoutDialog("download-dlg", {
        modal: true,
        width:600,
        height:450,
        shadow:true,
        minWidth:500,
        minHeight:350,
        autoTabs:true,
        proxyDrag:true,
        // layout config merges with the dialog config
        center:{
            tabPosition: "top",
            alwaysShowTabs: true
        }
    });
    dialog.addKeyListener(27, dialog.hide, dialog);
    dialog.setDefaultButton(dialog.addButton("Close", dialog.hide, dialog));
    dialog.addButton("Build It!", this.getDownload, this);

    // we can even add nested layouts
    var innerLayout = new Roo.BorderLayout("dl-inner", {
        east: {
            initialSize: 200,
            autoScroll:true,
            split:true
        },
        center: {
            autoScroll:true
        }
    });
    innerLayout.beginUpdate();
    innerLayout.add("east", new Roo.ContentPanel("dl-details"));
    innerLayout.add("center", new Roo.ContentPanel("selection-panel"));
    innerLayout.endUpdate(true);

    var layout = dialog.getLayout();
    layout.beginUpdate();
    layout.add("center", new Roo.ContentPanel("standard-panel",
                        {title: "Download the Source", fitToFrame:true}));
    layout.add("center", new Roo.NestedLayoutPanel(innerLayout,
               {title: "Build your own roo.js"}));
    layout.getRegion("center").showPanel(sp);
    layout.endUpdate();
}
</code></pre>
    * @constructor
    * @param {String/HTMLElement/Roo.Element} el The id of or container element, or config
    * @param {Object} config configuration options
  */
Roo.LayoutDialog = function(el, v){
    
    var  z=  v;
    if (typeof(v) == 'undefined') {
        z = Roo.apply({}, el);
        el = Roo.get( document.documentElement || document.body).createChild();
        //config.autoCreate = true;
    }

    
    
    z.autoTabs = false;
    Roo.LayoutDialog.superclass.constructor.call(this, el, z);
    this.body.setStyle({overflow:"hidden", position:"relative"});
    this.layout = new  Roo.BorderLayout(this.body.dom, z);
    this.layout.monitorWindowResize = false;
    this.el.addClass("x-dlg-auto-layout");
    // fix case when center region overwrites center function
    this.center = Roo.BasicDialog.prototype.center;
    this.on("show", this.layout.layout, this.layout, true);
    if (z.items) {
        var  xitems = z.items;
        delete  z.items;
        Roo.each(xitems, this.addxtype, this);
    }
    
    
};
Roo.extend(Roo.LayoutDialog, Roo.BasicDialog, {
    /**
     * Ends update of the layout <strike>and resets display to none</strike>. Use standard beginUpdate/endUpdate on the layout.
     * @deprecated
     */
    endUpdate : function(){
        this.layout.endUpdate();
    },

    /**
     * Begins an update of the layout <strike>and sets display to block and visibility to hidden</strike>. Use standard beginUpdate/endUpdate on the layout.
     *  @deprecated
     */
    beginUpdate : function(){
        this.layout.beginUpdate();
    },

    /**
     * Get the BorderLayout for this dialog
     * @return {Roo.BorderLayout}
     */
    getLayout : function(){
        return  this.layout;
    },

    showEl : function(){
        Roo.LayoutDialog.superclass.showEl.apply(this, arguments);
        if(Roo.isIE7){
            this.layout.layout();
        }
    },

    // private
    // Use the syncHeightBeforeShow config option to control this automatically
    syncBodyHeight : function(){
        Roo.LayoutDialog.superclass.syncBodyHeight.call(this);
        if(this.layout){this.layout.layout();}
    },
    
      /**
     * Add an xtype element (actually adds to the layout.)
     * @return {Object} xdata xtype object data.
     */
    
    addxtype : function(c) {
        return  this.layout.addxtype(c);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.MessageBox
 * Utility class for generating different styles of message boxes.  The alias Roo.Msg can also be used.
 * Example usage:
 *<pre><code>
// Basic alert:
Roo.Msg.alert('Status', 'Changes saved successfully.');

// Prompt for user data:
Roo.Msg.prompt('Name', 'Please enter your name:', function(btn, text){
    if (btn == 'ok'){
        // process text value...
    }
});

// Show a dialog using config options:
Roo.Msg.show({
   title:'Save Changes?',
   msg: 'Your are closing a tab that has unsaved changes. Would you like to save your changes?',
   buttons: Roo.Msg.YESNOCANCEL,
   fn: processResult,
   animEl: 'elId'
});
</code></pre>
 * @singleton
 */
Roo.MessageBox = function(){
    var  A, B, C, D;
    var  E, F, G, H, I, pp;
    var  J, K, L;

    // private
    var  M = function(Q){
        A.hide();
        Roo.callback(B.fn, B.scope||window, [Q, K.dom.value], 1);
    };

    // private
    var  N = function(){
        if(B && B.cls){
            A.el.removeClass(B.cls);
        }
        if(D){
            Roo.TaskMgr.stop(D);
            D = null;
        }
    };

    // private
    var  O = function(b){
        var  Q = 0;
        if(!b){
            J["ok"].hide();
            J["cancel"].hide();
            J["yes"].hide();
            J["no"].hide();
            A.footer.dom.style.display = 'none';
            return  Q;
        }

        A.footer.dom.style.display = '';
        for(var  k  in  J){
            if(typeof  J[k] != "function"){
                if(b[k]){
                    J[k].show();
                    J[k].setText(typeof  b[k] == "string" ? b[k] : Roo.MessageBox.buttonText[k]);
                    Q += J[k].el.getWidth()+15;
                }else {
                    J[k].hide();
                }
            }
        }
        return  Q;
    };

    // private
    var  P = function(d, k, e){
        if(B && B.closable !== false){
            A.hide();
        }
        if(e){
            e.stopEvent();
        }
    };

    return  {
        /**
         * Returns a reference to the underlying {@link Roo.BasicDialog} element
         * @return {Roo.BasicDialog} The BasicDialog element
         */
        getDialog : function(){
           if(!A){
                A = new  Roo.BasicDialog("x-msg-box", {
                    autoCreate : true,
                    shadow: true,
                    draggable: true,
                    resizable:false,
                    constraintoviewport:false,
                    fixedcenter:true,
                    collapsible : false,
                    shim:true,
                    modal: true,
                    width:400, height:100,
                    buttonAlign:"center",
                    closeClick : function(){
                        if(B && B.buttons && B.buttons.no && !B.buttons.cancel){
                            M("no");
                        }else {
                            M("cancel");
                        }
                    }
                });
                A.on("hide", N);
                C = A.mask;
                A.addKeyListener(27, P);
                J = {};
                var  bt = this.buttonText;
                J["ok"] = A.addButton(bt["ok"], M.createCallback("ok"));
                J["yes"] = A.addButton(bt["yes"], M.createCallback("yes"));
                J["no"] = A.addButton(bt["no"], M.createCallback("no"));
                J["cancel"] = A.addButton(bt["cancel"], M.createCallback("cancel"));
                E = A.body.createChild({

                    html:'<span class="roo-mb-text"></span><br /><input type="text" class="roo-mb-input" /><textarea class="roo-mb-textarea"></textarea><div class="roo-mb-progress-wrap"><div class="roo-mb-progress"><div class="roo-mb-progress-bar">&#160;</div></div></div>'
                });
                F = E.dom.firstChild;
                G = Roo.get(E.dom.childNodes[2]);
                G.enableDisplayMode();
                G.addKeyListener([10,13], function(){
                    if(A.isVisible() && B && B.buttons){
                        if(B.buttons.ok){
                            M("ok");
                        }else  if(B.buttons.yes){
                            M("yes");
                        }
                    }
                });
                H = Roo.get(E.dom.childNodes[3]);
                H.enableDisplayMode();
                I = Roo.get(E.dom.childNodes[4]);
                I.enableDisplayMode();
                var  pf = I.dom.firstChild;
                if (pf) {
                    pp = Roo.get(pf.firstChild);
                    pp.setHeight(pf.offsetHeight);
                }
                
            }
            return  A;
        },

        /**
         * Updates the message box body text
         * @param {String} text (optional) Replaces the message box element's innerHTML with the specified string (defaults to
         * the XHTML-compliant non-breaking space character '&amp;#160;')
         * @return {Roo.MessageBox} This message box
         */
        updateText : function(j){
            if(!A.isVisible() && !B.width){
                A.resizeTo(this.maxWidth, 100); // resize first so content is never clipped from previous shows
            }

            F.innerHTML = j || '&#160;';
            var  w = Math.max(Math.min(B.width || F.offsetWidth, this.maxWidth), 
                        Math.max(B.minWidth || this.minWidth, L));
            if(B.prompt){
                K.setWidth(w);
            }
            if(A.isVisible()){
                A.fixedcenter = false;
            }

            A.setContentSize(w, E.getHeight());
            if(A.isVisible()){
                A.fixedcenter = true;
            }
            return  this;
        },

        /**
         * Updates a progress-style message box's text and progress bar.  Only relevant on message boxes
         * initiated via {@link Roo.MessageBox#progress} or by calling {@link Roo.MessageBox#show} with progress: true.
         * @param {Number} value Any number between 0 and 1 (e.g., .5)
         * @param {String} text (optional) If defined, the message box's body text is replaced with the specified string (defaults to undefined)
         * @return {Roo.MessageBox} This message box
         */
        updateProgress : function(l, m){
            if(m){
                this.updateText(m);
            }
            if (pp) { // weird bug on my firefox - for some reason this is not defined
                pp.setWidth(Math.floor(l*I.dom.firstChild.offsetWidth));
            }
            return  this;
        },        

        /**
         * Returns true if the message box is currently displayed
         * @return {Boolean} True if the message box is visible, else false
         */
        isVisible : function(){
            return  A && A.isVisible();  
        },

        /**
         * Hides the message box if it is displayed
         */
        hide : function(){
            if(this.isVisible()){
                A.hide();
            }  
        },

        /**
         * Displays a new message box, or reinitializes an existing message box, based on the config options
         * passed in. All functions (e.g. prompt, alert, etc) on MessageBox call this function internally.
         * The following config object properties are supported:
         * <pre>
Property    Type             Description
----------  ---------------  ------------------------------------------------------------------------------------
animEl            String/Element   An id or Element from which the message box should animate as it opens and
                                   closes (defaults to undefined)
buttons           Object/Boolean   A button config object (e.g., Roo.MessageBox.OKCANCEL or {ok:'Foo',
                                   cancel:'Bar'}), or false to not show any buttons (defaults to false)
closable          Boolean          False to hide the top-right close button (defaults to true).  Note that
                                   progress and wait dialogs will ignore this property and always hide the
                                   close button as they can only be closed programmatically.
cls               String           A custom CSS class to apply to the message box element
defaultTextHeight Number           The default height in pixels of the message box's multiline textarea if
                                   displayed (defaults to 75)
fn                Function         A callback function to execute after closing the dialog.  The arguments to the
                                   function will be btn (the name of the button that was clicked, if applicable,
                                   e.g. "ok"), and text (the value of the active text field, if applicable).
                                   Progress and wait dialogs will ignore this option since they do not respond to
                                   user actions and can only be closed programmatically, so any required function
                                   should be called by the same code after it closes the dialog.
icon              String           A CSS class that provides a background image to be used as an icon for
                                   the dialog (e.g., Roo.MessageBox.WARNING or 'custom-class', defaults to '')
maxWidth          Number           The maximum width in pixels of the message box (defaults to 600)
minWidth          Number           The minimum width in pixels of the message box (defaults to 100)
modal             Boolean          False to allow user interaction with the page while the message box is
                                   displayed (defaults to true)
msg               String           A string that will replace the existing message box body text (defaults
                                   to the XHTML-compliant non-breaking space character '&#160;')
multiline         Boolean          True to prompt the user to enter multi-line text (defaults to false)
progress          Boolean          True to display a progress bar (defaults to false)
progressText      String           The text to display inside the progress bar if progress = true (defaults to '')
prompt            Boolean          True to prompt the user to enter single-line text (defaults to false)
proxyDrag         Boolean          True to display a lightweight proxy while dragging (defaults to false)
title             String           The title text
value             String           The string value to set into the active textbox element if displayed
wait              Boolean          True to display a progress bar (defaults to false)
width             Number           The width of the dialog in pixels
</pre>
         *
         * Example usage:
         * <pre><code>
Roo.Msg.show({
   title: 'Address',
   msg: 'Please enter your address:',
   width: 300,
   buttons: Roo.MessageBox.OKCANCEL,
   multiline: true,
   fn: saveAddress,
   animEl: 'addAddressBtn'
});
</code></pre>
         * @param {Object} config Configuration options
         * @return {Roo.MessageBox} This message box
         */
        show : function(n){
            if(this.isVisible()){
                this.hide();
            }
            var  d = this.getDialog();
            B = n;
            d.setTitle(B.title || "&#160;");
            d.close.setDisplayed(B.closable !== false);
            K = G;
            B.prompt = B.prompt || (B.multiline ? true : false);
            if(B.prompt){
                if(B.multiline){
                    G.hide();
                    H.show();
                    H.setHeight(typeof  B.multiline == "number" ?
                        B.multiline : this.defaultTextHeight);
                    K = H;
                }else {
                    G.show();
                    H.hide();
                }
            }else {
                G.hide();
                H.hide();
            }

            I.setDisplayed(B.progress === true);
            this.updateProgress(0);
            K.dom.value = B.value || "";
            if(B.prompt){
                A.setDefaultButton(K);
            }else {
                var  bs = B.buttons;
                var  db = null;
                if(bs && bs.ok){
                    db = J["ok"];
                }else  if(bs && bs.yes){
                    db = J["yes"];
                }

                A.setDefaultButton(db);
            }

            L = O(B.buttons);
            this.updateText(B.msg);
            if(B.cls){
                d.el.addClass(B.cls);
            }

            d.proxyDrag = B.proxyDrag === true;
            d.modal = B.modal !== false;
            d.mask = B.modal !== false ? C : false;
            if(!d.isVisible()){
                // force it to the end of the z-index stack so it gets a cursor in FF
                document.body.appendChild(A.el.dom);
                d.animateTarget = null;
                d.show(n.animEl);
            }
            return  this;
        },

        /**
         * Displays a message box with a progress bar.  This message box has no buttons and is not closeable by
         * the user.  You are responsible for updating the progress bar as needed via {@link Roo.MessageBox#updateProgress}
         * and closing the message box when the process is complete.
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @return {Roo.MessageBox} This message box
         */
        progress : function(o, p){
            this.show({
                title : o,
                msg : p,
                buttons: false,
                progress:true,
                closable:false,
                minWidth: this.minProgressWidth,
                modal : true
            });
            return  this;
        },

        /**
         * Displays a standard read-only message box with an OK button (comparable to the basic JavaScript Window.alert).
         * If a callback function is passed it will be called after the user clicks the button, and the
         * id of the button that was clicked will be passed as the only parameter to the callback
         * (could also be the top-right close button).
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} fn (optional) The callback function invoked after the message box is closed
         * @param {Object} scope (optional) The scope of the callback function
         * @return {Roo.MessageBox} This message box
         */
        alert : function(q, r, fn, s){
            this.show({
                title : q,
                msg : r,
                buttons: this.OK,
                fn: fn,
                scope : s,
                modal : true
            });
            return  this;
        },

        /**
         * Displays a message box with an infinitely auto-updating progress bar.  This can be used to block user
         * interaction while waiting for a long-running process to complete that does not have defined intervals.
         * You are responsible for closing the message box when the process is complete.
         * @param {String} msg The message box body text
         * @param {String} title (optional) The title bar text
         * @return {Roo.MessageBox} This message box
         */
        wait : function(t, u){
            this.show({
                title : u,
                msg : t,
                buttons: false,
                closable:false,
                progress:true,
                modal:true,
                width:300,
                wait:true
            });
            D = Roo.TaskMgr.start({
                run: function(i){
                    Roo.MessageBox.updateProgress(((((i+20)%20)+1)*5)*.01);
                },
                interval: 1000
            });
            return  this;
        },

        /**
         * Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's Window.confirm).
         * If a callback function is passed it will be called after the user clicks either button, and the id of the
         * button that was clicked will be passed as the only parameter to the callback (could also be the top-right close button).
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} fn (optional) The callback function invoked after the message box is closed
         * @param {Object} scope (optional) The scope of the callback function
         * @return {Roo.MessageBox} This message box
         */
        confirm : function(v, x, fn, y){
            this.show({
                title : v,
                msg : x,
                buttons: this.YESNO,
                fn: fn,
                scope : y,
                modal : true
            });
            return  this;
        },

        /**
         * Displays a message box with OK and Cancel buttons prompting the user to enter some text (comparable to
         * JavaScript's Window.prompt).  The prompt can be a single-line or multi-line textbox.  If a callback function
         * is passed it will be called after the user clicks either button, and the id of the button that was clicked
         * (could also be the top-right close button) and the text that was entered will be passed as the two
         * parameters to the callback.
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} fn (optional) The callback function invoked after the message box is closed
         * @param {Object} scope (optional) The scope of the callback function
         * @param {Boolean/Number} multiline (optional) True to create a multiline textbox using the defaultTextHeight
         * property, or the height in pixels to create the textbox (defaults to false / single-line)
         * @return {Roo.MessageBox} This message box
         */
        prompt : function(z, AA, fn, AB, AC){
            this.show({
                title : z,
                msg : AA,
                buttons: this.OKCANCEL,
                fn: fn,
                minWidth:250,
                scope : AB,
                prompt:true,
                multiline: AC,
                modal : true
            });
            return  this;
        },

        /**
         * Button config that displays a single OK button
         * @type Object
         */
        OK : {ok:true},
        /**
         * Button config that displays Yes and No buttons
         * @type Object
         */
        YESNO : {yes:true, no:true},
        /**
         * Button config that displays OK and Cancel buttons
         * @type Object
         */
        OKCANCEL : {ok:true, cancel:true},
        /**
         * Button config that displays Yes, No and Cancel buttons
         * @type Object
         */
        YESNOCANCEL : {yes:true, no:true, cancel:true},

        /**
         * The default height in pixels of the message box's multiline textarea if displayed (defaults to 75)
         * @type Number
         */
        defaultTextHeight : 75,
        /**
         * The maximum width in pixels of the message box (defaults to 600)
         * @type Number
         */
        maxWidth : 600,
        /**
         * The minimum width in pixels of the message box (defaults to 100)
         * @type Number
         */
        minWidth : 100,
        /**
         * The minimum width in pixels of the message box if it is a progress-style dialog.  This is useful
         * for setting a different minimum width than text-only dialogs may need (defaults to 250)
         * @type Number
         */
        minProgressWidth : 250,
        /**
         * An object containing the default button text strings that can be overriden for localized language support.
         * Supported properties are: ok, cancel, yes and no.
         * Customize the default text like so: Roo.MessageBox.buttonText.yes = "S?";
         * @type Object
         */
        buttonText : {
            ok : "OK",
            cancel : "Cancel",
            yes : "Yes",
            no : "No"
        }
    };
}();

/**
 * Shorthand for {@link Roo.MessageBox}
 */
Roo.Msg = Roo.MessageBox;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.QuickTips
 * Provides attractive and customizable tooltips for any element.
 * @singleton
 */
Roo.QuickTips = function(){
    var  el, A, B, C, tm, D, E, F = {}, esc, removeCls = null, bdLeft, bdRight;
    var  ce, bd, xy, dd;
    var  G = false, H = true, I = false;
    var  J = 1, K = 1, L = 1, M = [];
    
    var  N = function(e){
        if(H){
            return;
        }
        var  t = e.getTarget();
        if(!t || t.nodeType !== 1 || t == document || t == document.body){
            return;
        }
        if(ce && t == ce.el){
            clearTimeout(K);
            return;
        }
        if(t && F[t.id]){
            F[t.id].el = t;
            J = S.defer(tm.showDelay, tm, [F[t.id]]);
            return;
        }
        var  W, et = Roo.fly(t);
        var  ns = D.namespace;
        if(tm.interceptTitles && t.title){
            W = t.title;
            t.qtip = W;
            t.removeAttribute("title");
            e.preventDefault();
        }else {
            W = t.qtip || et.getAttributeNS(ns, D.attribute);
        }
        if(W){
            J = S.defer(tm.showDelay, tm, [{
                el: t, 
                text: W, 
                width: et.getAttributeNS(ns, D.width),
                autoHide: et.getAttributeNS(ns, D.hide) != "user",
                title: et.getAttributeNS(ns, D.title),
           	    cls: et.getAttributeNS(ns, D.cls)
            }]);
        }
    };
    
    var  O = function(e){
        clearTimeout(J);
        var  t = e.getTarget();
        if(t && ce && ce.el == t && (tm.autoHide && ce.autoHide !== false)){
            K = setTimeout(U, tm.hideDelay);
        }
    };
    
    var  P = function(e){
        if(H){
            return;
        }

        xy = e.getXY();
        xy[1] += 18;
        if(tm.trackMouse && ce){
            el.setXY(xy);
        }
    };
    
    var  Q = function(e){
        clearTimeout(J);
        clearTimeout(K);
        if(!e.within(el)){
            if(tm.hideOnClick){
                U();
                tm.disable();
                tm.enable.defer(100, tm);
            }
        }
    };
    
    var  R = function(){
        return  2;//bdLeft.getPadding('l')+bdRight.getPadding('r');
    };

    var  S = function(o){
        if(H){
            return;
        }

        clearTimeout(L);
        ce = o;
        if(removeCls){ // in case manually hidden
            el.removeClass(removeCls);
            removeCls = null;
        }
        if(ce.cls){
            el.addClass(ce.cls);
            removeCls = ce.cls;
        }
        if(ce.title){
            C.update(ce.title);
            C.show();
        }else {
            C.update('');
            C.hide();
        }

        el.dom.style.width  = tm.maxWidth+'px';
        //tipBody.dom.style.width = '';
        B.update(o.text);
        var  p = R(), w = ce.width;
        if(!w){
            var  td = B.dom;
            var  aw = Math.max(td.offsetWidth, td.clientWidth, td.scrollWidth);
            if(aw > tm.maxWidth){
                w = tm.maxWidth;
            }else  if(aw < tm.minWidth){
                w = tm.minWidth;
            }else {
                w = aw;
            }
        }

        //tipBody.setWidth(w);
        el.setWidth(parseInt(w, 10) + p);
        if(ce.autoHide === false){
            E.setDisplayed(true);
            if(dd){
                dd.unlock();
            }
        }else {
            E.setDisplayed(false);
            if(dd){
                dd.lock();
            }
        }
        if(xy){
            el.avoidY = xy[1]-18;
            el.setXY(xy);
        }
        if(tm.animate){
            el.setOpacity(.1);
            el.setStyle("visibility", "visible");
            el.fadeIn({callback: T});
        }else {
            T();
        }
    };
    
    var  T = function(){
        if(ce){
            el.show();
            esc.enable();
            if(tm.autoDismiss && ce.autoHide !== false){
                L = setTimeout(U, tm.autoDismissDelay);
            }
        }
    };
    
    var  U = function(W){
        clearTimeout(L);
        clearTimeout(K);
        ce = null;
        if(el.isVisible()){
            esc.disable();
            if(W !== true && tm.animate){
                el.fadeOut({callback: V});
            }else {
                V();
            } 
        }
    };
    
    var  V = function(){
        el.hide();
        if(removeCls){
            el.removeClass(removeCls);
            removeCls = null;
        }
    };
    
    return  {
        /**
        * @cfg {Number} minWidth
        * The minimum width of the quick tip (defaults to 40)
        */
       minWidth : 40,
        /**
        * @cfg {Number} maxWidth
        * The maximum width of the quick tip (defaults to 300)
        */
       maxWidth : 300,
        /**
        * @cfg {Boolean} interceptTitles
        * True to automatically use the element's DOM title value if available (defaults to false)
        */
       interceptTitles : false,
        /**
        * @cfg {Boolean} trackMouse
        * True to have the quick tip follow the mouse as it moves over the target element (defaults to false)
        */
       trackMouse : false,
        /**
        * @cfg {Boolean} hideOnClick
        * True to hide the quick tip if the user clicks anywhere in the document (defaults to true)
        */
       hideOnClick : true,
        /**
        * @cfg {Number} showDelay
        * Delay in milliseconds before the quick tip displays after the mouse enters the target element (defaults to 500)
        */
       showDelay : 500,
        /**
        * @cfg {Number} hideDelay
        * Delay in milliseconds before the quick tip hides when autoHide = true (defaults to 200)
        */
       hideDelay : 200,
        /**
        * @cfg {Boolean} autoHide
        * True to automatically hide the quick tip after the mouse exits the target element (defaults to true).
        * Used in conjunction with hideDelay.
        */
       autoHide : true,
        /**
        * @cfg {Boolean}
        * True to automatically hide the quick tip after a set period of time, regardless of the user's actions
        * (defaults to true).  Used in conjunction with autoDismissDelay.
        */
       autoDismiss : true,
        /**
        * @cfg {Number}
        * Delay in milliseconds before the quick tip hides when autoDismiss = true (defaults to 5000)
        */
       autoDismissDelay : 5000,
       /**
        * @cfg {Boolean} animate
        * True to turn on fade animation. Defaults to false (ClearType/scrollbar flicker issues in IE7).
        */
       animate : false,

       /**
        * @cfg {String} title
        * Title text to display (defaults to '').  This can be any valid HTML markup.
        */
        title: '',
       /**
        * @cfg {String} text
        * Body text to display (defaults to '').  This can be any valid HTML markup.
        */
        text : '',
       /**
        * @cfg {String} cls
        * A CSS class to apply to the base quick tip element (defaults to '').
        */
        cls : '',
       /**
        * @cfg {Number} width
        * Width in pixels of the quick tip (defaults to auto).  Width will be ignored if it exceeds the bounds of
        * minWidth or maxWidth.
        */
        width : null,

    /**
     * Initialize and enable QuickTips for first use.  This should be called once before the first attempt to access
     * or display QuickTips in a page.
     */
       init : function(){
          tm = Roo.QuickTips;
          D = tm.tagConfig;
          if(!I){
              if(!Roo.isReady){ // allow calling of init() before onReady
                  Roo.onReady(Roo.QuickTips.init, Roo.QuickTips);
                  return;
              }

              el = new  Roo.Layer({cls:"x-tip", shadow:"drop", shim: true, constrain:true, shadowOffset:4});
              el.fxDefaults = {stopFx: true};
              // maximum custom styling
              //el.update('<div class="x-tip-top-left"><div class="x-tip-top-right"><div class="x-tip-top"></div></div></div><div class="x-tip-bd-left"><div class="x-tip-bd-right"><div class="x-tip-bd"><div class="x-tip-close"></div><h3></h3><div class="x-tip-bd-inner"></div><div class="x-clear"></div></div></div></div><div class="x-tip-ft-left"><div class="x-tip-ft-right"><div class="x-tip-ft"></div></div></div>');
              el.update('<div class="x-tip-bd"><div class="x-tip-close"></div><h3></h3><div class="x-tip-bd-inner"></div><div class="x-clear"></div></div>');              
              C = el.child('h3');
              C.enableDisplayMode("block");
              A = el.child('div.x-tip-bd');
              B = el.child('div.x-tip-bd-inner');
              //bdLeft = el.child('div.x-tip-bd-left');
              //bdRight = el.child('div.x-tip-bd-right');
              E = el.child('div.x-tip-close');
              E.enableDisplayMode("block");
              E.on("click", U);
              var  d = Roo.get(document);
              d.on("mousedown", Q);
              d.on("mouseover", N);
              d.on("mouseout", O);
              d.on("mousemove", P);
              esc = d.addKeyListener(27, U);
              esc.disable();
              if(Roo.dd.DD){
                  dd = el.initDD("default", null, {
                      onDrag : function(){
                          el.sync();  
                      }
                  });
                  dd.setHandleElId(C.id);
                  dd.lock();
              }

              I = true;
          }

          this.enable(); 
       },

    /**
     * Configures a new quick tip instance and assigns it to a target element.  The following config options
     * are supported:
     * <pre>
Property    Type                   Description
----------  ---------------------  ------------------------------------------------------------------------
target      Element/String/Array   An Element, id or array of ids that this quick tip should be tied to
     * </ul>
     * @param {Object} config The config object
     */
       register : function(X){
           var  cs = X  instanceof  Array ? X : arguments;
           for(var  i = 0, len = cs.length; i < len; i++) {
               var  c = cs[i];
               var  target = c.target;
               if(target){
                   if(target  instanceof  Array){
                       for(var  j = 0, jlen = target.length; j < jlen; j++){
                           F[target[j]] = c;
                       }
                   }else {
                       F[typeof  target == 'string' ? target : Roo.id(target)] = c;
                   }
               }
           }
       },

    /**
     * Removes this quick tip from its element and destroys it.
     * @param {String/HTMLElement/Element} el The element from which the quick tip is to be removed.
     */
       unregister : function(el){
           delete  F[Roo.id(el)];
       },

    /**
     * Enable this quick tip.
     */
       enable : function(){
           if(I && H){
               M.pop();
               if(M.length < 1){
                   H = false;
               }
           }
       },

    /**
     * Disable this quick tip.
     */
       disable : function(){
          H = true;
          clearTimeout(J);
          clearTimeout(K);
          clearTimeout(L);
          if(ce){
              U(true);
          }

          M.push(1);
       },

    /**
     * Returns true if the quick tip is enabled, else false.
     */
       isEnabled : function(){
            return  !H;
       },

        // private
       tagConfig : {
           namespace : "ext",
           attribute : "qtip",
           width : "width",
           target : "target",
           title : "qtitle",
           hide : "hide",
           cls : "qclass"
       }
   };
}();

// backwards compat
Roo.QuickTips.tips = Roo.QuickTips.register;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.tree.TreePanel
 * @extends Roo.data.Tree

 * @cfg {Boolean} rootVisible false to hide the root node (defaults to true)
 * @cfg {Boolean} lines false to disable tree lines (defaults to true)
 * @cfg {Boolean} enableDD true to enable drag and drop
 * @cfg {Boolean} enableDrag true to enable just drag
 * @cfg {Boolean} enableDrop true to enable just drop
 * @cfg {Object} dragConfig Custom config to pass to the {@link Roo.tree.TreeDragZone} instance
 * @cfg {Object} dropConfig Custom config to pass to the {@link Roo.tree.TreeDropZone} instance
 * @cfg {String} ddGroup The DD group this TreePanel belongs to
 * @cfg {String} ddAppendOnly True if the tree should only allow append drops (use for trees which are sorted)
 * @cfg {Boolean} ddScroll true to enable YUI body scrolling
 * @cfg {Boolean} containerScroll true to register this container with ScrollManager
 * @cfg {Boolean} hlDrop false to disable node highlight on drop (defaults to the value of Roo.enableFx)
 * @cfg {String} hlColor The color of the node highlight (defaults to C3DAF9)
 * @cfg {Boolean} animate true to enable animated expand/collapse (defaults to the value of Roo.enableFx)
 * @cfg {Boolean} singleExpand true if only 1 node per branch may be expanded
 * @cfg {Boolean} selModel A tree selection model to use with this TreePanel (defaults to a {@link Roo.tree.DefaultSelectionModel})
 * @cfg {Boolean} loader A TreeLoader for use with this TreePanel
 * @cfg {String} pathSeparator The token used to separate sub-paths in path strings (defaults to '/')
 * @cfg {Function} renderer Sets the rendering (formatting) function for the nodes. to return HTML markup for the tree view. The render function is called with  the following parameters:<ul><li>The {Object} The data for the node.</li></ul>
 * @cfg {Function} rendererTip Sets the rendering (formatting) function for the nodes hovertip to return HTML markup for the tree view. The render function is called with  the following parameters:<ul><li>The {Object} The data for the node.</li></ul>
 * 
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.tree.TreePanel = function(el, A){
    var  B = false;
    var  C = false;
    if (A.root) {
        B = A.root;
        delete  A.root;
    }
    if (A.loader) {
        C = A.loader;
        delete  A.loader;
    }

    
    Roo.apply(this, A);
    Roo.tree.TreePanel.superclass.constructor.call(this);
    this.el = Roo.get(el);
    this.el.addClass('x-tree');
    //console.log(root);
    if (B) {
        this.setRootNode( Roo.factory(B, Roo.tree));
    }
    if (C) {
        this.loader = Roo.factory(C, Roo.tree);
    }

   /**
    * Read-only. The id of the container element becomes this TreePanel's id.
    */
   this.id = this.el.id;
   this.addEvents({
        /**
        * @event beforeload
        * Fires before a node is loaded, return false to cancel
        * @param {Node} node The node being loaded
        */
        "beforeload" : true,
        /**
        * @event load
        * Fires when a node is loaded
        * @param {Node} node The node that was loaded
        */
        "load" : true,
        /**
        * @event textchange
        * Fires when the text for a node is changed
        * @param {Node} node The node
        * @param {String} text The new text
        * @param {String} oldText The old text
        */
        "textchange" : true,
        /**
        * @event beforeexpand
        * Fires before a node is expanded, return false to cancel.
        * @param {Node} node The node
        * @param {Boolean} deep
        * @param {Boolean} anim
        */
        "beforeexpand" : true,
        /**
        * @event beforecollapse
        * Fires before a node is collapsed, return false to cancel.
        * @param {Node} node The node
        * @param {Boolean} deep
        * @param {Boolean} anim
        */
        "beforecollapse" : true,
        /**
        * @event expand
        * Fires when a node is expanded
        * @param {Node} node The node
        */
        "expand" : true,
        /**
        * @event disabledchange
        * Fires when the disabled status of a node changes
        * @param {Node} node The node
        * @param {Boolean} disabled
        */
        "disabledchange" : true,
        /**
        * @event collapse
        * Fires when a node is collapsed
        * @param {Node} node The node
        */
        "collapse" : true,
        /**
        * @event beforeclick
        * Fires before click processing on a node. Return false to cancel the default action.
        * @param {Node} node The node
        * @param {Roo.EventObject} e The event object
        */
        "beforeclick":true,
        /**
        * @event checkchange
        * Fires when a node with a checkbox's checked property changes
        * @param {Node} this This node
        * @param {Boolean} checked
        */
        "checkchange":true,
        /**
        * @event click
        * Fires when a node is clicked
        * @param {Node} node The node
        * @param {Roo.EventObject} e The event object
        */
        "click":true,
        /**
        * @event dblclick
        * Fires when a node is double clicked
        * @param {Node} node The node
        * @param {Roo.EventObject} e The event object
        */
        "dblclick":true,
        /**
        * @event contextmenu
        * Fires when a node is right clicked
        * @param {Node} node The node
        * @param {Roo.EventObject} e The event object
        */
        "contextmenu":true,
        /**
        * @event beforechildrenrendered
        * Fires right before the child nodes for a node are rendered
        * @param {Node} node The node
        */
        "beforechildrenrendered":true,
       /**
	     * @event startdrag
	     * Fires when a node starts being dragged
	     * @param {Roo.tree.TreePanel} this
	     * @param {Roo.tree.TreeNode} node
	     * @param {event} e The raw browser event
	     */ 
	    "startdrag" : true,
	    /**
	     * @event enddrag
	     * Fires when a drag operation is complete
	     * @param {Roo.tree.TreePanel} this
	     * @param {Roo.tree.TreeNode} node
	     * @param {event} e The raw browser event
	     */
	    "enddrag" : true,
	    /**
	     * @event dragdrop
	     * Fires when a dragged node is dropped on a valid DD target
	     * @param {Roo.tree.TreePanel} this
	     * @param {Roo.tree.TreeNode} node
	     * @param {DD} dd The dd it was dropped on
	     * @param {event} e The raw browser event
	     */
	    "dragdrop" : true,
	    /**
	     * @event beforenodedrop
	     * Fires when a DD object is dropped on a node in this tree for preprocessing. Return false to cancel the drop. The dropEvent
	     * passed to handlers has the following properties:<br />
	     * <ul style="padding:5px;padding-left:16px;">
	     * <li>tree - The TreePanel</li>
	     * <li>target - The node being targeted for the drop</li>
	     * <li>data - The drag data from the drag source</li>
	     * <li>point - The point of the drop - append, above or below</li>
	     * <li>source - The drag source</li>
	     * <li>rawEvent - Raw mouse event</li>
	     * <li>dropNode - Drop node(s) provided by the source <b>OR</b> you can supply node(s)
	     * to be inserted by setting them on this object.</li>
	     * <li>cancel - Set this to true to cancel the drop.</li>
	     * </ul>
	     * @param {Object} dropEvent
	     */
	    "beforenodedrop" : true,
	    /**
	     * @event nodedrop
	     * Fires after a DD object is dropped on a node in this tree. The dropEvent
	     * passed to handlers has the following properties:<br />
	     * <ul style="padding:5px;padding-left:16px;">
	     * <li>tree - The TreePanel</li>
	     * <li>target - The node being targeted for the drop</li>
	     * <li>data - The drag data from the drag source</li>
	     * <li>point - The point of the drop - append, above or below</li>
	     * <li>source - The drag source</li>
	     * <li>rawEvent - Raw mouse event</li>
	     * <li>dropNode - Dropped node(s).</li>
	     * </ul>
	     * @param {Object} dropEvent
	     */
	    "nodedrop" : true,
	     /**
	     * @event nodedragover
	     * Fires when a tree node is being targeted for a drag drop, return false to signal drop not allowed. The dragOverEvent
	     * passed to handlers has the following properties:<br />
	     * <ul style="padding:5px;padding-left:16px;">
	     * <li>tree - The TreePanel</li>
	     * <li>target - The node being targeted for the drop</li>
	     * <li>data - The drag data from the drag source</li>
	     * <li>point - The point of the drop - append, above or below</li>
	     * <li>source - The drag source</li>
	     * <li>rawEvent - Raw mouse event</li>
	     * <li>dropNode - Drop node(s) provided by the source.</li>
	     * <li>cancel - Set this to true to signal drop not allowed.</li>
	     * </ul>
	     * @param {Object} dragOverEvent
	     */
	    "nodedragover" : true
        
   });
   if(this.singleExpand){
       this.on("beforeexpand", this.restrictExpand, this);
   }
};
Roo.extend(Roo.tree.TreePanel, Roo.data.Tree, {
    rootVisible : true,
    animate: Roo.enableFx,
    lines : true,
    enableDD : false,
    hlDrop : Roo.enableFx,
  
    renderer: false,
    
    rendererTip: false,
    // private
    restrictExpand : function(D){
        var  p = D.parentNode;
        if(p){
            if(p.expandedChild && p.expandedChild.parentNode == p){
                p.expandedChild.collapse();
            }

            p.expandedChild = D;
        }
    },

    // private override
    setRootNode : function(E){
        Roo.tree.TreePanel.superclass.setRootNode.call(this, E);
        if(!this.rootVisible){
            E.ui = new  Roo.tree.RootTreeNodeUI(E);
        }
        return  E;
    },

    /**
     * Returns the container element for this TreePanel
     */
    getEl : function(){
        return  this.el;
    },

    /**
     * Returns the default TreeLoader for this TreePanel
     */
    getLoader : function(){
        return  this.loader;
    },

    /**
     * Expand all nodes
     */
    expandAll : function(){
        this.root.expand(true);
    },

    /**
     * Collapse all nodes
     */
    collapseAll : function(){
        this.root.collapse(true);
    },

    /**
     * Returns the selection model used by this TreePanel
     */
    getSelectionModel : function(){
        if(!this.selModel){
            this.selModel = new  Roo.tree.DefaultSelectionModel();
        }
        return  this.selModel;
    },

    /**
     * Retrieve an array of checked nodes, or an array of a specific attribute of checked nodes (e.g. "id")
     * @param {String} attribute (optional) Defaults to null (return the actual nodes)
     * @param {TreeNode} startNode (optional) The node to start from, defaults to the root
     * @return {Array}
     */
    getChecked : function(a, F){
        F = F || this.root;
        var  r = [];
        var  f = function(){
            if(this.attributes.checked){
                r.push(!a ? this : (a == 'id' ? this.id : this.attributes[a]));
            }
        }

        F.cascade(f);
        return  r;
    },

    /**
     * Expands a specified path in this TreePanel. A path can be retrieved from a node with {@link Roo.data.Node#getPath}
     * @param {String} path
     * @param {String} attr (optional) The attribute used in the path (see {@link Roo.data.Node#getPath} for more info)
     * @param {Function} callback (optional) The callback to call when the expand is complete. The callback will be called with
     * (bSuccess, oLastNode) where bSuccess is if the expand was successful and oLastNode is the last node that was expanded.
     */
    expandPath : function(G, H, I){
        H = H || "id";
        var  J = G.split(this.pathSeparator);
        var  K = this.root;
        if(K.attributes[H] != J[1]){ // invalid root
            if(I){
                I(false, null);
            }
            return;
        }
        var  L = 1;
        var  f = function(){
            if(++L == J.length){
                if(I){
                    I(true, K);
                }
                return;
            }
            var  c = K.findChild(H, J[L]);
            if(!c){
                if(I){
                    I(false, K);
                }
                return;
            }

            K = c;
            c.expand(false, false, f);
        };
        K.expand(false, false, f);
    },

    /**
     * Selects the node in this tree at the specified path. A path can be retrieved from a node with {@link Roo.data.Node#getPath}
     * @param {String} path
     * @param {String} attr (optional) The attribute used in the path (see {@link Roo.data.Node#getPath} for more info)
     * @param {Function} callback (optional) The callback to call when the selection is complete. The callback will be called with
     * (bSuccess, oSelNode) where bSuccess is if the selection was successful and oSelNode is the selected node.
     */
    selectPath : function(M, N, O){
        N = N || "id";
        var  P = M.split(this.pathSeparator);
        var  v = P.pop();
        if(P.length > 0){
            var  f = function(Q, R){
                if(Q && R){
                    var  n = R.findChild(N, v);
                    if(n){
                        n.select();
                        if(O){
                            O(true, n);
                        }
                    }else  if(O){
                        O(false, n);
                    }
                }else {
                    if(O){
                        O(false, n);
                    }
                }
            };
            this.expandPath(P.join(this.pathSeparator), N, f);
        }else {
            this.root.select();
            if(O){
                O(true, this.root);
            }
        }
    },

    getTreeEl : function(){
        return  this.el;
    },

    /**
     * Trigger rendering of this TreePanel
     */
    render : function(){
        if (this.innerCt) {
            return  this; // stop it rendering more than once!!
        }

        
        this.innerCt = this.el.createChild({tag:"ul",
               cls:"x-tree-root-ct " +
               (this.lines ? "x-tree-lines" : "x-tree-no-lines")});

        if(this.containerScroll){
            Roo.dd.ScrollManager.register(this.el);
        }
        if((this.enableDD || this.enableDrop) && !this.dropZone){
           /**
            * The dropZone used by this tree if drop is enabled
            * @type Roo.tree.TreeDropZone
            */
             this.dropZone = new  Roo.tree.TreeDropZone(this, this.dropConfig || {
               ddGroup: this.ddGroup || "TreeDD", appendOnly: this.ddAppendOnly === true
           });
        }
        if((this.enableDD || this.enableDrag) && !this.dragZone){
           /**
            * The dragZone used by this tree if drag is enabled
            * @type Roo.tree.TreeDragZone
            */
            this.dragZone = new  Roo.tree.TreeDragZone(this, this.dragConfig || {
               ddGroup: this.ddGroup || "TreeDD",
               scroll: this.ddScroll
           });
        }

        this.getSelectionModel().init(this);
        if (!this.root) {
            console.log("ROOT not set in tree");
            return;
        }

        this.root.render();
        if(!this.rootVisible){
            this.root.renderChildren();
        }
        return  this;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.tree.DefaultSelectionModel
 * @extends Roo.util.Observable
 * The default single selection for a TreePanel.
 */
Roo.tree.DefaultSelectionModel = function(){
   this.selNode = null;
   
   this.addEvents({
       /**
        * @event selectionchange
        * Fires when the selected node changes
        * @param {DefaultSelectionModel} this
        * @param {TreeNode} node the new selection
        */
       "selectionchange" : true,

       /**
        * @event beforeselect
        * Fires before the selected node changes, return false to cancel the change
        * @param {DefaultSelectionModel} this
        * @param {TreeNode} node the new selection
        * @param {TreeNode} node the old selection
        */
       "beforeselect" : true
   });
};

Roo.extend(Roo.tree.DefaultSelectionModel, Roo.util.Observable, {
    init : function(A){
        this.tree = A;
        A.getTreeEl().on("keydown", this.onKeyDown, this);
        A.on("click", this.onNodeClick, this);
    },
    
    onNodeClick : function(B, e){
        if (e.ctrlKey && this.selNode == B)  {
            this.unselect(B);
            return;
        }

        this.select(B);
    },
    
    /**
     * Select a node.
     * @param {TreeNode} node The node to select
     * @return {TreeNode} The selected node
     */
    select : function(C){
        var  D = this.selNode;
        if(D != C && this.fireEvent('beforeselect', this, C, D) !== false){
            if(D){
                D.ui.onSelectedChange(false);
            }

            this.selNode = C;
            C.ui.onSelectedChange(true);
            this.fireEvent("selectionchange", this, C, D);
        }
        return  C;
    },
    
    /**
     * Deselect a node.
     * @param {TreeNode} node The node to unselect
     */
    unselect : function(E){
        if(this.selNode == E){
            this.clearSelections();
        }    
    },
    
    /**
     * Clear all selections
     */
    clearSelections : function(){
        var  n = this.selNode;
        if(n){
            n.ui.onSelectedChange(false);
            this.selNode = null;
            this.fireEvent("selectionchange", this, null);
        }
        return  n;
    },
    
    /**
     * Get the selected node
     * @return {TreeNode} The selected node
     */
    getSelectedNode : function(){
        return  this.selNode;    
    },
    
    /**
     * Returns true if the node is selected
     * @param {TreeNode} node The node to check
     * @return {Boolean}
     */
    isSelected : function(F){
        return  this.selNode == F;  
    },

    /**
     * Selects the node above the selected node in the tree, intelligently walking the nodes
     * @return TreeNode The new selection
     */
    selectPrevious : function(){
        var  s = this.selNode || this.lastSelNode;
        if(!s){
            return  null;
        }
        var  ps = s.previousSibling;
        if(ps){
            if(!ps.isExpanded() || ps.childNodes.length < 1){
                return  this.select(ps);
            } else {
                var  lc = ps.lastChild;
                while(lc && lc.isExpanded() && lc.childNodes.length > 0){
                    lc = lc.lastChild;
                }
                return  this.select(lc);
            }
        } else  if(s.parentNode && (this.tree.rootVisible || !s.parentNode.isRoot)){
            return  this.select(s.parentNode);
        }
        return  null;
    },

    /**
     * Selects the node above the selected node in the tree, intelligently walking the nodes
     * @return TreeNode The new selection
     */
    selectNext : function(){
        var  s = this.selNode || this.lastSelNode;
        if(!s){
            return  null;
        }
        if(s.firstChild && s.isExpanded()){
             return  this.select(s.firstChild);
         }else  if(s.nextSibling){
             return  this.select(s.nextSibling);
         }else  if(s.parentNode){
            var  newS = null;
            s.parentNode.bubble(function(){
                if(this.nextSibling){
                    newS = this.getOwnerTree().selModel.select(this.nextSibling);
                    return  false;
                }
            });
            return  newS;
         }
        return  null;
    },

    onKeyDown : function(e){
        var  s = this.selNode || this.lastSelNode;
        // undesirable, but required
        var  sm = this;
        if(!s){
            return;
        }
        var  k = e.getKey();
        switch(k){
             case  e.DOWN:
                 e.stopEvent();
                 this.selectNext();
             break;
             case  e.UP:
                 e.stopEvent();
                 this.selectPrevious();
             break;
             case  e.RIGHT:
                 e.preventDefault();
                 if(s.hasChildNodes()){
                     if(!s.isExpanded()){
                         s.expand();
                     }else  if(s.firstChild){
                         this.select(s.firstChild, e);
                     }
                 }
             break;
             case  e.LEFT:
                 e.preventDefault();
                 if(s.hasChildNodes() && s.isExpanded()){
                     s.collapse();
                 }else  if(s.parentNode && (this.tree.rootVisible || s.parentNode != this.tree.getRootNode())){
                     this.select(s.parentNode, e);
                 }
             break;
        };
    }
});

/**
 * @class Roo.tree.MultiSelectionModel
 * @extends Roo.util.Observable
 * Multi selection for a TreePanel.
 */
Roo.tree.MultiSelectionModel = function(){
   this.selNodes = [];
   this.selMap = {};
   this.addEvents({
       /**
        * @event selectionchange
        * Fires when the selected nodes change
        * @param {MultiSelectionModel} this
        * @param {Array} nodes Array of the selected nodes
        */
       "selectionchange" : true
   });
};

Roo.extend(Roo.tree.MultiSelectionModel, Roo.util.Observable, {
    init : function(G){
        this.tree = G;
        G.getTreeEl().on("keydown", this.onKeyDown, this);
        G.on("click", this.onNodeClick, this);
    },
    
    onNodeClick : function(H, e){
        this.select(H, e, e.ctrlKey);
    },
    
    /**
     * Select a node.
     * @param {TreeNode} node The node to select
     * @param {EventObject} e (optional) An event associated with the selection
     * @param {Boolean} keepExisting True to retain existing selections
     * @return {TreeNode} The selected node
     */
    select : function(I, e, J){
        if(J !== true){
            this.clearSelections(true);
        }
        if(this.isSelected(I)){
            this.lastSelNode = I;
            return  I;
        }

        this.selNodes.push(I);
        this.selMap[I.id] = I;
        this.lastSelNode = I;
        I.ui.onSelectedChange(true);
        this.fireEvent("selectionchange", this, this.selNodes);
        return  I;
    },
    
    /**
     * Deselect a node.
     * @param {TreeNode} node The node to unselect
     */
    unselect : function(K){
        if(this.selMap[K.id]){
            K.ui.onSelectedChange(false);
            var  sn = this.selNodes;
            var  index = -1;
            if(sn.indexOf){
                index = sn.indexOf(K);
            }else {
                for(var  i = 0, len = sn.length; i < len; i++){
                    if(sn[i] == K){
                        index = i;
                        break;
                    }
                }
            }
            if(index != -1){
                this.selNodes.splice(index, 1);
            }
            delete  this.selMap[K.id];
            this.fireEvent("selectionchange", this, this.selNodes);
        }
    },
    
    /**
     * Clear all selections
     */
    clearSelections : function(L){
        var  sn = this.selNodes;
        if(sn.length > 0){
            for(var  i = 0, len = sn.length; i < len; i++){
                sn[i].ui.onSelectedChange(false);
            }

            this.selNodes = [];
            this.selMap = {};
            if(L !== true){
                this.fireEvent("selectionchange", this, this.selNodes);
            }
        }
    },
    
    /**
     * Returns true if the node is selected
     * @param {TreeNode} node The node to check
     * @return {Boolean}
     */
    isSelected : function(M){
        return  this.selMap[M.id] ? true : false;  
    },
    
    /**
     * Returns an array of the selected nodes
     * @return {Array}
     */
    getSelectedNodes : function(){
        return  this.selNodes;    
    },

    onKeyDown : Roo.tree.DefaultSelectionModel.prototype.onKeyDown,

    selectNext : Roo.tree.DefaultSelectionModel.prototype.selectNext,

    selectPrevious : Roo.tree.DefaultSelectionModel.prototype.selectPrevious
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.tree.TreeNode
 * @extends Roo.data.Node
 * @cfg {String} text The text for this node
 * @cfg {Boolean} expanded true to start the node expanded
 * @cfg {Boolean} allowDrag false to make this node undraggable if DD is on (defaults to true)
 * @cfg {Boolean} allowDrop false if this node cannot be drop on
 * @cfg {Boolean} disabled true to start the node disabled
 * @cfg {String} icon The path to an icon for the node. The preferred way to do this
 * is to use the cls or iconCls attributes and add the icon via a CSS background image.
 * @cfg {String} cls A css class to be added to the node
 * @cfg {String} iconCls A css class to be added to the nodes icon element for applying css background images
 * @cfg {String} href URL of the link used for the node (defaults to #)
 * @cfg {String} hrefTarget target frame for the link
 * @cfg {String} qtip An Ext QuickTip for the node
 * @cfg {String} qtipCfg An Ext QuickTip config for the node (used instead of qtip)
 * @cfg {Boolean} singleClickExpand True for single click expand on this node
 * @cfg {Function} uiProvider A UI <b>class</b> to use for this node (defaults to Roo.tree.TreeNodeUI)
 * @cfg {Boolean} checked True to render a checked checkbox for this node, false to render an unchecked checkbox
 * (defaults to undefined with no checkbox rendered)
 * @constructor
 * @param {Object/String} attributes The attributes/config for the node or just a string with the text for the node
 */
Roo.tree.TreeNode = function(A){
    A = A || {};
    if(typeof  A == "string"){
        A = {text: A};
    }

    this.childrenRendered = false;
    this.rendered = false;
    Roo.tree.TreeNode.superclass.constructor.call(this, A);
    this.expanded = A.expanded === true;
    this.isTarget = A.isTarget !== false;
    this.draggable = A.draggable !== false && A.allowDrag !== false;
    this.allowChildren = A.allowChildren !== false && A.allowDrop !== false;

    /**
     * Read-only. The text for this node. To change it use setText().
     * @type String
     */
    this.text = A.text;
    /**
     * True if this node is disabled.
     * @type Boolean
     */
    this.disabled = A.disabled === true;

    this.addEvents({
        /**
        * @event textchange
        * Fires when the text for this node is changed
        * @param {Node} this This node
        * @param {String} text The new text
        * @param {String} oldText The old text
        */
        "textchange" : true,
        /**
        * @event beforeexpand
        * Fires before this node is expanded, return false to cancel.
        * @param {Node} this This node
        * @param {Boolean} deep
        * @param {Boolean} anim
        */
        "beforeexpand" : true,
        /**
        * @event beforecollapse
        * Fires before this node is collapsed, return false to cancel.
        * @param {Node} this This node
        * @param {Boolean} deep
        * @param {Boolean} anim
        */
        "beforecollapse" : true,
        /**
        * @event expand
        * Fires when this node is expanded
        * @param {Node} this This node
        */
        "expand" : true,
        /**
        * @event disabledchange
        * Fires when the disabled status of this node changes
        * @param {Node} this This node
        * @param {Boolean} disabled
        */
        "disabledchange" : true,
        /**
        * @event collapse
        * Fires when this node is collapsed
        * @param {Node} this This node
        */
        "collapse" : true,
        /**
        * @event beforeclick
        * Fires before click processing. Return false to cancel the default action.
        * @param {Node} this This node
        * @param {Roo.EventObject} e The event object
        */
        "beforeclick":true,
        /**
        * @event checkchange
        * Fires when a node with a checkbox's checked property changes
        * @param {Node} this This node
        * @param {Boolean} checked
        */
        "checkchange":true,
        /**
        * @event click
        * Fires when this node is clicked
        * @param {Node} this This node
        * @param {Roo.EventObject} e The event object
        */
        "click":true,
        /**
        * @event dblclick
        * Fires when this node is double clicked
        * @param {Node} this This node
        * @param {Roo.EventObject} e The event object
        */
        "dblclick":true,
        /**
        * @event contextmenu
        * Fires when this node is right clicked
        * @param {Node} this This node
        * @param {Roo.EventObject} e The event object
        */
        "contextmenu":true,
        /**
        * @event beforechildrenrendered
        * Fires right before the child nodes for this node are rendered
        * @param {Node} this This node
        */
        "beforechildrenrendered":true
    });

    var  B = this.attributes.uiProvider || Roo.tree.TreeNodeUI;

    /**
     * Read-only. The UI for this node
     * @type TreeNodeUI
     */
    this.ui = new  B(this);
};
Roo.extend(Roo.tree.TreeNode, Roo.data.Node, {
    preventHScroll: true,
    /**
     * Returns true if this node is expanded
     * @return {Boolean}
     */
    isExpanded : function(){
        return  this.expanded;
    },

    /**
     * Returns the UI object for this node
     * @return {TreeNodeUI}
     */
    getUI : function(){
        return  this.ui;
    },

    // private override
    setFirstChild : function(C){
        var  of = this.firstChild;
        Roo.tree.TreeNode.superclass.setFirstChild.call(this, C);
        if(this.childrenRendered && of && C != of){
            of.renderIndent(true, true);
        }
        if(this.rendered){
            this.renderIndent(true, true);
        }
    },

    // private override
    setLastChild : function(D){
        var  ol = this.lastChild;
        Roo.tree.TreeNode.superclass.setLastChild.call(this, D);
        if(this.childrenRendered && ol && D != ol){
            ol.renderIndent(true, true);
        }
        if(this.rendered){
            this.renderIndent(true, true);
        }
    },

    // these methods are overridden to provide lazy rendering support
    // private override
    appendChild : function(){
        var  E = Roo.tree.TreeNode.superclass.appendChild.apply(this, arguments);
        if(E && this.childrenRendered){
            E.render();
        }

        this.ui.updateExpandIcon();
        return  E;
    },

    // private override
    removeChild : function(F){
        this.ownerTree.getSelectionModel().unselect(F);
        Roo.tree.TreeNode.superclass.removeChild.apply(this, arguments);
        // if it's been rendered remove dom node
        if(this.childrenRendered){
            F.ui.remove();
        }
        if(this.childNodes.length < 1){
            this.collapse(false, false);
        }else {
            this.ui.updateExpandIcon();
        }
        if(!this.firstChild) {
            this.childrenRendered = false;
        }
        return  F;
    },

    // private override
    insertBefore : function(G, H){
        var  I = Roo.tree.TreeNode.superclass.insertBefore.apply(this, arguments);
        if(I && H && this.childrenRendered){
            G.render();
        }

        this.ui.updateExpandIcon();
        return  I;
    },

    /**
     * Sets the text for this node
     * @param {String} text
     */
    setText : function(J){
        var  K = this.text;
        this.text = J;
        this.attributes.text = J;
        if(this.rendered){ // event without subscribing
            this.ui.onTextChange(this, J, K);
        }

        this.fireEvent("textchange", this, J, K);
    },

    /**
     * Triggers selection of this node
     */
    select : function(){
        this.getOwnerTree().getSelectionModel().select(this);
    },

    /**
     * Triggers deselection of this node
     */
    unselect : function(){
        this.getOwnerTree().getSelectionModel().unselect(this);
    },

    /**
     * Returns true if this node is selected
     * @return {Boolean}
     */
    isSelected : function(){
        return  this.getOwnerTree().getSelectionModel().isSelected(this);
    },

    /**
     * Expand this node.
     * @param {Boolean} deep (optional) True to expand all children as well
     * @param {Boolean} anim (optional) false to cancel the default animation
     * @param {Function} callback (optional) A callback to be called when
     * expanding this node completes (does not wait for deep expand to complete).
     * Called with 1 parameter, this node.
     */
    expand : function(L, M, N){
        if(!this.expanded){
            if(this.fireEvent("beforeexpand", this, L, M) === false){
                return;
            }
            if(!this.childrenRendered){
                this.renderChildren();
            }

            this.expanded = true;
            if(!this.isHiddenRoot() && (this.getOwnerTree().animate && M !== false) || M){
                this.ui.animExpand(function(){
                    this.fireEvent("expand", this);
                    if(typeof  N == "function"){
                        N(this);
                    }
                    if(L === true){
                        this.expandChildNodes(true);
                    }
                }.createDelegate(this));
                return;
            }else {
                this.ui.expand();
                this.fireEvent("expand", this);
                if(typeof  N == "function"){
                    N(this);
                }
            }
        }else {
           if(typeof  N == "function"){
               N(this);
           }
        }
        if(L === true){
            this.expandChildNodes(true);
        }
    },

    isHiddenRoot : function(){
        return  this.isRoot && !this.getOwnerTree().rootVisible;
    },

    /**
     * Collapse this node.
     * @param {Boolean} deep (optional) True to collapse all children as well
     * @param {Boolean} anim (optional) false to cancel the default animation
     */
    collapse : function(O, P){
        if(this.expanded && !this.isHiddenRoot()){
            if(this.fireEvent("beforecollapse", this, O, P) === false){
                return;
            }

            this.expanded = false;
            if((this.getOwnerTree().animate && P !== false) || P){
                this.ui.animCollapse(function(){
                    this.fireEvent("collapse", this);
                    if(O === true){
                        this.collapseChildNodes(true);
                    }
                }.createDelegate(this));
                return;
            }else {
                this.ui.collapse();
                this.fireEvent("collapse", this);
            }
        }
        if(O === true){
            var  cs = this.childNodes;
            for(var  i = 0, len = cs.length; i < len; i++) {
            	cs[i].collapse(true, false);
            }
        }
    },

    // private
    delayedExpand : function(Q){
        if(!this.expandProcId){
            this.expandProcId = this.expand.defer(Q, this);
        }
    },

    // private
    cancelExpand : function(){
        if(this.expandProcId){
            clearTimeout(this.expandProcId);
        }

        this.expandProcId = false;
    },

    /**
     * Toggles expanded/collapsed state of the node
     */
    toggle : function(){
        if(this.expanded){
            this.collapse();
        }else {
            this.expand();
        }
    },

    /**
     * Ensures all parent nodes are expanded
     */
    ensureVisible : function(R){
        var  S = this.getOwnerTree();
        S.expandPath(this.parentNode.getPath(), false, function(){
            S.getTreeEl().scrollChildIntoView(this.ui.anchor);
            Roo.callback(R);
        }.createDelegate(this));
    },

    /**
     * Expand all child nodes
     * @param {Boolean} deep (optional) true if the child nodes should also expand their child nodes
     */
    expandChildNodes : function(T){
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++) {
        	cs[i].expand(T);
        }
    },

    /**
     * Collapse all child nodes
     * @param {Boolean} deep (optional) true if the child nodes should also collapse their child nodes
     */
    collapseChildNodes : function(U){
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++) {
        	cs[i].collapse(U);
        }
    },

    /**
     * Disables this node
     */
    disable : function(){
        this.disabled = true;
        this.unselect();
        if(this.rendered && this.ui.onDisableChange){ // event without subscribing
            this.ui.onDisableChange(this, true);
        }

        this.fireEvent("disabledchange", this, true);
    },

    /**
     * Enables this node
     */
    enable : function(){
        this.disabled = false;
        if(this.rendered && this.ui.onDisableChange){ // event without subscribing
            this.ui.onDisableChange(this, false);
        }

        this.fireEvent("disabledchange", this, false);
    },

    // private
    renderChildren : function(V){
        if(V !== false){
            this.fireEvent("beforechildrenrendered", this);
        }
        var  cs = this.childNodes;
        for(var  i = 0, len = cs.length; i < len; i++){
            cs[i].render(true);
        }

        this.childrenRendered = true;
    },

    // private
    sort : function(fn, W){
        Roo.tree.TreeNode.superclass.sort.apply(this, arguments);
        if(this.childrenRendered){
            var  cs = this.childNodes;
            for(var  i = 0, len = cs.length; i < len; i++){
                cs[i].render(true);
            }
        }
    },

    // private
    render : function(X){
        this.ui.render(X);
        if(!this.rendered){
            this.rendered = true;
            if(this.expanded){
                this.expanded = false;
                this.expand(false, false);
            }
        }
    },

    // private
    renderIndent : function(Y, Z){
        if(Z){
            this.ui.childIndent = null;
        }

        this.ui.renderIndent();
        if(Y === true && this.childrenRendered){
            var  cs = this.childNodes;
            for(var  i = 0, len = cs.length; i < len; i++){
                cs[i].renderIndent(true, Z);
            }
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.tree.AsyncTreeNode
 * @extends Roo.tree.TreeNode
 * @cfg {TreeLoader} loader A TreeLoader to be used by this node (defaults to the loader defined on the tree)
 * @constructor
 * @param {Object/String} attributes The attributes/config for the node or just a string with the text for the node 
 */
 Roo.tree.AsyncTreeNode = function(A){
    this.loaded = false;
    this.loading = false;
    Roo.tree.AsyncTreeNode.superclass.constructor.apply(this, arguments);
    /**
    * @event beforeload
    * Fires before this node is loaded, return false to cancel
    * @param {Node} this This node
    */
    this.addEvents({'beforeload':true, 'load': true});
    /**
    * @event load
    * Fires when this node is loaded
    * @param {Node} this This node
    */
    /**
     * The loader used by this node (defaults to using the tree's defined loader)
     * @type TreeLoader
     * @property loader
     */
};
Roo.extend(Roo.tree.AsyncTreeNode, Roo.tree.TreeNode, {
    expand : function(B, C, D){
        if(this.loading){ // if an async load is already running, waiting til it's done
            var  timer;
            var  f = function(){
                if(!this.loading){ // done loading
                    clearInterval(timer);
                    this.expand(B, C, D);
                }
            }.createDelegate(this);
            timer = setInterval(f, 200);
            return;
        }
        if(!this.loaded){
            if(this.fireEvent("beforeload", this) === false){
                return;
            }

            this.loading = true;
            this.ui.beforeLoad(this);
            var  loader = this.loader || this.attributes.loader || this.getOwnerTree().getLoader();
            if(loader){
                loader.load(this, this.loadComplete.createDelegate(this, [B, C, D]));
                return;
            }
        }

        Roo.tree.AsyncTreeNode.superclass.expand.call(this, B, C, D);
    },
    
    /**
     * Returns true if this node is currently loading
     * @return {Boolean}
     */
    isLoading : function(){
        return  this.loading;  
    },
    
    loadComplete : function(E, F, G){
        this.loading = false;
        this.loaded = true;
        this.ui.afterLoad(this);
        this.fireEvent("load", this);
        this.expand(E, F, G);
    },
    
    /**
     * Returns true if this node has been loaded
     * @return {Boolean}
     */
    isLoaded : function(){
        return  this.loaded;
    },
    
    hasChildNodes : function(){
        if(!this.isLeaf() && !this.loaded){
            return  true;
        }else {
            return  Roo.tree.AsyncTreeNode.superclass.hasChildNodes.call(this);
        }
    },

    /**
     * Trigger a reload for this node
     * @param {Function} callback
     */
    reload : function(H){
        this.collapse(false, false);
        while(this.firstChild){
            this.removeChild(this.firstChild);
        }

        this.childrenRendered = false;
        this.loaded = false;
        if(this.isHiddenRoot()){
            this.expanded = false;
        }

        this.expand(false, false, H);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.tree.TreeNodeUI
 * @constructor
 * @param {Object} node The node to render
 * The TreeNode UI implementation is separate from the
 * tree implementation. Unless you are customizing the tree UI,
 * you should never have to use this directly.
 */
Roo.tree.TreeNodeUI = function(A){
    this.node = A;
    this.rendered = false;
    this.animating = false;
    this.emptyIcon = Roo.BLANK_IMAGE_URL;
};

Roo.tree.TreeNodeUI.prototype = {
    removeChild : function(B){
        if(this.rendered){
            this.ctNode.removeChild(B.ui.getEl());
        }
    },

    beforeLoad : function(){
         this.addClass("x-tree-node-loading");
    },

    afterLoad : function(){
         this.removeClass("x-tree-node-loading");
    },

    onTextChange : function(C, D, E){
        if(this.rendered){
            this.textNode.innerHTML = D;
        }
    },

    onDisableChange : function(F, G){
        this.disabled = G;
        if(G){
            this.addClass("x-tree-node-disabled");
        }else {
            this.removeClass("x-tree-node-disabled");
        }
    },

    onSelectedChange : function(H){
        if(H){
            this.focus();
            this.addClass("x-tree-selected");
        }else {
            //this.blur();
            this.removeClass("x-tree-selected");
        }
    },

    onMove : function(I, J, K, L, M, N){
        this.childIndent = null;
        if(this.rendered){
            var  targetNode = L.ui.getContainer();
            if(!targetNode){//target not rendered
                this.holder = document.createElement("div");
                this.holder.appendChild(this.wrap);
                return;
            }
            var  insertBefore = N ? N.ui.getEl() : null;
            if(insertBefore){
                targetNode.insertBefore(this.wrap, insertBefore);
            }else {
                targetNode.appendChild(this.wrap);
            }

            this.node.renderIndent(true);
        }
    },

    addClass : function(O){
        if(this.elNode){
            Roo.fly(this.elNode).addClass(O);
        }
    },

    removeClass : function(P){
        if(this.elNode){
            Roo.fly(this.elNode).removeClass(P);
        }
    },

    remove : function(){
        if(this.rendered){
            this.holder = document.createElement("div");
            this.holder.appendChild(this.wrap);
        }
    },

    fireEvent : function(){
        return  this.node.fireEvent.apply(this.node, arguments);
    },

    initEvents : function(){
        this.node.on("move", this.onMove, this);
        var  E = Roo.EventManager;
        var  a = this.anchor;

        var  el = Roo.fly(a, '_treeui');

        if(Roo.isOpera){ // opera render bug ignores the CSS
            el.setStyle("text-decoration", "none");
        }


        el.on("click", this.onClick, this);
        el.on("dblclick", this.onDblClick, this);

        if(this.checkbox){
            Roo.EventManager.on(this.checkbox,
                    Roo.isIE ? 'click' : 'change', this.onCheckChange, this);
        }


        el.on("contextmenu", this.onContextMenu, this);

        var  Q = Roo.fly(this.iconNode);
        Q.on("click", this.onClick, this);
        Q.on("dblclick", this.onDblClick, this);
        Q.on("contextmenu", this.onContextMenu, this);
        E.on(this.ecNode, "click", this.ecClick, this, true);

        if(this.node.disabled){
            this.addClass("x-tree-node-disabled");
        }
        if(this.node.hidden){
            this.addClass("x-tree-node-disabled");
        }
        var  ot = this.node.getOwnerTree();
        var  dd = ot.enableDD || ot.enableDrag || ot.enableDrop;
        if(dd && (!this.node.isRoot || ot.rootVisible)){
            Roo.dd.Registry.register(this.elNode, {
                node: this.node,
                handles: this.getDDHandles(),
                isHandle: false
            });
        }
    },

    getDDHandles : function(){
        return  [this.iconNode, this.textNode];
    },

    hide : function(){
        if(this.rendered){
            this.wrap.style.display = "none";
        }
    },

    show : function(){
        if(this.rendered){
            this.wrap.style.display = "";
        }
    },

    onContextMenu : function(e){
        if (this.node.hasListener("contextmenu") || this.node.getOwnerTree().hasListener("contextmenu")) {
            e.preventDefault();
            this.focus();
            this.fireEvent("contextmenu", this.node, e);
        }
    },

    onClick : function(e){
        if(this.dropping){
            e.stopEvent();
            return;
        }
        if(this.fireEvent("beforeclick", this.node, e) !== false){
            if(!this.disabled && this.node.attributes.href){
                this.fireEvent("click", this.node, e);
                return;
            }

            e.preventDefault();
            if(this.disabled){
                return;
            }

            if(this.node.attributes.singleClickExpand && !this.animating && this.node.hasChildNodes()){
                this.node.toggle();
            }


            this.fireEvent("click", this.node, e);
        }else {
            e.stopEvent();
        }
    },

    onDblClick : function(e){
        e.preventDefault();
        if(this.disabled){
            return;
        }
        if(this.checkbox){
            this.toggleCheck();
        }
        if(!this.animating && this.node.hasChildNodes()){
            this.node.toggle();
        }

        this.fireEvent("dblclick", this.node, e);
    },

    onCheckChange : function(){
        var  R = this.checkbox.checked;
        this.node.attributes.checked = R;
        this.fireEvent('checkchange', this.node, R);
    },

    ecClick : function(e){
        if(!this.animating && this.node.hasChildNodes()){
            this.node.toggle();
        }
    },

    startDrop : function(){
        this.dropping = true;
    },

    // delayed drop so the click event doesn't get fired on a drop
    endDrop : function(){
       setTimeout(function(){
           this.dropping = false;
       }.createDelegate(this), 50);
    },

    expand : function(){
        this.updateExpandIcon();
        this.ctNode.style.display = "";
    },

    focus : function(){
        if(!this.node.preventHScroll){
            try{this.anchor.focus();
            }catch(e){}
        }else  if(!Roo.isIE){
            try{
                var  noscroll = this.node.getOwnerTree().getTreeEl().dom;
                var  l = noscroll.scrollLeft;
                this.anchor.focus();
                noscroll.scrollLeft = l;
            }catch(e){}
        }
    },

    toggleCheck : function(S){
        var  cb = this.checkbox;
        if(cb){
            cb.checked = (S === undefined ? !cb.checked : S);
        }
    },

    blur : function(){
        try{
            this.anchor.blur();
        }catch(e){}
    },

    animExpand : function(T){
        var  ct = Roo.get(this.ctNode);
        ct.stopFx();
        if(!this.node.hasChildNodes()){
            this.updateExpandIcon();
            this.ctNode.style.display = "";
            Roo.callback(T);
            return;
        }

        this.animating = true;
        this.updateExpandIcon();

        ct.slideIn('t', {
           callback : function(){
               this.animating = false;
               Roo.callback(T);
            },
            scope: this,
            duration: this.node.ownerTree.duration || .25
        });
    },

    highlight : function(){
        var  U = this.node.getOwnerTree();
        Roo.fly(this.wrap).highlight(
            U.hlColor || "C3DAF9",
            {endColor: U.hlBaseColor}
        );
    },

    collapse : function(){
        this.updateExpandIcon();
        this.ctNode.style.display = "none";
    },

    animCollapse : function(V){
        var  ct = Roo.get(this.ctNode);
        ct.enableDisplayMode('block');
        ct.stopFx();

        this.animating = true;
        this.updateExpandIcon();

        ct.slideOut('t', {
            callback : function(){
               this.animating = false;
               Roo.callback(V);
            },
            scope: this,
            duration: this.node.ownerTree.duration || .25
        });
    },

    getContainer : function(){
        return  this.ctNode;
    },

    getEl : function(){
        return  this.wrap;
    },

    appendDDGhost : function(W){
        W.appendChild(this.elNode.cloneNode(true));
    },

    getDDRepairXY : function(){
        return  Roo.lib.Dom.getXY(this.iconNode);
    },

    onRender : function(){
        this.render();
    },

    render : function(X){
        var  n = this.node, a = n.attributes;
        var  Y = n.parentNode ?
              n.parentNode.ui.getContainer() : n.ownerTree.innerCt.dom;

        if(!this.rendered){
            this.rendered = true;

            this.renderElements(n, a, Y, X);

            if(a.qtip){
               if(this.textNode.setAttributeNS){
                   this.textNode.setAttributeNS("ext", "qtip", a.qtip);
                   if(a.qtipTitle){
                       this.textNode.setAttributeNS("ext", "qtitle", a.qtipTitle);
                   }
               }else {
                   this.textNode.setAttribute("ext:qtip", a.qtip);
                   if(a.qtipTitle){
                       this.textNode.setAttribute("ext:qtitle", a.qtipTitle);
                   }
               }
            }else  if(a.qtipCfg){
                a.qtipCfg.target = Roo.id(this.textNode);
                Roo.QuickTips.register(a.qtipCfg);
            }

            this.initEvents();
            if(!this.node.expanded){
                this.updateExpandIcon();
            }
        }else {
            if(X === true) {
                Y.appendChild(this.wrap);
            }
        }
    },

    renderElements : function(n, a, Z, b){
        // add some indent caching, this helps performance when rendering a large tree
        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';
        var  t = n.getOwnerTree();
        var  c = t.renderer ? t.renderer(n.attributes) : Roo.util.Format.htmlEncode(n.text);
        var  d = t.rendererTip ? t.rendererTip(n.attributes) : c;
        var  cb = typeof  a.checked == 'boolean';
        var  f = a.href ? a.href : Roo.isGecko ? "" : "#";
        var  g = ['<li class="x-tree-node"><div class="x-tree-node-el ', a.cls,'">',
            '<span class="x-tree-node-indent">',this.indentMarkup,"</span>",
            '<img src="', this.emptyIcon, '" class="x-tree-ec-icon" />',
            '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon',(a.icon ? " x-tree-node-inline-icon" : ""),(a.iconCls ? " "+a.iconCls : ""),'" unselectable="on" />',
            cb ? ('<input class="x-tree-node-cb" type="checkbox" ' + (a.checked ? 'checked="checked" />' : ' />')) : '',
            '<a hidefocus="on" href="',f,'" tabIndex="1" ',
             a.hrefTarget ? ' target="'+a.hrefTarget+'"' : "", 
                '><span unselectable="on" qtip="' , d ,'">',c,"</span></a></div>",
            '<ul class="x-tree-node-ct" style="display:none;"></ul>',
            "</li>"];

        if(b !== true && n.nextSibling && n.nextSibling.ui.getEl()){
            this.wrap = Roo.DomHelper.insertHtml("beforeBegin",
                                n.nextSibling.ui.getEl(), g.join(""));
        }else {
            this.wrap = Roo.DomHelper.insertHtml("beforeEnd", Z, g.join(""));
        }


        this.elNode = this.wrap.childNodes[0];
        this.ctNode = this.wrap.childNodes[1];
        var  cs = this.elNode.childNodes;
        this.indentNode = cs[0];
        this.ecNode = cs[1];
        this.iconNode = cs[2];
        var  h = 3;
        if(cb){
            this.checkbox = cs[3];
            h++;
        }

        this.anchor = cs[h];
        this.textNode = cs[h].firstChild;
    },

    getAnchor : function(){
        return  this.anchor;
    },

    getTextEl : function(){
        return  this.textNode;
    },

    getIconEl : function(){
        return  this.iconNode;
    },

    isChecked : function(){
        return  this.checkbox ? this.checkbox.checked : false;
    },

    updateExpandIcon : function(){
        if(this.rendered){
            var  n = this.node, c1, c2;
            var  P = n.isLast() ? "x-tree-elbow-end" : "x-tree-elbow";
            var  hasChild = n.hasChildNodes();
            if(hasChild){
                if(n.expanded){
                    P += "-minus";
                    c1 = "x-tree-node-collapsed";
                    c2 = "x-tree-node-expanded";
                }else {
                    P += "-plus";
                    c1 = "x-tree-node-expanded";
                    c2 = "x-tree-node-collapsed";
                }
                if(this.wasLeaf){
                    this.removeClass("x-tree-node-leaf");
                    this.wasLeaf = false;
                }
                if(this.c1 != c1 || this.c2 != c2){
                    Roo.fly(this.elNode).replaceClass(c1, c2);
                    this.c1 = c1; this.c2 = c2;
                }
            }else {
                if(!this.wasLeaf){
                    Roo.fly(this.elNode).replaceClass("x-tree-node-expanded", "x-tree-node-leaf");
                    delete  this.c1;
                    delete  this.c2;
                    this.wasLeaf = true;
                }
            }
            var  ecc = "x-tree-ec-icon "+P;
            if(this.ecc != ecc){
                this.ecNode.className = ecc;
                this.ecc = ecc;
            }
        }
    },

    getChildIndent : function(){
        if(!this.childIndent){
            var  g = [];
            var  p = this.node;
            while(p){
                if(!p.isRoot || (p.isRoot && p.ownerTree.rootVisible)){
                    if(!p.isLast()) {
                        g.unshift('<img src="'+this.emptyIcon+'" class="x-tree-elbow-line" />');
                    } else  {
                        g.unshift('<img src="'+this.emptyIcon+'" class="x-tree-icon" />');
                    }
                }

                p = p.parentNode;
            }

            this.childIndent = g.join("");
        }
        return  this.childIndent;
    },

    renderIndent : function(){
        if(this.rendered){
            var  indent = "";
            var  p = this.node.parentNode;
            if(p){
                indent = p.ui.getChildIndent();
            }
            if(this.indentMarkup != indent){ // don't rerender if not required
                this.indentNode.innerHTML = indent;
                this.indentMarkup = indent;
            }

            this.updateExpandIcon();
        }
    }
};

Roo.tree.RootTreeNodeUI = function(){
    Roo.tree.RootTreeNodeUI.superclass.constructor.apply(this, arguments);
};
Roo.extend(Roo.tree.RootTreeNodeUI, Roo.tree.TreeNodeUI, {
    render : function(){
        if(!this.rendered){
            var  Z = this.node.ownerTree.innerCt.dom;
            this.node.expanded = true;
            Z.innerHTML = '<div class="x-tree-root-node"></div>';
            this.wrap = this.ctNode = Z.firstChild;
        }
    },
    collapse : function(){
    },
    expand : function(){
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.tree.TreeLoader
 * @extends Roo.util.Observable
 * A TreeLoader provides for lazy loading of an {@link Roo.tree.TreeNode}'s child
 * nodes from a specified URL. The response must be a javascript Array definition
 * who's elements are node definition objects. eg:
 * <pre><code>
   [{ 'id': 1, 'text': 'A folder Node', 'leaf': false },
    { 'id': 2, 'text': 'A leaf Node', 'leaf': true }]
</code></pre>
 * <br><br>
 * A server request is sent, and child nodes are loaded only when a node is expanded.
 * The loading node's id is passed to the server under the parameter name "node" to
 * enable the server to produce the correct child nodes.
 * <br><br>
 * To pass extra parameters, an event handler may be attached to the "beforeload"
 * event, and the parameters specified in the TreeLoader's baseParams property:
 * <pre><code>
    myTreeLoader.on("beforeload", function(treeLoader, node) {
        this.baseParams.category = node.attributes.category;
    }, this);
</code></pre><
 * This would pass an HTTP parameter called "category" to the server containing
 * the value of the Node's "category" attribute.
 * @constructor
 * Creates a new Treeloader.
 * @param {Object} config A config object containing config properties.
 */
Roo.tree.TreeLoader = function(A){
    this.baseParams = {};
    this.requestMethod = "POST";
    Roo.apply(this, A);

    this.addEvents({
        /**
         * @event beforeload
         * Fires before a network request is made to retrieve the Json text which specifies a node's children.
         * @param {Object} This TreeLoader object.
         * @param {Object} node The {@link Roo.tree.TreeNode} object being loaded.
         * @param {Object} callback The callback function specified in the {@link #load} call.
         */
        "beforeload" : true,
        /**
         * @event load
         * Fires when the node has been successfuly loaded.
         * @param {Object} This TreeLoader object.
         * @param {Object} node The {@link Roo.tree.TreeNode} object being loaded.
         * @param {Object} response The response object containing the data from the server.
         */
        "load" : true,
        /**
         * @event loadexception
         * Fires if the network request failed.
         * @param {Object} This TreeLoader object.
         * @param {Object} node The {@link Roo.tree.TreeNode} object being loaded.
         * @param {Object} response The response object containing the data from the server.
         */
        "loadexception" : true,
          /**
         * @event create
         * Fires before a node is created, enabling you to return custom Node types 
         * @param {Object} This TreeLoader object.
         * @param {Object} attr - the data returned from the AJAX call (modify it to suit)
         */
        "create" : true
    });

    Roo.tree.TreeLoader.superclass.constructor.call(this);
};

Roo.extend(Roo.tree.TreeLoader, Roo.util.Observable, {
    /**
    * @cfg {String} dataUrl The URL from which to request a Json string which
    * specifies an array of node definition object representing the child nodes
    * to be loaded.
    */
    /**
    * @cfg {Object} baseParams (optional) An object containing properties which
    * specify HTTP parameters to be passed to each request for child nodes.
    */
    /**
    * @cfg {Object} baseAttrs (optional) An object containing attributes to be added to all nodes
    * created by this loader. If the attributes sent by the server have an attribute in this object,
    * they take priority.
    */
    /**
    * @cfg {Object} uiProviders (optional) An object containing properties which
    * 
    * DEPRECIATED - use 'create' event handler to modify attributes - which affect creation.
    * specify custom {@link Roo.tree.TreeNodeUI} implementations. If the optional
    * <i>uiProvider</i> attribute of a returned child node is a string rather
    * than a reference to a TreeNodeUI implementation, this that string value
    * is used as a property name in the uiProviders object. You can define the provider named
    * 'default' , and this will be used for all nodes (if no uiProvider is delivered by the node data)
    */
    uiProviders : {},

    /**
    * @cfg {Boolean} clearOnLoad (optional) Default to true. Remove previously existing
    * child nodes before loading.
    */
    clearOnLoad : true,

    /**
    * @cfg {String} root (optional) Default to false. Use this to read data from an object 
    * property on loading, rather than expecting an array. (eg. more compatible to a standard
    * Grid query { data : [ .....] }
    */
    
    root : false,
     /**
    * @cfg {String} queryParam (optional) 
    * Name of the query as it will be passed on the querystring (defaults to 'node')
    * eg. the request will be ?node=[id]
    */
    
    
    queryParam: false,
    
    /**
     * Load an {@link Roo.tree.TreeNode} from the URL specified in the constructor.
     * This is called automatically when a node is expanded, but may be used to reload
     * a node (or append new children if the {@link #clearOnLoad} option is false.)
     * @param {Roo.tree.TreeNode} node
     * @param {Function} callback
     */
    load : function(B, C){
        if(this.clearOnLoad){
            while(B.firstChild){
                B.removeChild(B.firstChild);
            }
        }
        if(B.attributes.children){ // preloaded json children
            var  cs = B.attributes.children;
            for(var  i = 0, len = cs.length; i < len; i++){
                B.appendChild(this.createNode(cs[i]));
            }
            if(typeof  C == "function"){
                C();
            }
        }else  if(this.dataUrl){
            this.requestData(B, C);
        }
    },

    getParams: function(D){
        var  E = [], bp = this.baseParams;
        for(var  key  in  bp){
            if(typeof  bp[key] != "function"){
                E.push(encodeURIComponent(key), "=", encodeURIComponent(bp[key]), "&");
            }
        }
        var  n = this.queryParam === false ? 'node' : this.queryParam;
        E.push(n + "=", encodeURIComponent(D.id));
        return  E.join("");
    },

    requestData : function(F, G){
        if(this.fireEvent("beforeload", this, F, G) !== false){
            this.transId = Roo.Ajax.request({
                method:this.requestMethod,
                url: this.dataUrl||this.url,
                success: this.handleResponse,
                failure: this.handleFailure,
                scope: this,
                argument: {callback: G, node: F},
                params: this.getParams(F)
            });
        }else {
            // if the load is cancelled, make sure we notify
            // the node that we are done
            if(typeof  G == "function"){
                G();
            }
        }
    },

    isLoading : function(){
        return  this.transId ? true : false;
    },

    abort : function(){
        if(this.isLoading()){
            Roo.Ajax.abort(this.transId);
        }
    },

    /**
    * Override this function for custom TreeNode node implementation
    */
    createNode : function(H){
        // apply baseAttrs, nice idea Corey!
        if(this.baseAttrs){
            Roo.applyIf(H, this.baseAttrs);
        }
        if(this.applyLoader !== false){
            H.loader = this;
        }
        // uiProvider = depreciated..
        
        if(typeof(H.uiProvider) == 'string'){
           H.uiProvider = this.uiProviders[H.uiProvider] || 
                /**  eval:var:attr */ eval(H.uiProvider);
        }
        if(typeof(this.uiProviders['default']) != 'undefined') {
            H.uiProvider = this.uiProviders['default'];
        }

        
        this.fireEvent('create', this, H);
        
        H.leaf  = typeof(H.leaf) == 'string' ? H.leaf * 1 : H.leaf;
        return (H.leaf ?
                        new  Roo.tree.TreeNode(H) :
                        new  Roo.tree.AsyncTreeNode(H));
    },

    processResponse : function(I, J, K){
        var  L = I.responseText;
        try {
            
            var  o = /**  eval:var:zzzzzzzzzz */ eval("("+L+")");
            if (this.root !== false) {
                o = o[this.root];
            }
            
            for(var  i = 0, len = o.length; i < len; i++){
                var  n = this.createNode(o[i]);
                if(n){
                    J.appendChild(n);
                }
            }
            if(typeof  K == "function"){
                K(this, J);
            }
        }catch(e){
            this.handleFailure(response);
        }
    },

    handleResponse : function(M){
        this.transId = false;
        var  a = M.argument;
        this.processResponse(M, a.node, a.callback);
        this.fireEvent("load", this, a.node, M);
    },

    handleFailure : function(N){
        this.transId = false;
        var  a = N.argument;
        this.fireEvent("loadexception", this, a.node, N);
        if(typeof  a.callback == "function"){
            a.callback(this, a.node);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
* @class Roo.tree.TreeFilter
* Note this class is experimental and doesn't update the indent (lines) or expand collapse icons of the nodes
* @param {TreePanel} tree
* @param {Object} config (optional)
 */
Roo.tree.TreeFilter = function(A, B){
    this.tree = A;
    this.filtered = {};
    Roo.apply(this, B);
};

Roo.tree.TreeFilter.prototype = {
    clearBlank:false,
    reverse:false,
    autoClear:false,
    remove:false,

     /**
     * Filter the data by a specific attribute.
     * @param {String/RegExp} value Either string that the attribute value
     * should start with or a RegExp to test against the attribute
     * @param {String} attr (optional) The attribute passed in your node's attributes collection. Defaults to "text".
     * @param {TreeNode} startNode (optional) The node to start the filter at.
     */
    filter : function(C, D, E){
        D = D || "text";
        var  f;
        if(typeof  C == "string"){
            var  vlen = C.length;
            // auto clear empty filter
            if(vlen == 0 && this.clearBlank){
                this.clear();
                return;
            }

            C = C.toLowerCase();
            f = function(n){
                return  n.attributes[D].substr(0, vlen).toLowerCase() == C;
            };
        }else  if(C.exec){ // regex?
            f = function(n){
                return  C.test(n.attributes[D]);
            };
        }else {
            throw  'Illegal filter type, must be string or regex';
        }

        this.filterBy(f, null, E);
	},

    /**
     * Filter by a function. The passed function will be called with each
     * node in the tree (or from the startNode). If the function returns true, the node is kept
     * otherwise it is filtered. If a node is filtered, its children are also filtered.
     * @param {Function} fn The filter function
     * @param {Object} scope (optional) The scope of the function (defaults to the current node)
     */
    filterBy : function(fn, F, G){
        G = G || this.tree.root;
        if(this.autoClear){
            this.clear();
        }
        var  af = this.filtered, rv = this.reverse;
        var  f = function(n){
            if(n == G){
                return  true;
            }
            if(af[n.id]){
                return  false;
            }
            var  m = fn.call(F || n, n);
            if(!m || rv){
                af[n.id] = n;
                n.ui.hide();
                return  false;
            }
            return  true;
        };
        G.cascade(f);
        if(this.remove){
           for(var  id  in  af){
               if(typeof  id != "function"){
                   var  n = af[id];
                   if(n && n.parentNode){
                       n.parentNode.removeChild(n);
                   }
               }
           }
        }
    },

    /**
     * Clears the current filter. Note: with the "remove" option
     * set a filter cannot be cleared.
     */
    clear : function(){
        var  t = this.tree;
        var  af = this.filtered;
        for(var  id  in  af){
            if(typeof  id != "function"){
                var  n = af[id];
                if(n){
                    n.ui.show();
                }
            }
        }

        this.filtered = {};
    }
};

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.tree.TreeSorter
 * Provides sorting of nodes in a TreePanel
 * 
 * @cfg {Boolean} folderSort True to sort leaf nodes under non leaf nodes
 * @cfg {String} property The named attribute on the node to sort by (defaults to text)
 * @cfg {String} dir The direction to sort (asc or desc) (defaults to asc)
 * @cfg {String} leafAttr The attribute used to determine leaf nodes in folder sort (defaults to "leaf")
 * @cfg {Boolean} caseSensitive true for case sensitive sort (defaults to false)
 * @cfg {Function} sortType A custom "casting" function used to convert node values before sorting
 * @constructor
 * @param {TreePanel} tree
 * @param {Object} config
 */
Roo.tree.TreeSorter = function(A, B){
    Roo.apply(this, B);
    A.on("beforechildrenrendered", this.doSort, this);
    A.on("append", this.updateSort, this);
    A.on("insert", this.updateSort, this);
    
    var  C = this.dir && this.dir.toLowerCase() == "desc";
    var  p = this.property || "text";
    var  D = this.sortType;
    var  fs = this.folderSort;
    var  cs = this.caseSensitive === true;
    var  E = this.leafAttr || 'leaf';

    this.sortFn = function(n1, n2){
        if(fs){
            if(n1.attributes[E] && !n2.attributes[E]){
                return  1;
            }
            if(!n1.attributes[E] && n2.attributes[E]){
                return  -1;
            }
        }
    	var  v1 = D ? D(n1) : (cs ? n1.attributes[p] : n1.attributes[p].toUpperCase());
    	var  v2 = D ? D(n2) : (cs ? n2.attributes[p] : n2.attributes[p].toUpperCase());
    	if(v1 < v2){
			return  C ? +1 : -1;
		}else  if(v1 > v2){
			return  C ? -1 : +1;
        }else {
	    	return  0;
        }
    };
};

Roo.tree.TreeSorter.prototype = {
    doSort : function(F){
        F.sort(this.sortFn);
    },
    
    compareNodes : function(n1, n2){
        return  (n1.text.toUpperCase() > n2.text.toUpperCase() ? 1 : -1);
    },
    
    updateSort : function(G, H){
        if(H.childrenRendered){
            this.doSort.defer(1, this, [H]);
        }
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

if(Roo.dd.DropZone){
    
Roo.tree.TreeDropZone = function(A, B){
    this.allowParentInsert = false;
    this.allowContainerDrop = false;
    this.appendOnly = false;
    Roo.tree.TreeDropZone.superclass.constructor.call(this, A.innerCt, B);
    this.tree = A;
    this.lastInsertClass = "x-tree-no-status";
    this.dragOverData = {};
};

Roo.extend(Roo.tree.TreeDropZone, Roo.dd.DropZone, {
    ddGroup : "TreeDD",
    
    expandDelay : 1000,
    
    expandNode : function(C){
        if(C.hasChildNodes() && !C.isExpanded()){
            C.expand(false, null, this.triggerCacheRefresh.createDelegate(this));
        }
    },
    
    queueExpand : function(D){
        this.expandProcId = this.expandNode.defer(this.expandDelay, this, [D]);
    },
    
    cancelExpand : function(){
        if(this.expandProcId){
            clearTimeout(this.expandProcId);
            this.expandProcId = false;
        }
    },
    
    isValidDropPoint : function(n, pt, dd, e, E){
        if(!n || !E){ return  false; }
        var  F = n.node;
        var  G = E.node;
        // default drop rules
        if(!(F && F.isTarget && pt)){
            return  false;
        }
        if(pt == "append" && F.allowChildren === false){
            return  false;
        }
        if((pt == "above" || pt == "below") && (F.parentNode && F.parentNode.allowChildren === false)){
            return  false;
        }
        if(G && (F == G || G.contains(F))){
            return  false;
        }
        // reuse the object
        var  H = this.dragOverData;
        H.tree = this.tree;
        H.target = F;
        H.data = E;
        H.point = pt;
        H.source = dd;
        H.rawEvent = e;
        H.dropNode = G;
        H.cancel = false;  
        var  I = this.tree.fireEvent("nodedragover", H);
        return  H.cancel === false && I !== false;
    },
    
    getDropPoint : function(e, n, dd){
        var  tn = n.node;
        if(tn.isRoot){
            return  tn.allowChildren !== false ? "append" : false; // always append for root
        }
        var  J = n.ddel;
        var  t = Roo.lib.Dom.getY(J), b = t + J.offsetHeight;
        var  y = Roo.lib.Event.getPageY(e);
        var  K = tn.allowChildren === false || tn.isLeaf();
        if(this.appendOnly || tn.parentNode.allowChildren === false){
            return  K ? false : "append";
        }
        var  L = false;
        if(!this.allowParentInsert){
            L = tn.hasChildNodes() && tn.isExpanded();
        }
        var  q = (b - t) / (K ? 2 : 3);
        if(y >= t && y < (t + q)){
            return  "above";
        }else  if(!L && (K || y >= b-q && y <= b)){
            return  "below";
        }else {
            return  "append";
        }
    },
    
    onNodeEnter : function(n, dd, e, M){
        this.cancelExpand();
    },
    
    onNodeOver : function(n, dd, e, N){
        var  pt = this.getDropPoint(e, n, dd);
        var  O = n.node;
        
        // auto node expand check
        if(!this.expandProcId && pt == "append" && O.hasChildNodes() && !n.node.isExpanded()){
            this.queueExpand(O);
        }else  if(pt != "append"){
            this.cancelExpand();
        }
        
        // set the insert point style on the target node
        var  P = this.dropNotAllowed;
        if(this.isValidDropPoint(n, pt, dd, e, N)){
           if(pt){
               var  el = n.ddel;
               var  cls;
               if(pt == "above"){
                   P = n.node.isFirst() ? "x-tree-drop-ok-above" : "x-tree-drop-ok-between";
                   cls = "x-tree-drag-insert-above";
               }else  if(pt == "below"){
                   P = n.node.isLast() ? "x-tree-drop-ok-below" : "x-tree-drop-ok-between";
                   cls = "x-tree-drag-insert-below";
               }else {
                   P = "x-tree-drop-ok-append";
                   cls = "x-tree-drag-append";
               }
               if(this.lastInsertClass != cls){
                   Roo.fly(el).replaceClass(this.lastInsertClass, cls);
                   this.lastInsertClass = cls;
               }
           }
       }
       return  P;
    },
    
    onNodeOut : function(n, dd, e, Q){
        this.cancelExpand();
        this.removeDropIndicators(n);
    },
    
    onNodeDrop : function(n, dd, e, R){
        var  S = this.getDropPoint(e, n, dd);
        var  T = n.node;
        T.ui.startDrop();
        if(!this.isValidDropPoint(n, S, dd, e, R)){
            T.ui.endDrop();
            return  false;
        }
        // first try to find the drop node
        var  U = R.node || (dd.getTreeNode ? dd.getTreeNode(R, T, S, e) : null);
        var  V = {
            tree : this.tree,
            target: T,
            data: R,
            point: S,
            source: dd,
            rawEvent: e,
            dropNode: U,
            cancel: !U   
        };
        var  W = this.tree.fireEvent("beforenodedrop", V);
        if(W === false || V.cancel === true || !V.dropNode){
            T.ui.endDrop();
            return  false;
        }

        // allow target changing
        T = V.target;
        if(S == "append" && !T.isExpanded()){
            T.expand(false, null, function(){
                this.completeDrop(V);
            }.createDelegate(this));
        }else {
            this.completeDrop(V);
        }
        return  true;
    },
    
    completeDrop : function(de){
        var  ns = de.dropNode, p = de.point, t = de.target;
        if(!(ns  instanceof  Array)){
            ns = [ns];
        }
        var  n;
        for(var  i = 0, len = ns.length; i < len; i++){
            n = ns[i];
            if(p == "above"){
                t.parentNode.insertBefore(n, t);
            }else  if(p == "below"){
                t.parentNode.insertBefore(n, t.nextSibling);
            }else {
                t.appendChild(n);
            }
        }

        n.ui.focus();
        if(this.tree.hlDrop){
            n.ui.highlight();
        }

        t.ui.endDrop();
        this.tree.fireEvent("nodedrop", de);
    },
    
    afterNodeMoved : function(dd, X, e, Y, Z){
        if(this.tree.hlDrop){
            Z.ui.focus();
            Z.ui.highlight();
        }

        this.tree.fireEvent("nodedrop", this.tree, Y, X, dd, e);
    },
    
    getTree : function(){
        return  this.tree;
    },
    
    removeDropIndicators : function(n){
        if(n && n.ddel){
            var  el = n.ddel;
            Roo.fly(el).removeClass([
                    "x-tree-drag-insert-above",
                    "x-tree-drag-insert-below",
                    "x-tree-drag-append"]);
            this.lastInsertClass = "_noclass";
        }
    },
    
    beforeDragDrop : function(a, e, id){
        this.cancelExpand();
        return  true;
    },
    
    afterRepair : function(c){
        if(c && Roo.enableFx){
            c.node.ui.highlight();
        }

        this.hideProxy();
    }    
});

}
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

if(Roo.dd.DragZone){
Roo.tree.TreeDragZone = function(A, B){
    Roo.tree.TreeDragZone.superclass.constructor.call(this, A.getTreeEl(), B);
    this.tree = A;
};

Roo.extend(Roo.tree.TreeDragZone, Roo.dd.DragZone, {
    ddGroup : "TreeDD",
    
    onBeforeDrag : function(C, e){
        var  n = C.node;
        return  n && n.draggable && !n.disabled;
    },
    
    onInitDrag : function(e){
        var  D = this.dragData;
        this.tree.getSelectionModel().select(D.node);
        this.proxy.update("");
        D.node.ui.appendDDGhost(this.proxy.ghost.dom);
        this.tree.fireEvent("startdrag", this.tree, D.node, e);
    },
    
    getRepairXY : function(e, E){
        return  E.node.ui.getDDRepairXY();
    },
    
    onEndDrag : function(F, e){
        this.tree.fireEvent("enddrag", this.tree, F.node, e);
    },
    
    onValidDrop : function(dd, e, id){
        this.tree.fireEvent("dragdrop", this.tree, this.dragData.node, dd, e);
        this.hideProxy();
    },
    
    beforeInvalidDrop : function(e, id){
        // this scrolls the original position back into view
        var  sm = this.tree.getSelectionModel();
        sm.clearSelections();
        sm.select(this.dragData.node);
    }
});
}
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.tree.TreeEditor
 * @extends Roo.Editor
 * Provides editor functionality for inline tree node editing.  Any valid {@link Roo.form.Field} can be used
 * as the editor field.
 * @constructor
 * @param {TreePanel} tree
 * @param {Object} config Either a prebuilt {@link Roo.form.Field} instance or a Field config object
 */
Roo.tree.TreeEditor = function(A, B){
    B = B || {};
    var  C = B.events ? B : new  Roo.form.TextField(B);
    Roo.tree.TreeEditor.superclass.constructor.call(this, C);

    this.tree = A;

    A.on('beforeclick', this.beforeNodeClick, this);
    A.getTreeEl().on('mousedown', this.hide, this);
    this.on('complete', this.updateNode, this);
    this.on('beforestartedit', this.fitToTree, this);
    this.on('startedit', this.bindScroll, this, {delay:10});
    this.on('specialkey', this.onSpecialKey, this);
};

Roo.extend(Roo.tree.TreeEditor, Roo.Editor, {
    /**
     * @cfg {String} alignment
     * The position to align to (see {@link Roo.Element#alignTo} for more details, defaults to "l-l").
     */
    alignment: "l-l",
    // inherit
    autoSize: false,
    /**
     * @cfg {Boolean} hideEl
     * True to hide the bound element while the editor is displayed (defaults to false)
     */
    hideEl : false,
    /**
     * @cfg {String} cls
     * CSS class to apply to the editor (defaults to "x-small-editor x-tree-editor")
     */
    cls: "x-small-editor x-tree-editor",
    /**
     * @cfg {Boolean} shim
     * True to shim the editor if selects/iframes could be displayed beneath it (defaults to false)
     */
    shim:false,
    // inherit
    shadow:"frame",
    /**
     * @cfg {Number} maxWidth
     * The maximum width in pixels of the editor field (defaults to 250).  Note that if the maxWidth would exceed
     * the containing tree element's size, it will be automatically limited for you to the container width, taking
     * scroll and client offsets into account prior to each edit.
     */
    maxWidth: 250,

    editDelay : 350,

    // private
    fitToTree : function(ed, el){
        var  td = this.tree.getTreeEl().dom, nd = el.dom;
        if(td.scrollLeft >  nd.offsetLeft){ // ensure the node left point is visible
            td.scrollLeft = nd.offsetLeft;
        }
        var  w = Math.min(
                this.maxWidth,
                (td.clientWidth > 20 ? td.clientWidth : td.offsetWidth) - Math.max(0, nd.offsetLeft-td.scrollLeft) - /*cushion*/5);
        this.setSize(w, '');
    },

    // private
    triggerEdit : function(D){
        this.completeEdit();
        this.editNode = D;
        this.startEdit(D.ui.textNode, D.text);
    },

    // private
    bindScroll : function(){
        this.tree.getTreeEl().on('scroll', this.cancelEdit, this);
    },

    // private
    beforeNodeClick : function(E, e){
        var  F = (this.lastClick ? this.lastClick.getElapsed() : 0);
        this.lastClick = new  Date();
        if(F > this.editDelay && this.tree.getSelectionModel().isSelected(E)){
            e.stopEvent();
            this.triggerEdit(E);
            return  false;
        }
    },

    // private
    updateNode : function(ed, G){
        this.tree.getTreeEl().un('scroll', this.cancelEdit, this);
        this.editNode.setText(G);
    },

    // private
    onHide : function(){
        Roo.tree.TreeEditor.superclass.onHide.call(this);
        if(this.editNode){
            this.editNode.ui.focus();
        }
    },

    // private
    onSpecialKey : function(H, e){
        var  k = e.getKey();
        if(k == e.ESC){
            e.stopEvent();
            this.cancelEdit();
        }else  if(k == e.ENTER && !e.hasModifier()){
            e.stopEvent();
            this.completeEdit();
        }
    }
});
//<Script type="text/javascript">
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * Not documented??? - probably should be...
 */

Roo.tree.ColumnNodeUI = Roo.extend(Roo.tree.TreeNodeUI, {
    //focus: Roo.emptyFn, // prevent odd scrolling behavior
    
    renderElements : function(n, a, A, B){
        //consel.log("renderElements?");
        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';

        var  t = n.getOwnerTree();
        var  C = Pman.Tab.Document_TypesTree.tree.el.id;
        
        var  D = t.columns;
        var  bw = t.borderWidth;
        var  c = D[0];
        var  E = a.href ? a.href : Roo.isGecko ? "" : "#";
         var  cb = typeof  a.checked == "boolean";
        var  tx = String.format('{0}',n.text || (c.renderer ? c.renderer(a[c.dataIndex], n, a) : a[c.dataIndex]));
        var  F = 'x-t-' + C + '-c0';
        var  G = [
            '<li class="x-tree-node">',
            
                
                '<div class="x-tree-node-el ', a.cls,'">',
                    // extran...
                    '<div class="x-tree-col ', F, '" style="width:', c.width-bw, 'px;">',
                
                
                        '<span class="x-tree-node-indent">',this.indentMarkup,'</span>',
                        '<img src="', this.emptyIcon, '" class="x-tree-ec-icon  " />',
                        '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon',
                           (a.icon ? ' x-tree-node-inline-icon' : ''),
                           (a.iconCls ? ' '+a.iconCls : ''),
                           '" unselectable="on" />',
                        (cb ? ('<input class="x-tree-node-cb" type="checkbox" ' + 
                             (a.checked ? 'checked="checked" />' : ' />')) : ''),
                             
                        '<a class="x-tree-node-anchor" hidefocus="on" href="',E,'" tabIndex="1" ',
                            (a.hrefTarget ? ' target="' +a.hrefTarget + '"' : ''), '>',
                            '<span unselectable="on" qtip="' + tx + '">',
                             tx,
                             '</span></a>' ,
                    '</div>',
                     '<a class="x-tree-node-anchor" hidefocus="on" href="',E,'" tabIndex="1" ',
                            (a.hrefTarget ? ' target="' +a.hrefTarget + '"' : ''), '>',
                 ];
        
        for(var  i = 1, len = D.length; i < len; i++){
            c = D[i];
            F = 'x-t-' + C + '-c' +i;
            tx = String.format('{0}', (c.renderer ? c.renderer(a[c.dataIndex], n, a) : a[c.dataIndex]));
            G.push('<div class="x-tree-col ', F, ' ' ,(c.cls?c.cls:''),'" style="width:',c.width-bw,'px;">',
                        '<div class="x-tree-col-text" qtip="' + tx +'">',tx,"</div>",
                      "</div>");
         }

         
         G.push(
            '</a>',
            '<div class="x-clear"></div></div>',
            '<ul class="x-tree-node-ct" style="display:none;"></ul>',
            "</li>");
        
        if(B !== true && n.nextSibling && n.nextSibling.ui.getEl()){
            this.wrap = Roo.DomHelper.insertHtml("beforeBegin",
                                n.nextSibling.ui.getEl(), G.join(""));
        }else {
            this.wrap = Roo.DomHelper.insertHtml("beforeEnd", A, G.join(""));
        }
        var  el = this.wrap.firstChild;
        this.elRow = el;
        this.elNode = el.firstChild;
        this.ranchor = el.childNodes[1];
        this.ctNode = this.wrap.childNodes[1];
        var  cs = el.firstChild.childNodes;
        this.indentNode = cs[0];
        this.ecNode = cs[1];
        this.iconNode = cs[2];
        var  H = 3;
        if(cb){
            this.checkbox = cs[3];
            H++;
        }

        this.anchor = cs[H];
        
        this.textNode = cs[H].firstChild;
        
        //el.on("click", this.onClick, this);
        //el.on("dblclick", this.onDblClick, this);
        
        
       // console.log(this);
    },
    initEvents : function(){
        Roo.tree.ColumnNodeUI.superclass.initEvents.call(this);
        
            
        var  a = this.ranchor;

        var  el = Roo.get(a);

        if(Roo.isOpera){ // opera render bug ignores the CSS
            el.setStyle("text-decoration", "none");
        }


        el.on("click", this.onClick, this);
        el.on("dblclick", this.onDblClick, this);
        el.on("contextmenu", this.onContextMenu, this);
        
    },
    
    /*onSelectedChange : function(state){
        if(state){
            this.focus();
            this.addClass("x-tree-selected");
        }else{
            //this.blur();
            this.removeClass("x-tree-selected");
        }
    },*/
    addClass : function(I){
        if(this.elRow){
            Roo.fly(this.elRow).addClass(I);
        }
        
    },
    
    
    removeClass : function(J){
        if(this.elRow){
            Roo.fly(this.elRow).removeClass(J);
        }
    }

    
    
});
//<Script type="text/javascript">

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.tree.ColumnTree
 * @extends Roo.data.TreePanel
 * @cfg {Object} columns  Including width, header, renderer, cls, dataIndex 
 * @cfg {int} borderWidth  compined right/left border allowance
 * @constructor
 * @param {String/HTMLElement/Element} el The container element
 * @param {Object} config
 */
Roo.tree.ColumnTree =  function(el, A)
{
   Roo.tree.ColumnTree.superclass.constructor.call(this, el , A);
   this.addEvents({
        /**
        * @event resize
        * Fire this event on a container when it resizes
        * @param {int} w Width
        * @param {int} h Height
        */
       "resize" : true
    });
    this.on('resize', this.onResize, this);
};

Roo.extend(Roo.tree.ColumnTree, Roo.tree.TreePanel, {
    //lines:false,
    
    
    borderWidth: Roo.isBorderBox ? 0 : 2, 
    headEls : false,
    
    render : function(){
        // add the header.....
       
        Roo.tree.ColumnTree.superclass.render.apply(this);
        
        this.el.addClass('x-column-tree');
        
        this.headers = this.el.createChild(
            {cls:'x-tree-headers'},this.innerCt.dom);
   
        var  B = this.columns, c;
        var  C = 0;
        this.headEls = [];
        var   D = B.length;
        for(var  i = 0; i < D; i++){
             c = B[i];
             C += c.width;
            this.headEls.push(this.headers.createChild({
                 cls:'x-tree-hd ' + (c.cls?c.cls+'-hd':''),
                 cn: {
                     cls:'x-tree-hd-text',
                     html: c.header
                 },
                 style:'width:'+(c.width-this.borderWidth)+'px;'
             }));
        }

        this.headers.createChild({cls:'x-clear'});
        // prevent floats from wrapping when clipped
        this.headers.setWidth(C);
        //this.innerCt.setWidth(totalWidth);
        this.innerCt.setStyle({ overflow: 'auto' });
        this.onResize(this.width, this.height);
             
        
    },
    onResize : function(w,h)
    {
        this.height = h;
        this.width = w;
        // resize cols..
        this.innerCt.setWidth(this.width);
        this.innerCt.setHeight(this.height-20);
        
        // headers...
        var  E = this.columns, c;
        var  F = 0;
        var  G = false;
        var  H = E.length;
        for(var  i = 0; i < H; i++){
            c = E[i];
            if (this.autoExpandColumn !== false && c.dataIndex == this.autoExpandColumn) {
                // it's the expander..
                G  = this.headEls[i];
                continue;
            }

            F += c.width;
            
        }
        if (G) {
            G.setWidth(  ((w - F)-this.borderWidth - 20));
        }

        this.headers.setWidth(w-20);

        
        
        
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.Menu
 * @extends Roo.util.Observable
 * A menu object.  This is the container to which you add all other menu items.  Menu can also serve a as a base class
 * when you want a specialzed menu based off of another component (like {@link Roo.menu.DateMenu} for example).
 * @constructor
 * Creates a new Menu
 * @param {Object} config Configuration options
 */
Roo.menu.Menu = function(A){
    Roo.apply(this, A);
    this.id = this.id || Roo.id();
    this.addEvents({
        /**
         * @event beforeshow
         * Fires before this menu is displayed
         * @param {Roo.menu.Menu} this
         */
        beforeshow : true,
        /**
         * @event beforehide
         * Fires before this menu is hidden
         * @param {Roo.menu.Menu} this
         */
        beforehide : true,
        /**
         * @event show
         * Fires after this menu is displayed
         * @param {Roo.menu.Menu} this
         */
        show : true,
        /**
         * @event hide
         * Fires after this menu is hidden
         * @param {Roo.menu.Menu} this
         */
        hide : true,
        /**
         * @event click
         * Fires when this menu is clicked (or when the enter key is pressed while it is active)
         * @param {Roo.menu.Menu} this
         * @param {Roo.menu.Item} menuItem The menu item that was clicked
         * @param {Roo.EventObject} e
         */
        click : true,
        /**
         * @event mouseover
         * Fires when the mouse is hovering over this menu
         * @param {Roo.menu.Menu} this
         * @param {Roo.EventObject} e
         * @param {Roo.menu.Item} menuItem The menu item that was clicked
         */
        mouseover : true,
        /**
         * @event mouseout
         * Fires when the mouse exits this menu
         * @param {Roo.menu.Menu} this
         * @param {Roo.EventObject} e
         * @param {Roo.menu.Item} menuItem The menu item that was clicked
         */
        mouseout : true,
        /**
         * @event itemclick
         * Fires when a menu item contained in this menu is clicked
         * @param {Roo.menu.BaseItem} baseItem The BaseItem that was clicked
         * @param {Roo.EventObject} e
         */
        itemclick: true
    });
    if (this.registerMenu) {
        Roo.menu.MenuMgr.register(this);
    }
    
    var  B = this.items;
    this.items = new  Roo.util.MixedCollection();
    if(B){
        this.add.apply(this, B);
    }
};

Roo.extend(Roo.menu.Menu, Roo.util.Observable, {
    /**
     * @cfg {Number} minWidth The minimum width of the menu in pixels (defaults to 120)
     */
    minWidth : 120,
    /**
     * @cfg {Boolean/String} shadow True or "sides" for the default effect, "frame" for 4-way shadow, and "drop"
     * for bottom-right shadow (defaults to "sides")
     */
    shadow : "sides",
    /**
     * @cfg {String} subMenuAlign The {@link Roo.Element#alignTo} anchor position value to use for submenus of
     * this menu (defaults to "tl-tr?")
     */
    subMenuAlign : "tl-tr?",
    /**
     * @cfg {String} defaultAlign The default {@link Roo.Element#alignTo) anchor position value for this menu
     * relative to its element of origin (defaults to "tl-bl?")
     */
    defaultAlign : "tl-bl?",
    /**
     * @cfg {Boolean} allowOtherMenus True to allow multiple menus to be displayed at the same time (defaults to false)
     */
    allowOtherMenus : false,
    /**
     * @cfg {Boolean} registerMenu True (default) - means that clicking on screen etc. hides it.
     */
    registerMenu : true,

    hidden:true,

    // private
    render : function(){
        if(this.el){
            return;
        }
        var  el = this.el = new  Roo.Layer({
            cls: "x-menu",
            shadow:this.shadow,
            constrain: false,
            parentEl: this.parentEl || document.body,
            zindex:15000
        });

        this.keyNav = new  Roo.menu.MenuNav(this);

        if(this.plain){
            el.addClass("x-menu-plain");
        }
        if(this.cls){
            el.addClass(this.cls);
        }

        // generic focus element
        this.focusEl = el.createChild({
            tag: "a", cls: "x-menu-focus", href: "#", onclick: "return false;", tabIndex:"-1"
        });
        var  ul = el.createChild({tag: "ul", cls: "x-menu-list"});
        ul.on("click", this.onClick, this);
        ul.on("mouseover", this.onMouseOver, this);
        ul.on("mouseout", this.onMouseOut, this);
        this.items.each(function(C){
            var  li = document.createElement("li");
            li.className = "x-menu-list-item";
            ul.dom.appendChild(li);
            C.render(li, this);
        }, this);
        this.ul = ul;
        this.autoWidth();
    },

    // private
    autoWidth : function(){
        var  el = this.el, ul = this.ul;
        if(!el){
            return;
        }
        var  w = this.width;
        if(w){
            el.setWidth(w);
        }else  if(Roo.isIE){
            el.setWidth(this.minWidth);
            var  t = el.dom.offsetWidth; // force recalc
            el.setWidth(ul.getWidth()+el.getFrameWidth("lr"));
        }
    },

    // private
    delayAutoWidth : function(){
        if(this.rendered){
            if(!this.awTask){
                this.awTask = new  Roo.util.DelayedTask(this.autoWidth, this);
            }

            this.awTask.delay(20);
        }
    },

    // private
    findTargetItem : function(e){
        var  t = e.getTarget(".x-menu-list-item", this.ul,  true);
        if(t && t.menuItemId){
            return  this.items.get(t.menuItemId);
        }
    },

    // private
    onClick : function(e){
        var  t;
        if(t = this.findTargetItem(e)){
            t.onClick(e);
            this.fireEvent("click", this, t, e);
        }
    },

    // private
    setActiveItem : function(C, D){
        if(C != this.activeItem){
            if(this.activeItem){
                this.activeItem.deactivate();
            }

            this.activeItem = C;
            C.activate(D);
        }else  if(D){
            C.expandMenu();
        }
    },

    // private
    tryActivate : function(E, F){
        var  G = this.items;
        for(var  i = E, len = G.length; i >= 0 && i < len; i+= F){
            var  C = G.get(i);
            if(!C.disabled && C.canActivate){
                this.setActiveItem(C, false);
                return  C;
            }
        }
        return  false;
    },

    // private
    onMouseOver : function(e){
        var  t;
        if(t = this.findTargetItem(e)){
            if(t.canActivate && !t.disabled){
                this.setActiveItem(t, true);
            }
        }

        this.fireEvent("mouseover", this, e, t);
    },

    // private
    onMouseOut : function(e){
        var  t;
        if(t = this.findTargetItem(e)){
            if(t == this.activeItem && t.shouldDeactivate(e)){
                this.activeItem.deactivate();
                delete  this.activeItem;
            }
        }

        this.fireEvent("mouseout", this, e, t);
    },

    /**
     * Read-only.  Returns true if the menu is currently displayed, else false.
     * @type Boolean
     */
    isVisible : function(){
        return  this.el && !this.hidden;
    },

    /**
     * Displays this menu relative to another element
     * @param {String/HTMLElement/Roo.Element} element The element to align to
     * @param {String} position (optional) The {@link Roo.Element#alignTo} anchor position to use in aligning to
     * the element (defaults to this.defaultAlign)
     * @param {Roo.menu.Menu} parentMenu (optional) This menu's parent menu, if applicable (defaults to undefined)
     */
    show : function(el, H, I){
        this.parentMenu = I;
        if(!this.el){
            this.render();
        }

        this.fireEvent("beforeshow", this);
        this.showAt(this.el.getAlignToXY(el, H || this.defaultAlign), I, false);
    },

    /**
     * Displays this menu at a specific xy position
     * @param {Array} xyPosition Contains X & Y [x, y] values for the position at which to show the menu (coordinates are page-based)
     * @param {Roo.menu.Menu} parentMenu (optional) This menu's parent menu, if applicable (defaults to undefined)
     */
    showAt : function(xy, J, /* private: */_e){
        this.parentMenu = J;
        if(!this.el){
            this.render();
        }
        if(_e !== false){
            this.fireEvent("beforeshow", this);
            xy = this.el.adjustForConstraints(xy);
        }

        this.el.setXY(xy);
        this.el.show();
        this.hidden = false;
        this.focus();
        this.fireEvent("show", this);
    },

    focus : function(){
        if(!this.hidden){
            this.doFocus.defer(50, this);
        }
    },

    doFocus : function(){
        if(!this.hidden){
            this.focusEl.focus();
        }
    },

    /**
     * Hides this menu and optionally all parent menus
     * @param {Boolean} deep (optional) True to hide all parent menus recursively, if any (defaults to false)
     */
    hide : function(K){
        if(this.el && this.isVisible()){
            this.fireEvent("beforehide", this);
            if(this.activeItem){
                this.activeItem.deactivate();
                this.activeItem = null;
            }

            this.el.hide();
            this.hidden = true;
            this.fireEvent("hide", this);
        }
        if(K === true && this.parentMenu){
            this.parentMenu.hide(true);
        }
    },

    /**
     * Addds one or more items of any type supported by the Menu class, or that can be converted into menu items.
     * Any of the following are valid:
     * <ul>
     * <li>Any menu item object based on {@link Roo.menu.Item}</li>
     * <li>An HTMLElement object which will be converted to a menu item</li>
     * <li>A menu item config object that will be created as a new menu item</li>
     * <li>A string, which can either be '-' or 'separator' to add a menu separator, otherwise
     * it will be converted into a {@link Roo.menu.TextItem} and added</li>
     * </ul>
     * Usage:
     * <pre><code>
// Create the menu
var menu = new Roo.menu.Menu();

// Create a menu item to add by reference
var menuItem = new Roo.menu.Item({ text: 'New Item!' });

// Add a bunch of items at once using different methods.
// Only the last item added will be returned.
var item = menu.add(
    menuItem,                // add existing item by ref
    'Dynamic Item',          // new TextItem
    '-',                     // new separator
    { text: 'Config Item' }  // new item by config
);
</code></pre>
     * @param {Mixed} args One or more menu items, menu item configs or other objects that can be converted to menu items
     * @return {Roo.menu.Item} The menu item that was added, or the last one if multiple items were added
     */
    add : function(){
        var  a = arguments, l = a.length, L;
        for(var  i = 0; i < l; i++){
            var  el = a[i];
            if(el.render){ // some kind of Item
                L = this.addItem(el);
            }else  if(typeof  el == "string"){ // string
                if(el == "separator" || el == "-"){
                    L = this.addSeparator();
                }else {
                    L = this.addText(el);
                }
            }else  if(el.tagName || el.el){ // element
                L = this.addElement(el);
            }else  if(typeof  el == "object"){ // must be menu item config?
                L = this.addMenuItem(el);
            }
        }
        return  L;
    },

    /**
     * Returns this menu's underlying {@link Roo.Element} object
     * @return {Roo.Element} The element
     */
    getEl : function(){
        if(!this.el){
            this.render();
        }
        return  this.el;
    },

    /**
     * Adds a separator bar to the menu
     * @return {Roo.menu.Item} The menu item that was added
     */
    addSeparator : function(){
        return  this.addItem(new  Roo.menu.Separator());
    },

    /**
     * Adds an {@link Roo.Element} object to the menu
     * @param {String/HTMLElement/Roo.Element} el The element or DOM node to add, or its id
     * @return {Roo.menu.Item} The menu item that was added
     */
    addElement : function(el){
        return  this.addItem(new  Roo.menu.BaseItem(el));
    },

    /**
     * Adds an existing object based on {@link Roo.menu.Item} to the menu
     * @param {Roo.menu.Item} item The menu item to add
     * @return {Roo.menu.Item} The menu item that was added
     */
    addItem : function(M){
        this.items.add(M);
        if(this.ul){
            var  li = document.createElement("li");
            li.className = "x-menu-list-item";
            this.ul.dom.appendChild(li);
            M.render(li, this);
            this.delayAutoWidth();
        }
        return  M;
    },

    /**
     * Creates a new {@link Roo.menu.Item} based an the supplied config object and adds it to the menu
     * @param {Object} config A MenuItem config object
     * @return {Roo.menu.Item} The menu item that was added
     */
    addMenuItem : function(N){
        if(!(N  instanceof  Roo.menu.Item)){
            if(typeof  N.checked == "boolean"){ // must be check menu item config?
                N = new  Roo.menu.CheckItem(N);
            }else {
                N = new  Roo.menu.Item(N);
            }
        }
        return  this.addItem(N);
    },

    /**
     * Creates a new {@link Roo.menu.TextItem} with the supplied text and adds it to the menu
     * @param {String} text The text to display in the menu item
     * @return {Roo.menu.Item} The menu item that was added
     */
    addText : function(O){
        return  this.addItem(new  Roo.menu.TextItem(O));
    },

    /**
     * Inserts an existing object based on {@link Roo.menu.Item} to the menu at a specified index
     * @param {Number} index The index in the menu's list of current items where the new item should be inserted
     * @param {Roo.menu.Item} item The menu item to add
     * @return {Roo.menu.Item} The menu item that was added
     */
    insert : function(P, Q){
        this.items.insert(P, Q);
        if(this.ul){
            var  li = document.createElement("li");
            li.className = "x-menu-list-item";
            this.ul.dom.insertBefore(li, this.ul.dom.childNodes[P]);
            Q.render(li, this);
            this.delayAutoWidth();
        }
        return  Q;
    },

    /**
     * Removes an {@link Roo.menu.Item} from the menu and destroys the object
     * @param {Roo.menu.Item} item The menu item to remove
     */
    remove : function(R){
        this.items.removeKey(R.id);
        R.destroy();
    },

    /**
     * Removes and destroys all items in the menu
     */
    removeAll : function(){
        var  f;
        while(f = this.items.first()){
            this.remove(f);
        }
    }
});

// MenuNav is a private utility class used internally by the Menu
Roo.menu.MenuNav = function(S){
    Roo.menu.MenuNav.superclass.constructor.call(this, S.el);
    this.scope = this.menu = S;
};

Roo.extend(Roo.menu.MenuNav, Roo.KeyNav, {
    doRelay : function(e, h){
        var  k = e.getKey();
        if(!this.menu.activeItem && e.isNavKeyPress() && k != e.SPACE && k != e.RETURN ){
            this.menu.tryActivate(0, 1);
            return  false;
        }
        return  h.call(this.scope || this, e, this.menu);
    },

    up : function(e, m){
        if(!m.tryActivate(m.items.indexOf(m.activeItem)-1, -1)){
            m.tryActivate(m.items.length-1, -1);
        }
    },

    down : function(e, m){
        if(!m.tryActivate(m.items.indexOf(m.activeItem)+1, 1)){
            m.tryActivate(0, 1);
        }
    },

    right : function(e, m){
        if(m.activeItem){
            m.activeItem.expandMenu(true);
        }
    },

    left : function(e, m){
        m.hide();
        if(m.parentMenu && m.parentMenu.activeItem){
            m.parentMenu.activeItem.activate();
        }
    },

    enter : function(e, m){
        if(m.activeItem){
            e.stopPropagation();
            m.activeItem.onClick(e);
            m.fireEvent("click", this, m.activeItem);
            return  true;
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.MenuMgr
 * Provides a common registry of all menu items on a page so that they can be easily accessed by id.
 * @singleton
 */
Roo.menu.MenuMgr = function(){
   var  A, B, C = {}, attached = false, lastShow = new  Date();

   // private - called when first menu is created
   function  D(){
       A = {};
       B = new  Roo.util.MixedCollection();
       Roo.get(document).addKeyListener(27, function(){
           if(B.length > 0){
               E();
           }
       });
   }

   // private
   function  E(){
       if(B && B.length > 0){
           var  c = B.clone();
           c.each(function(m){
               m.hide();
           });
       }
   }

   // private
   function  F(m){
       B.remove(m);
       if(B.length < 1){
           Roo.get(document).un("mousedown", J);
           attached = false;
       }
   }

   // private
   function  G(m){
       var  L = B.last();
       lastShow = new  Date();
       B.add(m);
       if(!attached){
           Roo.get(document).on("mousedown", J);
           attached = true;
       }
       if(m.parentMenu){
          m.getEl().setZIndex(parseInt(m.parentMenu.getEl().getStyle("z-index"), 10) + 3);
          m.parentMenu.activeChild = m;
       }else  if(L && L.isVisible()){
          m.getEl().setZIndex(parseInt(L.getEl().getStyle("z-index"), 10) + 3);
       }
   }

   // private
   function  H(m){
       if(m.activeChild){
           m.activeChild.hide();
       }
       if(m.autoHideTimer){
           clearTimeout(m.autoHideTimer);
           delete  m.autoHideTimer;
       }
   }

   // private
   function  I(m){
       var  pm = m.parentMenu;
       if(!pm && !m.allowOtherMenus){
           E();
       }else  if(pm && pm.activeChild && B != m){
           pm.activeChild.hide();
       }
   }

   // private
   function  J(e){
       if(lastShow.getElapsed() > 50 && B.length > 0 && !e.getTarget(".x-menu")){
           E();
       }
   }

   // private
   function  K(mi, L){
       if(L){
           var  g = C[mi.group];
           for(var  i = 0, l = g.length; i < l; i++){
               if(g[i] != mi){
                   g[i].setChecked(false);
               }
           }
       }
   }

   return  {

       /**
        * Hides all menus that are currently visible
        */
       hideAll : function(){
            E();  
       },

       // private
       register : function(Q){
           if(!A){
               D();
           }

           A[Q.id] = Q;
           Q.on("beforehide", H);
           Q.on("hide", F);
           Q.on("beforeshow", I);
           Q.on("show", G);
           var  g = Q.group;
           if(g && Q.events["checkchange"]){
               if(!C[g]){
                   C[g] = [];
               }

               C[g].push(Q);
               Q.on("checkchange", onCheck);
           }
       },

        /**
         * Returns a {@link Roo.menu.Menu} object
         * @param {String/Object} menu The string menu id, an existing menu object reference, or a Menu config that will
         * be used to generate and return a new Menu instance.
         */
       get : function(R){
           if(typeof  R == "string"){ // menu id
               return  A[R];
           }else  if(R.events){  // menu instance
               return  R;
           }else  if(typeof  R.length == 'number'){ // array of menu items?
               return  new  Roo.menu.Menu({items:R});
           }else { // otherwise, must be a config
               return  new  Roo.menu.Menu(R);
           }
       },

       // private
       unregister : function(S){
           delete  A[S.id];
           S.un("beforehide", H);
           S.un("hide", F);
           S.un("beforeshow", I);
           S.un("show", G);
           var  g = S.group;
           if(g && S.events["checkchange"]){
               C[g].remove(S);
               S.un("checkchange", onCheck);
           }
       },

       // private
       registerCheckable : function(T){
           var  g = T.group;
           if(g){
               if(!C[g]){
                   C[g] = [];
               }

               C[g].push(T);
               T.on("beforecheckchange", K);
           }
       },

       // private
       unregisterCheckable : function(U){
           var  g = U.group;
           if(g){
               C[g].remove(U);
               U.un("beforecheckchange", K);
           }
       }
   };
}();
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.menu.BaseItem
 * @extends Roo.Component
 * The base class for all items that render into menus.  BaseItem provides default rendering, activated state
 * management and base configuration options shared by all menu components.
 * @constructor
 * Creates a new BaseItem
 * @param {Object} config Configuration options
 */
Roo.menu.BaseItem = function(A){
    Roo.menu.BaseItem.superclass.constructor.call(this, A);

    this.addEvents({
        /**
         * @event click
         * Fires when this item is clicked
         * @param {Roo.menu.BaseItem} this
         * @param {Roo.EventObject} e
         */
        click: true,
        /**
         * @event activate
         * Fires when this item is activated
         * @param {Roo.menu.BaseItem} this
         */
        activate : true,
        /**
         * @event deactivate
         * Fires when this item is deactivated
         * @param {Roo.menu.BaseItem} this
         */
        deactivate : true
    });

    if(this.handler){
        this.on("click", this.handler, this.scope, true);
    }
};

Roo.extend(Roo.menu.BaseItem, Roo.Component, {
    /**
     * @cfg {Function} handler
     * A function that will handle the click event of this menu item (defaults to undefined)
     */
    /**
     * @cfg {Boolean} canActivate True if this item can be visually activated (defaults to false)
     */
    canActivate : false,
    /**
     * @cfg {String} activeClass The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")
     */
    activeClass : "x-menu-item-active",
    /**
     * @cfg {Boolean} hideOnClick True to hide the containing menu after this item is clicked (defaults to true)
     */
    hideOnClick : true,
    /**
     * @cfg {Number} hideDelay Length of time in milliseconds to wait before hiding after a click (defaults to 100)
     */
    hideDelay : 100,

    // private
    ctype: "Roo.menu.BaseItem",

    // private
    actionMode : "container",

    // private
    render : function(B, C){
        this.parentMenu = C;
        Roo.menu.BaseItem.superclass.render.call(this, B);
        this.container.menuItemId = this.id;
    },

    // private
    onRender : function(D, E){
        this.el = Roo.get(this.el);
        D.dom.appendChild(this.el.dom);
    },

    // private
    onClick : function(e){
        if(!this.disabled && this.fireEvent("click", this, e) !== false
                && this.parentMenu.fireEvent("itemclick", this, e) !== false){
            this.handleClick(e);
        }else {
            e.stopEvent();
        }
    },

    // private
    activate : function(){
        if(this.disabled){
            return  false;
        }
        var  li = this.container;
        li.addClass(this.activeClass);
        this.region = li.getRegion().adjust(2, 2, -2, -2);
        this.fireEvent("activate", this);
        return  true;
    },

    // private
    deactivate : function(){
        this.container.removeClass(this.activeClass);
        this.fireEvent("deactivate", this);
    },

    // private
    shouldDeactivate : function(e){
        return  !this.region || !this.region.contains(e.getPoint());
    },

    // private
    handleClick : function(e){
        if(this.hideOnClick){
            this.parentMenu.hide.defer(this.hideDelay, this.parentMenu, [true]);
        }
    },

    // private
    expandMenu : function(F){
        // do nothing
    },

    // private
    hideMenu : function(){
        // do nothing
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.Adapter
 * @extends Roo.menu.BaseItem
 * A base utility class that adapts a non-menu component so that it can be wrapped by a menu item and added to a menu.
 * It provides basic rendering, activation management and enable/disable logic required to work in menus.
 * @constructor
 * Creates a new Adapter
 * @param {Object} config Configuration options
 */
Roo.menu.Adapter = function(A, B){
    Roo.menu.Adapter.superclass.constructor.call(this, B);
    this.component = A;
};
Roo.extend(Roo.menu.Adapter, Roo.menu.BaseItem, {
    // private
    canActivate : true,

    // private
    onRender : function(C, D){
        this.component.render(C);
        this.el = this.component.getEl();
    },

    // private
    activate : function(){
        if(this.disabled){
            return  false;
        }

        this.component.focus();
        this.fireEvent("activate", this);
        return  true;
    },

    // private
    deactivate : function(){
        this.fireEvent("deactivate", this);
    },

    // private
    disable : function(){
        this.component.disable();
        Roo.menu.Adapter.superclass.disable.call(this);
    },

    // private
    enable : function(){
        this.component.enable();
        Roo.menu.Adapter.superclass.enable.call(this);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.menu.TextItem
 * @extends Roo.menu.BaseItem
 * Adds a static text string to a menu, usually used as either a heading or group separator.
 * @constructor
 * Creates a new TextItem
 * @param {String} text The text to display
 */
Roo.menu.TextItem = function(A){
    this.text = A;
    Roo.menu.TextItem.superclass.constructor.call(this);
};

Roo.extend(Roo.menu.TextItem, Roo.menu.BaseItem, {
    /**
     * @cfg {Boolean} hideOnClick True to hide the containing menu after this item is clicked (defaults to false)
     */
    hideOnClick : false,
    /**
     * @cfg {String} itemCls The default CSS class to use for text items (defaults to "x-menu-text")
     */
    itemCls : "x-menu-text",

    // private
    onRender : function(){
        var  s = document.createElement("span");
        s.className = this.itemCls;
        s.innerHTML = this.text;
        this.el = s;
        Roo.menu.TextItem.superclass.onRender.apply(this, arguments);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.menu.Separator
 * @extends Roo.menu.BaseItem
 * Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will
 * add one of these by using "-" in you call to add() or in your items config rather than creating one directly.
 * @constructor
 * @param {Object} config Configuration options
 */
Roo.menu.Separator = function(A){
    Roo.menu.Separator.superclass.constructor.call(this, A);
};

Roo.extend(Roo.menu.Separator, Roo.menu.BaseItem, {
    /**
     * @cfg {String} itemCls The default CSS class to use for separators (defaults to "x-menu-sep")
     */
    itemCls : "x-menu-sep",
    /**
     * @cfg {Boolean} hideOnClick True to hide the containing menu after this item is clicked (defaults to false)
     */
    hideOnClick : false,

    // private
    onRender : function(li){
        var  s = document.createElement("span");
        s.className = this.itemCls;
        s.innerHTML = "&#160;";
        this.el = s;
        li.addClass("x-menu-sep-li");
        Roo.menu.Separator.superclass.onRender.apply(this, arguments);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.menu.Item
 * @extends Roo.menu.BaseItem
 * A base class for all menu items that require menu-related functionality (like sub-menus) and are not static
 * display items.  Item extends the base functionality of {@link Roo.menu.BaseItem} by adding menu-specific
 * activation and click handling.
 * @constructor
 * Creates a new Item
 * @param {Object} config Configuration options
 */
Roo.menu.Item = function(A){
    Roo.menu.Item.superclass.constructor.call(this, A);
    if(this.menu){
        this.menu = Roo.menu.MenuMgr.get(this.menu);
    }
};
Roo.extend(Roo.menu.Item, Roo.menu.BaseItem, {
    /**
     * @cfg {String} icon
     * The path to an icon to display in this menu item (defaults to Roo.BLANK_IMAGE_URL)
     */
    /**
     * @cfg {String} itemCls The default CSS class to use for menu items (defaults to "x-menu-item")
     */
    itemCls : "x-menu-item",
    /**
     * @cfg {Boolean} canActivate True if this item can be visually activated (defaults to true)
     */
    canActivate : true,
    /**
     * @cfg {Number} showDelay Length of time in milliseconds to wait before showing this item (defaults to 200)
     */
    showDelay: 200,
    // doc'd in BaseItem
    hideDelay: 200,

    // private
    ctype: "Roo.menu.Item",
    
    // private
    onRender : function(B, C){
        var  el = document.createElement("a");
        el.hideFocus = true;
        el.unselectable = "on";
        el.href = this.href || "#";
        if(this.hrefTarget){
            el.target = this.hrefTarget;
        }

        el.className = this.itemCls + (this.menu ?  " x-menu-item-arrow" : "") + (this.cls ?  " " + this.cls : "");
        el.innerHTML = String.format(
                '<img src="{0}" class="x-menu-item-icon {2}" />{1}',
                this.icon || Roo.BLANK_IMAGE_URL, this.text, this.iconCls || '');
        this.el = el;
        Roo.menu.Item.superclass.onRender.call(this, B, C);
    },

    /**
     * Sets the text to display in this menu item
     * @param {String} text The text to display
     */
    setText : function(D){
        this.text = D;
        if(this.rendered){
            this.el.update(String.format(
                '<img src="{0}" class="x-menu-item-icon {2}">{1}',
                this.icon || Roo.BLANK_IMAGE_URL, this.text, this.iconCls || ''));
            this.parentMenu.autoWidth();
        }
    },

    // private
    handleClick : function(e){
        if(!this.href){ // if no link defined, stop the event automatically
            e.stopEvent();
        }

        Roo.menu.Item.superclass.handleClick.apply(this, arguments);
    },

    // private
    activate : function(E){
        if(Roo.menu.Item.superclass.activate.apply(this, arguments)){
            this.focus();
            if(E){
                this.expandMenu();
            }
        }
        return  true;
    },

    // private
    shouldDeactivate : function(e){
        if(Roo.menu.Item.superclass.shouldDeactivate.call(this, e)){
            if(this.menu && this.menu.isVisible()){
                return  !this.menu.getEl().getRegion().contains(e.getPoint());
            }
            return  true;
        }
        return  false;
    },

    // private
    deactivate : function(){
        Roo.menu.Item.superclass.deactivate.apply(this, arguments);
        this.hideMenu();
    },

    // private
    expandMenu : function(F){
        if(!this.disabled && this.menu){
            clearTimeout(this.hideTimer);
            delete  this.hideTimer;
            if(!this.menu.isVisible() && !this.showTimer){
                this.showTimer = this.deferExpand.defer(this.showDelay, this, [F]);
            }else  if (this.menu.isVisible() && F){
                this.menu.tryActivate(0, 1);
            }
        }
    },

    // private
    deferExpand : function(G){
        delete  this.showTimer;
        this.menu.show(this.container, this.parentMenu.subMenuAlign || "tl-tr?", this.parentMenu);
        if(G){
            this.menu.tryActivate(0, 1);
        }
    },

    // private
    hideMenu : function(){
        clearTimeout(this.showTimer);
        delete  this.showTimer;
        if(!this.hideTimer && this.menu && this.menu.isVisible()){
            this.hideTimer = this.deferHide.defer(this.hideDelay, this);
        }
    },

    // private
    deferHide : function(){
        delete  this.hideTimer;
        this.menu.hide();
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.CheckItem
 * @extends Roo.menu.Item
 * Adds a menu item that contains a checkbox by default, but can also be part of a radio group.
 * @constructor
 * Creates a new CheckItem
 * @param {Object} config Configuration options
 */
Roo.menu.CheckItem = function(A){
    Roo.menu.CheckItem.superclass.constructor.call(this, A);
    this.addEvents({
        /**
         * @event beforecheckchange
         * Fires before the checked value is set, providing an opportunity to cancel if needed
         * @param {Roo.menu.CheckItem} this
         * @param {Boolean} checked The new checked value that will be set
         */
        "beforecheckchange" : true,
        /**
         * @event checkchange
         * Fires after the checked value has been set
         * @param {Roo.menu.CheckItem} this
         * @param {Boolean} checked The checked value that was set
         */
        "checkchange" : true
    });
    if(this.checkHandler){
        this.on('checkchange', this.checkHandler, this.scope);
    }
};
Roo.extend(Roo.menu.CheckItem, Roo.menu.Item, {
    /**
     * @cfg {String} group
     * All check items with the same group name will automatically be grouped into a single-select
     * radio button group (defaults to '')
     */
    /**
     * @cfg {String} itemCls The default CSS class to use for check items (defaults to "x-menu-item x-menu-check-item")
     */
    itemCls : "x-menu-item x-menu-check-item",
    /**
     * @cfg {String} groupClass The default CSS class to use for radio group check items (defaults to "x-menu-group-item")
     */
    groupClass : "x-menu-group-item",

    /**
     * @cfg {Boolean} checked True to initialize this checkbox as checked (defaults to false).  Note that
     * if this checkbox is part of a radio group (group = true) only the last item in the group that is
     * initialized with checked = true will be rendered as checked.
     */
    checked: false,

    // private
    ctype: "Roo.menu.CheckItem",

    // private
    onRender : function(c){
        Roo.menu.CheckItem.superclass.onRender.apply(this, arguments);
        if(this.group){
            this.el.addClass(this.groupClass);
        }

        Roo.menu.MenuMgr.registerCheckable(this);
        if(this.checked){
            this.checked = false;
            this.setChecked(true, true);
        }
    },

    // private
    destroy : function(){
        if(this.rendered){
            Roo.menu.MenuMgr.unregisterCheckable(this);
        }

        Roo.menu.CheckItem.superclass.destroy.apply(this, arguments);
    },

    /**
     * Set the checked state of this item
     * @param {Boolean} checked The new checked value
     * @param {Boolean} suppressEvent (optional) True to prevent the checkchange event from firing (defaults to false)
     */
    setChecked : function(B, C){
        if(this.checked != B && this.fireEvent("beforecheckchange", this, B) !== false){
            if(this.container){
                this.container[B ? "addClass" : "removeClass"]("x-menu-item-checked");
            }

            this.checked = B;
            if(C !== true){
                this.fireEvent("checkchange", this, B);
            }
        }
    },

    // private
    handleClick : function(e){
       if(!this.disabled && !(this.checked && this.group)){// disable unselect on radio item
           this.setChecked(!this.checked);
       }

       Roo.menu.CheckItem.superclass.handleClick.apply(this, arguments);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.DateItem
 * @extends Roo.menu.Adapter
 * A menu item that wraps the {@link Roo.DatPicker} component.
 * @constructor
 * Creates a new DateItem
 * @param {Object} config Configuration options
 */
Roo.menu.DateItem = function(A){
    Roo.menu.DateItem.superclass.constructor.call(this, new  Roo.DatePicker(A), A);
    /** The Roo.DatePicker object @type Roo.DatePicker */
    this.picker = this.component;
    this.addEvents({select: true});
    
    this.picker.on("render", function(B){
        B.getEl().swallowEvent("click");
        B.container.addClass("x-menu-date-item");
    });

    this.picker.on("select", this.onSelect, this);
};

Roo.extend(Roo.menu.DateItem, Roo.menu.Adapter, {
    // private
    onSelect : function(B, C){
        this.fireEvent("select", this, C, B);
        Roo.menu.DateItem.superclass.handleClick.call(this);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.menu.ColorItem
 * @extends Roo.menu.Adapter
 * A menu item that wraps the {@link Roo.ColorPalette} component.
 * @constructor
 * Creates a new ColorItem
 * @param {Object} config Configuration options
 */
Roo.menu.ColorItem = function(A){
    Roo.menu.ColorItem.superclass.constructor.call(this, new  Roo.ColorPalette(A), A);
    /** The Roo.ColorPalette object @type Roo.ColorPalette */
    this.palette = this.component;
    this.relayEvents(this.palette, ["select"]);
    if(this.selectHandler){
        this.on('select', this.selectHandler, this.scope);
    }
};
Roo.extend(Roo.menu.ColorItem, Roo.menu.Adapter);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.menu.DateMenu
 * @extends Roo.menu.Menu
 * A menu containing a {@link Roo.menu.DateItem} component (which provides a date picker).
 * @constructor
 * Creates a new DateMenu
 * @param {Object} config Configuration options
 */
Roo.menu.DateMenu = function(A){
    Roo.menu.DateMenu.superclass.constructor.call(this, A);
    this.plain = true;
    var  di = new  Roo.menu.DateItem(A);
    this.add(di);
    /**
     * The {@link Roo.DatePicker} instance for this DateMenu
     * @type DatePicker
     */
    this.picker = di.picker;
    /**
     * @event select
     * @param {DatePicker} picker
     * @param {Date} date
     */
    this.relayEvents(di, ["select"]);

    this.on('beforeshow', function(){
        if(this.picker){
            this.picker.hideMonthPicker(true);
        }
    }, this);
};
Roo.extend(Roo.menu.DateMenu, Roo.menu.Menu, {
    cls:'x-date-menu'
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.menu.ColorMenu
 * @extends Roo.menu.Menu
 * A menu containing a {@link Roo.menu.ColorItem} component (which provides a basic color picker).
 * @constructor
 * Creates a new ColorMenu
 * @param {Object} config Configuration options
 */
Roo.menu.ColorMenu = function(A){
    Roo.menu.ColorMenu.superclass.constructor.call(this, A);
    this.plain = true;
    var  ci = new  Roo.menu.ColorItem(A);
    this.add(ci);
    /**
     * The {@link Roo.ColorPalette} instance for this ColorMenu
     * @type ColorPalette
     */
    this.palette = ci.palette;
    /**
     * @event select
     * @param {ColorPalette} palette
     * @param {String} color
     */
    this.relayEvents(ci, ["select"]);
};
Roo.extend(Roo.menu.ColorMenu, Roo.menu.Menu);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.Field
 * @extends Roo.BoxComponent
 * Base class for form fields that provides default event handling, sizing, value handling and other functionality.
 * @constructor
 * Creates a new Field
 * @param {Object} config Configuration options
 */
Roo.form.Field = function(A){
    Roo.form.Field.superclass.constructor.call(this, A);
};

Roo.extend(Roo.form.Field, Roo.BoxComponent,  {
    /**
     * @cfg {String} fieldLabel Label to use when rendering a form.
     */
       /**
     * @cfg {String} qtip Mouse over tip
     */
     
    /**
     * @cfg {String} invalidClass The CSS class to use when marking a field invalid (defaults to "x-form-invalid")
     */
    invalidClass : "x-form-invalid",
    /**
     * @cfg {String} invalidText The error text to use when marking a field invalid and no message is provided (defaults to "The value in this field is invalid")
     */
    invalidText : "The value in this field is invalid",
    /**
     * @cfg {String} focusClass The CSS class to use when the field receives focus (defaults to "x-form-focus")
     */
    focusClass : "x-form-focus",
    /**
     * @cfg {String/Boolean} validationEvent The event that should initiate field validation. Set to false to disable
      automatic validation (defaults to "keyup").
     */
    validationEvent : "keyup",
    /**
     * @cfg {Boolean} validateOnBlur Whether the field should validate when it loses focus (defaults to true).
     */
    validateOnBlur : true,
    /**
     * @cfg {Number} validationDelay The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)
     */
    validationDelay : 250,
    /**
     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "text", size: "20", autocomplete: "off"})
     */
    defaultAutoCreate : {tag: "input", type: "text", size: "20", autocomplete: "off"},
    /**
     * @cfg {String} fieldClass The default CSS class for the field (defaults to "x-form-field")
     */
    fieldClass : "x-form-field",
    /**
     * @cfg {String} msgTarget The location where error text should display.  Should be one of the following values (defaults to 'qtip'):
     *<pre>
Value         Description
-----------   ----------------------------------------------------------------------
qtip          Display a quick tip when the user hovers over the field
title         Display a default browser title attribute popup
under         Add a block div beneath the field containing the error text
side          Add an error icon to the right of the field with a popup on hover
[element id]  Add the error text directly to the innerHTML of the specified element
</pre>
     */
    msgTarget : 'qtip',
    /**
     * @cfg {String} msgFx <b>Experimental</b> The effect used when displaying a validation message under the field (defaults to 'normal').
     */
    msgFx : 'normal',

    /**
     * @cfg {Boolean} readOnly True to mark the field as readOnly in HTML (defaults to false) -- Note: this only sets the element's readOnly DOM attribute.
     */
    readOnly : false,

    /**
     * @cfg {Boolean} disabled True to disable the field (defaults to false).
     */
    disabled : false,

    /**
     * @cfg {String} inputType The type attribute for input fields -- e.g. radio, text, password (defaults to "text").
     */
    inputType : undefined,
    
    /**
     * @cfg {Number} tabIndex The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo (defaults to undefined).
	 */
	tabIndex : undefined,
	
    // private
    isFormField : true,

    // private
    hasFocus : false,
    /**
     * @property {Roo.Element} fieldEl
     * Element Containing the rendered Field (with label etc.)
     */
    /**
     * @cfg {Mixed} value A value to initialize this field with.
     */
    value : undefined,

    /**
     * @cfg {String} name The field's HTML name attribute.
     */
    /**
     * @cfg {String} cls A CSS class to apply to the field's underlying element.
     */

	// private ??
	initComponent : function(){
        Roo.form.Field.superclass.initComponent.call(this);
        this.addEvents({
            /**
             * @event focus
             * Fires when this field receives input focus.
             * @param {Roo.form.Field} this
             */
            focus : true,
            /**
             * @event blur
             * Fires when this field loses input focus.
             * @param {Roo.form.Field} this
             */
            blur : true,
            /**
             * @event specialkey
             * Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed.  You can check
             * {@link Roo.EventObject#getKey} to determine which key was pressed.
             * @param {Roo.form.Field} this
             * @param {Roo.EventObject} e The event object
             */
            specialkey : true,
            /**
             * @event change
             * Fires just before the field blurs if the field value has changed.
             * @param {Roo.form.Field} this
             * @param {Mixed} newValue The new value
             * @param {Mixed} oldValue The original value
             */
            change : true,
            /**
             * @event invalid
             * Fires after the field has been marked as invalid.
             * @param {Roo.form.Field} this
             * @param {String} msg The validation message
             */
            invalid : true,
            /**
             * @event valid
             * Fires after the field has been validated with no errors.
             * @param {Roo.form.Field} this
             */
            valid : true
        });
    },

    /**
     * Returns the name attribute of the field if available
     * @return {String} name The field name
     */
    getName: function(){
         return  this.rendered && this.el.dom.name ? this.el.dom.name : (this.hiddenName || '');
    },

    // private
    onRender : function(ct, B){
        Roo.form.Field.superclass.onRender.call(this, ct, B);
        if(!this.el){
            var  cfg = this.getAutoCreate();
            if(!cfg.name){
                cfg.name = this.name || this.id;
            }
            if(this.inputType){
                cfg.type = this.inputType;
            }

            this.el = ct.createChild(cfg, B);
        }
        var  C = this.el.dom.type;
        if(C){
            if(C == 'password'){
                C = 'text';
            }

            this.el.addClass('x-form-'+C);
        }
        if(this.readOnly){
            this.el.dom.readOnly = true;
        }
        if(this.tabIndex !== undefined){
            this.el.dom.setAttribute('tabIndex', this.tabIndex);
        }


        this.el.addClass([this.fieldClass, this.cls]);
        this.initValue();
    },

    /**
     * Apply the behaviors of this component to an existing element. <b>This is used instead of render().</b>
     * @param {String/HTMLElement/Element} el The id of the node, a DOM node or an existing Element
     * @return {Roo.form.Field} this
     */
    applyTo : function(D){
        this.allowDomMove = false;
        this.el = Roo.get(D);
        this.render(this.el.dom.parentNode);
        return  this;
    },

    // private
    initValue : function(){
        if(this.value !== undefined){
            this.setValue(this.value);
        }else  if(this.el.dom.value.length > 0){
            this.setValue(this.el.dom.value);
        }
    },

    /**
     * Returns true if this field has been changed since it was originally loaded and is not disabled.
     */
    isDirty : function() {
        if(this.disabled) {
            return  false;
        }
        return  String(this.getValue()) !== String(this.originalValue);
    },

    // private
    afterRender : function(){
        Roo.form.Field.superclass.afterRender.call(this);
        this.initEvents();
    },

    // private
    fireKey : function(e){
        if(e.isNavKeyPress()){
            this.fireEvent("specialkey", this, e);
        }
    },

    /**
     * Resets the current field value to the originally loaded value and clears any validation messages
     */
    reset : function(){
        this.setValue(this.originalValue);
        this.clearInvalid();
    },

    // private
    initEvents : function(){
        this.el.on(Roo.isIE ? "keydown" : "keypress", this.fireKey,  this);
        this.el.on("focus", this.onFocus,  this);
        this.el.on("blur", this.onBlur,  this);

        // reference to original value for reset
        this.originalValue = this.getValue();
    },

    // private
    onFocus : function(){
        if(!Roo.isOpera && this.focusClass){ // don't touch in Opera
            this.el.addClass(this.focusClass);
        }
        if(!this.hasFocus){
            this.hasFocus = true;
            this.startValue = this.getValue();
            this.fireEvent("focus", this);
        }
    },

    beforeBlur : Roo.emptyFn,

    // private
    onBlur : function(){
        this.beforeBlur();
        if(!Roo.isOpera && this.focusClass){ // don't touch in Opera
            this.el.removeClass(this.focusClass);
        }

        this.hasFocus = false;
        if(this.validationEvent !== false && this.validateOnBlur && this.validationEvent != "blur"){
            this.validate();
        }
        var  v = this.getValue();
        if(String(v) !== String(this.startValue)){
            this.fireEvent('change', this, v, this.startValue);
        }

        this.fireEvent("blur", this);
    },

    /**
     * Returns whether or not the field value is currently valid
     * @param {Boolean} preventMark True to disable marking the field invalid
     * @return {Boolean} True if the value is valid, else false
     */
    isValid : function(E){
        if(this.disabled){
            return  true;
        }
        var  F = this.preventMark;
        this.preventMark = E === true;
        var  v = this.validateValue(this.processValue(this.getRawValue()));
        this.preventMark = F;
        return  v;
    },

    /**
     * Validates the field value
     * @return {Boolean} True if the value is valid, else false
     */
    validate : function(){
        if(this.disabled || this.validateValue(this.processValue(this.getRawValue()))){
            this.clearInvalid();
            return  true;
        }
        return  false;
    },

    processValue : function(G){
        return  G;
    },

    // private
    // Subclasses should provide the validation implementation by overriding this
    validateValue : function(H){
        return  true;
    },

    /**
     * Mark this field as invalid
     * @param {String} msg The validation message
     */
    markInvalid : function(I){
        if(!this.rendered || this.preventMark){ // not rendered
            return;
        }

        this.el.addClass(this.invalidClass);
        I = I || this.invalidText;
        switch(this.msgTarget){
            case  'qtip':
                this.el.dom.qtip = I;
                this.el.dom.qclass = 'x-form-invalid-tip';
                if(Roo.QuickTips){ // fix for floating editors interacting with DND
                    Roo.QuickTips.enable();
                }
                break;
            case  'title':
                this.el.dom.title = I;
                break;
            case  'under':
                if(!this.errorEl){
                    var  elp = this.el.findParent('.x-form-element', 5, true);
                    this.errorEl = elp.createChild({cls:'x-form-invalid-msg'});
                    this.errorEl.setWidth(elp.getWidth(true)-20);
                }

                this.errorEl.update(I);
                Roo.form.Field.msgFx[this.msgFx].show(this.errorEl, this);
                break;
            case  'side':
                if(!this.errorIcon){
                    var  elp = this.el.findParent('.x-form-element', 5, true);
                    this.errorIcon = elp.createChild({cls:'x-form-invalid-icon'});
                }

                this.alignErrorIcon();
                this.errorIcon.dom.qtip = I;
                this.errorIcon.dom.qclass = 'x-form-invalid-tip';
                this.errorIcon.show();
                this.on('resize', this.alignErrorIcon, this);
                break;
            default:
                var  t = Roo.getDom(this.msgTarget);
                t.innerHTML = I;
                t.style.display = this.msgDisplay;
                break;
        }

        this.fireEvent('invalid', this, I);
    },

    // private
    alignErrorIcon : function(){
        this.errorIcon.alignTo(this.el, 'tl-tr', [2, 0]);
    },

    /**
     * Clear any invalid styles/messages for this field
     */
    clearInvalid : function(){
        if(!this.rendered || this.preventMark){ // not rendered
            return;
        }

        this.el.removeClass(this.invalidClass);
        switch(this.msgTarget){
            case  'qtip':
                this.el.dom.qtip = '';
                break;
            case  'title':
                this.el.dom.title = '';
                break;
            case  'under':
                if(this.errorEl){
                    Roo.form.Field.msgFx[this.msgFx].hide(this.errorEl, this);
                }
                break;
            case  'side':
                if(this.errorIcon){
                    this.errorIcon.dom.qtip = '';
                    this.errorIcon.hide();
                    this.un('resize', this.alignErrorIcon, this);
                }
                break;
            default:
                var  t = Roo.getDom(this.msgTarget);
                t.innerHTML = '';
                t.style.display = 'none';
                break;
        }

        this.fireEvent('valid', this);
    },

    /**
     * Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see {@link #getValue}.
     * @return {Mixed} value The field value
     */
    getRawValue : function(){
        var  v = this.el.getValue();
        if(v === this.emptyText){
            v = '';
        }
        return  v;
    },

    /**
     * Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see {@link #getRawValue}.
     * @return {Mixed} value The field value
     */
    getValue : function(){
        var  v = this.el.getValue();
        if(v === this.emptyText || v === undefined){
            v = '';
        }
        return  v;
    },

    /**
     * Sets the underlying DOM field's value directly, bypassing validation.  To set the value with validation see {@link #setValue}.
     * @param {Mixed} value The value to set
     */
    setRawValue : function(v){
        return  this.el.dom.value = (v === null || v === undefined ? '' : v);
    },

    /**
     * Sets a data value into the field and validates it.  To set the value directly without validation see {@link #setRawValue}.
     * @param {Mixed} value The value to set
     */
    setValue : function(v){
        this.value = v;
        if(this.rendered){
            this.el.dom.value = (v === null || v === undefined ? '' : v);
            this.validate();
        }
    },

    adjustSize : function(w, h){
        var  s = Roo.form.Field.superclass.adjustSize.call(this, w, h);
        s.width = this.adjustWidth(this.el.dom.tagName, s.width);
        return  s;
    },

    adjustWidth : function(J, w){
        J = J.toLowerCase();
        if(typeof  w == 'number' && Roo.isStrict && !Roo.isSafari){
            if(Roo.isIE && (J == 'input' || J == 'textarea')){
                if(J == 'input'){
                    return  w + 2;
                }
                if(J = 'textarea'){
                    return  w-2;
                }
            }else  if(Roo.isOpera){
                if(J == 'input'){
                    return  w + 2;
                }
                if(J = 'textarea'){
                    return  w-2;
                }
            }
        }
        return  w;
    }
});


// anything other than normal should be considered experimental
Roo.form.Field.msgFx = {
    normal : {
        show: function(K, f){
            K.setDisplayed('block');
        },

        hide : function(L, f){
            L.setDisplayed(false).update('');
        }
    },

    slide : {
        show: function(M, f){
            M.slideIn('t', {stopFx:true});
        },

        hide : function(N, f){
            N.slideOut('t', {stopFx:true,useDisplay:true});
        }
    },

    slideRight : {
        show: function(O, f){
            O.fixDisplay();
            O.alignTo(f.el, 'tl-tr');
            O.slideIn('l', {stopFx:true});
        },

        hide : function(P, f){
            P.slideOut('l', {stopFx:true,useDisplay:true});
        }
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.form.TextField
 * @extends Roo.form.Field
 * Basic text field.  Can be used as a direct replacement for traditional text inputs, or as the base
 * class for more sophisticated input controls (like {@link Roo.form.TextArea} and {@link Roo.form.ComboBox}).
 * @constructor
 * Creates a new TextField
 * @param {Object} config Configuration options
 */
Roo.form.TextField = function(A){
    Roo.form.TextField.superclass.constructor.call(this, A);
    this.addEvents({
        /**
         * @event autosize
         * Fires when the autosize function is triggered.  The field may or may not have actually changed size
         * according to the default logic, but this event provides a hook for the developer to apply additional
         * logic at runtime to resize the field if needed.
	     * @param {Roo.form.Field} this This text field
	     * @param {Number} width The new field width
	     */
        autosize : true
    });
};

Roo.extend(Roo.form.TextField, Roo.form.Field,  {
    /**
     * @cfg {Boolean} grow True if this field should automatically grow and shrink to its content
     */
    grow : false,
    /**
     * @cfg {Number} growMin The minimum width to allow when grow = true (defaults to 30)
     */
    growMin : 30,
    /**
     * @cfg {Number} growMax The maximum width to allow when grow = true (defaults to 800)
     */
    growMax : 800,
    /**
     * @cfg {String} vtype A validation type name as defined in {@link Roo.form.VTypes} (defaults to null)
     */
    vtype : null,
    /**
     * @cfg {String} maskRe An input mask regular expression that will be used to filter keystrokes that don't match (defaults to null)
     */
    maskRe : null,
    /**
     * @cfg {Boolean} disableKeyFilter True to disable input keystroke filtering (defaults to false)
     */
    disableKeyFilter : false,
    /**
     * @cfg {Boolean} allowBlank False to validate that the value length > 0 (defaults to true)
     */
    allowBlank : true,
    /**
     * @cfg {Number} minLength Minimum input field length required (defaults to 0)
     */
    minLength : 0,
    /**
     * @cfg {Number} maxLength Maximum input field length allowed (defaults to Number.MAX_VALUE)
     */
    maxLength : Number.MAX_VALUE,
    /**
     * @cfg {String} minLengthText Error text to display if the minimum length validation fails (defaults to "The minimum length for this field is {minLength}")
     */
    minLengthText : "The minimum length for this field is {0}",
    /**
     * @cfg {String} maxLengthText Error text to display if the maximum length validation fails (defaults to "The maximum length for this field is {maxLength}")
     */
    maxLengthText : "The maximum length for this field is {0}",
    /**
     * @cfg {Boolean} selectOnFocus True to automatically select any existing field text when the field receives input focus (defaults to false)
     */
    selectOnFocus : false,
    /**
     * @cfg {String} blankText Error text to display if the allow blank validation fails (defaults to "This field is required")
     */
    blankText : "This field is required",
    /**
     * @cfg {Function} validator A custom validation function to be called during field validation (defaults to null).
     * If available, this function will be called only after the basic validators all return true, and will be passed the
     * current field value and expected to return boolean true if the value is valid or a string error message if invalid.
     */
    validator : null,
    /**
     * @cfg {RegExp} regex A JavaScript RegExp object to be tested against the field value during validation (defaults to null).
     * If available, this regex will be evaluated only after the basic validators all return true, and will be passed the
     * current field value.  If the test fails, the field will be marked invalid using {@link #regexText}.
     */
    regex : null,
    /**
     * @cfg {String} regexText The error text to display if {@link #regex} is used and the test fails during validation (defaults to "")
     */
    regexText : "",
    /**
     * @cfg {String} emptyText The default text to display in an empty field (defaults to null).
     */
    emptyText : null,
    /**
     * @cfg {String} emptyClass The CSS class to apply to an empty field to style the {@link #emptyText} (defaults to
     * 'x-form-empty-field').  This class is automatically added and removed as needed depending on the current field value.
     */
    emptyClass : 'x-form-empty-field',

    // private
    initEvents : function(){
        Roo.form.TextField.superclass.initEvents.call(this);
        if(this.validationEvent == 'keyup'){
            this.validationTask = new  Roo.util.DelayedTask(this.validate, this);
            this.el.on('keyup', this.filterValidation, this);
        }
        else  if(this.validationEvent !== false){
            this.el.on(this.validationEvent, this.validate, this, {buffer: this.validationDelay});
        }
        if(this.selectOnFocus || this.emptyText){
            this.on("focus", this.preFocus, this);
            if(this.emptyText){
                this.on('blur', this.postBlur, this);
                this.applyEmptyText();
            }
        }
        if(this.maskRe || (this.vtype && this.disableKeyFilter !== true && (this.maskRe = Roo.form.VTypes[this.vtype+'Mask']))){
            this.el.on("keypress", this.filterKeys, this);
        }
        if(this.grow){
            this.el.on("keyup", this.onKeyUp,  this, {buffer:50});
            this.el.on("click", this.autoSize,  this);
        }
    },

    processValue : function(B){
        if(this.stripCharsRe){
            var  newValue = B.replace(this.stripCharsRe, '');
            if(newValue !== B){
                this.setRawValue(newValue);
                return  newValue;
            }
        }
        return  B;
    },

    filterValidation : function(e){
        if(!e.isNavKeyPress()){
            this.validationTask.delay(this.validationDelay);
        }
    },

    // private
    onKeyUp : function(e){
        if(!e.isNavKeyPress()){
            this.autoSize();
        }
    },

    /**
     * Resets the current field value to the originally-loaded value and clears any validation messages.
     * Also adds emptyText and emptyClass if the original value was blank.
     */
    reset : function(){
        Roo.form.TextField.superclass.reset.call(this);
        this.applyEmptyText();
    },

    applyEmptyText : function(){
        if(this.rendered && this.emptyText && this.getRawValue().length < 1){
            this.setRawValue(this.emptyText);
            this.el.addClass(this.emptyClass);
        }
    },

    // private
    preFocus : function(){
        if(this.emptyText){
            if(this.el.dom.value == this.emptyText){
                this.setRawValue('');
            }

            this.el.removeClass(this.emptyClass);
        }
        if(this.selectOnFocus){
            this.el.dom.select();
        }
    },

    // private
    postBlur : function(){
        this.applyEmptyText();
    },

    // private
    filterKeys : function(e){
        var  k = e.getKey();
        if(!Roo.isIE && (e.isNavKeyPress() || k == e.BACKSPACE || (k == e.DELETE  && e.button == -1))){
            return;
        }
        var  c = e.getCharCode(), cc = String.fromCharCode(c);
        if(Roo.isIE && (e.isSpecialKey() || !cc)){
            return;
        }
        if(!this.maskRe.test(cc)){
            e.stopEvent();
        }
    },

    setValue : function(v){
        if(this.emptyText && this.el && v !== undefined && v !== null && v !== ''){
            this.el.removeClass(this.emptyClass);
        }

        Roo.form.TextField.superclass.setValue.apply(this, arguments);
        this.applyEmptyText();
        this.autoSize();
    },

    /**
     * Validates a value according to the field's validation rules and marks the field as invalid
     * if the validation fails
     * @param {Mixed} value The value to validate
     * @return {Boolean} True if the value is valid, else false
     */
    validateValue : function(C){
        if(C.length < 1 || C === this.emptyText){ // if it's blank
             if(this.allowBlank){
                this.clearInvalid();
                return  true;
             }else {
                this.markInvalid(this.blankText);
                return  false;
             }
        }
        if(C.length < this.minLength){
            this.markInvalid(String.format(this.minLengthText, this.minLength));
            return  false;
        }
        if(C.length > this.maxLength){
            this.markInvalid(String.format(this.maxLengthText, this.maxLength));
            return  false;
        }
        if(this.vtype){
            var  vt = Roo.form.VTypes;
            if(!vt[this.vtype](C, this)){
                this.markInvalid(this.vtypeText || vt[this.vtype +'Text']);
                return  false;
            }
        }
        if(typeof  this.validator == "function"){
            var  msg = this.validator(C);
            if(msg !== true){
                this.markInvalid(msg);
                return  false;
            }
        }
        if(this.regex && !this.regex.test(C)){
            this.markInvalid(this.regexText);
            return  false;
        }
        return  true;
    },

    /**
     * Selects text in this field
     * @param {Number} start (optional) The index where the selection should start (defaults to 0)
     * @param {Number} end (optional) The index where the selection should end (defaults to the text length)
     */
    selectText : function(D, E){
        var  v = this.getRawValue();
        if(v.length > 0){
            D = D === undefined ? 0 : D;
            E = E === undefined ? v.length : E;
            var  d = this.el.dom;
            if(d.setSelectionRange){
                d.setSelectionRange(D, E);
            }else  if(d.createTextRange){
                var  range = d.createTextRange();
                range.moveStart("character", D);
                range.moveEnd("character", v.length-E);
                range.select();
            }
        }
    },

    /**
     * Automatically grows the field to accomodate the width of the text up to the maximum field width allowed.
     * This only takes effect if grow = true, and fires the autosize event.
     */
    autoSize : function(){
        if(!this.grow || !this.rendered){
            return;
        }
        if(!this.metrics){
            this.metrics = Roo.util.TextMetrics.createInstance(this.el);
        }
        var  el = this.el;
        var  v = el.dom.value;
        var  d = document.createElement('div');
        d.appendChild(document.createTextNode(v));
        v = d.innerHTML;
        d = null;
        v += "&#160;";
        var  w = Math.min(this.growMax, Math.max(this.metrics.getWidth(v) + /* add extra padding */ 10, this.growMin));
        this.el.setWidth(w);
        this.fireEvent("autosize", this, w);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.Hidden
 * @extends Roo.form.TextField
 * Simple Hidden element used on forms 
 * 
 * usage: form.add(new Roo.form.HiddenField({ 'name' : 'test1' }));
 * 
 * @constructor
 * Creates a new Hidden form element.
 * @param {Object} config Configuration options
 */



// easy hidden field...
Roo.form.Hidden = function(A){
    Roo.form.Hidden.superclass.constructor.call(this, A);
};
  
Roo.extend(Roo.form.Hidden, Roo.form.TextField, {
    fieldLabel:      '',
    inputType:      'hidden',
    width:          50,
    allowBlank:     true,
    labelSeparator: '',
    hidden:         true,
    itemCls :       'x-form-item-display-none'


});



/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.TriggerField
 * @extends Roo.form.TextField
 * Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default).
 * The trigger has no default action, so you must assign a function to implement the trigger click handler by
 * overriding {@link #onTriggerClick}. You can create a TriggerField directly, as it renders exactly like a combobox
 * for which you can provide a custom implementation.  For example:
 * <pre><code>
var trigger = new Roo.form.TriggerField();
trigger.onTriggerClick = myTriggerFn;
trigger.applyTo('my-field');
</code></pre>
 *
 * However, in general you will most likely want to use TriggerField as the base class for a reusable component.
 * {@link Roo.form.DateField} and {@link Roo.form.ComboBox} are perfect examples of this.
 * @cfg {String} triggerClass An additional CSS class used to style the trigger button.  The trigger will always get the
 * class 'x-form-trigger' by default and triggerClass will be <b>appended</b> if specified.
 * @constructor
 * Create a new TriggerField.
 * @param {Object} config Configuration options (valid {@Roo.form.TextField} config options will also be applied
 * to the base TextField)
 */
Roo.form.TriggerField = function(A){
    this.mimicing = false;
    Roo.form.TriggerField.superclass.constructor.call(this, A);
};

Roo.extend(Roo.form.TriggerField, Roo.form.TextField,  {
    /**
     * @cfg {String} triggerClass A CSS class to apply to the trigger
     */
    /**
     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "text", size: "16", autocomplete: "off"})
     */
    defaultAutoCreate : {tag: "input", type: "text", size: "16", autocomplete: "off"},
    /**
     * @cfg {Boolean} hideTrigger True to hide the trigger element and display only the base text field (defaults to false)
     */
    hideTrigger:false,

    /** @cfg {Boolean} grow @hide */
    /** @cfg {Number} growMin @hide */
    /** @cfg {Number} growMax @hide */

    /**
     * @hide 
     * @method
     */
    autoSize: Roo.emptyFn,
    // private
    monitorTab : true,
    // private
    deferHeight : true,

    
    actionMode : 'wrap',
    // private
    onResize : function(w, h){
        Roo.form.TriggerField.superclass.onResize.apply(this, arguments);
        if(typeof  w == 'number'){
            this.el.setWidth(this.adjustWidth('input', w - this.trigger.getWidth()));
        }
    },

    // private
    adjustSize : Roo.BoxComponent.prototype.adjustSize,

    // private
    getResizeEl : function(){
        return  this.wrap;
    },

    // private
    getPositionEl : function(){
        return  this.wrap;
    },

    // private
    alignErrorIcon : function(){
        this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
    },

    // private
    onRender : function(ct, B){
        Roo.form.TriggerField.superclass.onRender.call(this, ct, B);
        this.wrap = this.el.wrap({cls: "x-form-field-wrap"});
        this.trigger = this.wrap.createChild(this.triggerConfig ||
                {tag: "img", src: Roo.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass});
        if(this.hideTrigger){
            this.trigger.setDisplayed(false);
        }

        this.initTrigger();
        if(!this.width){
            this.wrap.setWidth(this.el.getWidth()+this.trigger.getWidth());
        }
    },

    // private
    initTrigger : function(){
        this.trigger.on("click", this.onTriggerClick, this, {preventDefault:true});
        this.trigger.addClassOnOver('x-form-trigger-over');
        this.trigger.addClassOnClick('x-form-trigger-click');
    },

    // private
    onDestroy : function(){
        if(this.trigger){
            this.trigger.removeAllListeners();
            this.trigger.remove();
        }
        if(this.wrap){
            this.wrap.remove();
        }

        Roo.form.TriggerField.superclass.onDestroy.call(this);
    },

    // private
    onFocus : function(){
        Roo.form.TriggerField.superclass.onFocus.call(this);
        if(!this.mimicing){
            this.wrap.addClass('x-trigger-wrap-focus');
            this.mimicing = true;
            Roo.get(Roo.isIE ? document.body : document).on("mousedown", this.mimicBlur, this);
            if(this.monitorTab){
                this.el.on("keydown", this.checkTab, this);
            }
        }
    },

    // private
    checkTab : function(e){
        if(e.getKey() == e.TAB){
            this.triggerBlur();
        }
    },

    // private
    onBlur : function(){
        // do nothing
    },

    // private
    mimicBlur : function(e, t){
        if(!this.wrap.contains(t) && this.validateBlur()){
            this.triggerBlur();
        }
    },

    // private
    triggerBlur : function(){
        this.mimicing = false;
        Roo.get(Roo.isIE ? document.body : document).un("mousedown", this.mimicBlur);
        if(this.monitorTab){
            this.el.un("keydown", this.checkTab, this);
        }

        this.wrap.removeClass('x-trigger-wrap-focus');
        Roo.form.TriggerField.superclass.onBlur.call(this);
    },

    // private
    // This should be overriden by any subclass that needs to check whether or not the field can be blurred.
    validateBlur : function(e, t){
        return  true;
    },

    // private
    onDisable : function(){
        Roo.form.TriggerField.superclass.onDisable.call(this);
        if(this.wrap){
            this.wrap.addClass('x-item-disabled');
        }
    },

    // private
    onEnable : function(){
        Roo.form.TriggerField.superclass.onEnable.call(this);
        if(this.wrap){
            this.wrap.removeClass('x-item-disabled');
        }
    },

    // private
    onShow : function(){
        var  ae = this.getActionEl();
        
        if(ae){
            ae.dom.style.display = '';
            ae.dom.style.visibility = 'visible';
        }
    },

    // private
    
    onHide : function(){
        var  ae = this.getActionEl();
        ae.dom.style.display = 'none';
    },

    /**
     * The function that should handle the trigger's click event.  This method does nothing by default until overridden
     * by an implementing function.
     * @method
     * @param {EventObject} e
     */
    onTriggerClick : Roo.emptyFn
});

// TwinTriggerField is not a public class to be used directly.  It is meant as an abstract base class
// to be extended by an implementing class.  For an example of implementing this class, see the custom
// SearchField implementation here: http://extjs.com/deploy/ext/examples/form/custom.html
Roo.form.TwinTriggerField = Roo.extend(Roo.form.TriggerField, {
    initComponent : function(){
        Roo.form.TwinTriggerField.superclass.initComponent.call(this);

        this.triggerConfig = {
            tag:'span', cls:'x-form-twin-triggers', cn:[
            {tag: "img", src: Roo.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.trigger1Class},
            {tag: "img", src: Roo.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.trigger2Class}
        ]};
    },

    getTrigger : function(C){
        return  this.triggers[C];
    },

    initTrigger : function(){
        var  ts = this.trigger.select('.x-form-trigger', true);
        this.wrap.setStyle('overflow', 'hidden');
        var  D = this;
        ts.each(function(t, E, F){
            t.hide = function(){
                var  w = D.wrap.getWidth();
                this.dom.style.display = 'none';
                D.el.setWidth(w-D.trigger.getWidth());
            };
            t.show = function(){
                var  w = D.wrap.getWidth();
                this.dom.style.display = '';
                D.el.setWidth(w-D.trigger.getWidth());
            };
            var  G = 'Trigger'+(F+1);

            if(this['hide'+G]){
                t.dom.style.display = 'none';
            }

            t.on("click", this['on'+G+'Click'], this, {preventDefault:true});
            t.addClassOnOver('x-form-trigger-over');
            t.addClassOnClick('x-form-trigger-click');
        }, this);
        this.triggers = ts.elements;
    },

    onTrigger1Click : Roo.emptyFn,
    onTrigger2Click : Roo.emptyFn
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.TextArea
 * @extends Roo.form.TextField
 * Multiline text field.  Can be used as a direct replacement for traditional textarea fields, plus adds
 * support for auto-sizing.
 * @constructor
 * Creates a new TextArea
 * @param {Object} config Configuration options
 */
Roo.form.TextArea = function(A){
    Roo.form.TextArea.superclass.constructor.call(this, A);
    // these are provided exchanges for backwards compat
    // minHeight/maxHeight were replaced by growMin/growMax to be
    // compatible with TextField growing config values
    if(this.minHeight !== undefined){
        this.growMin = this.minHeight;
    }
    if(this.maxHeight !== undefined){
        this.growMax = this.maxHeight;
    }
};

Roo.extend(Roo.form.TextArea, Roo.form.TextField,  {
    /**
     * @cfg {Number} growMin The minimum height to allow when grow = true (defaults to 60)
     */
    growMin : 60,
    /**
     * @cfg {Number} growMax The maximum height to allow when grow = true (defaults to 1000)
     */
    growMax: 1000,
    /**
     * @cfg {Boolean} preventScrollbars True to prevent scrollbars from appearing regardless of how much text is
     * in the field (equivalent to setting overflow: hidden, defaults to false)
     */
    preventScrollbars: false,
    /**
     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "textarea", style: "width:300px;height:60px;", autocomplete: "off"})
     */

    // private
    onRender : function(ct, B){
        if(!this.el){
            this.defaultAutoCreate = {
                tag: "textarea",
                style:"width:300px;height:60px;",
                autocomplete: "off"
            };
        }

        Roo.form.TextArea.superclass.onRender.call(this, ct, B);
        if(this.grow){
            this.textSizeEl = Roo.DomHelper.append(document.body, {
                tag: "pre", cls: "x-form-grow-sizer"
            });
            if(this.preventScrollbars){
                this.el.setStyle("overflow", "hidden");
            }

            this.el.setHeight(this.growMin);
        }
    },

    onDestroy : function(){
        if(this.textSizeEl){
            this.textSizeEl.parentNode.removeChild(this.textSizeEl);
        }

        Roo.form.TextArea.superclass.onDestroy.call(this);
    },

    // private
    onKeyUp : function(e){
        if(!e.isNavKeyPress() || e.getKey() == e.ENTER){
            this.autoSize();
        }
    },

    /**
     * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
     * This only takes effect if grow = true, and fires the autosize event if the height changes.
     */
    autoSize : function(){
        if(!this.grow || !this.textSizeEl){
            return;
        }
        var  el = this.el;
        var  v = el.dom.value;
        var  ts = this.textSizeEl;

        ts.innerHTML = '';
        ts.appendChild(document.createTextNode(v));
        v = ts.innerHTML;

        Roo.fly(ts).setWidth(this.el.getWidth());
        if(v.length < 1){
            v = "&#160;&#160;";
        }else {
            if(Roo.isIE){
                v = v.replace(/\n/g, '<p>&#160;</p>');
            }

            v += "&#160;\n&#160;";
        }

        ts.innerHTML = v;
        var  h = Math.min(this.growMax, Math.max(ts.offsetHeight, this.growMin));
        if(h != this.lastHeight){
            this.lastHeight = h;
            this.el.setHeight(h);
            this.fireEvent("autosize", this, h);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.form.NumberField
 * @extends Roo.form.TextField
 * Numeric text field that provides automatic keystroke filtering and numeric validation.
 * @constructor
 * Creates a new NumberField
 * @param {Object} config Configuration options
 */
Roo.form.NumberField = function(A){
    Roo.form.NumberField.superclass.constructor.call(this, A);
};

Roo.extend(Roo.form.NumberField, Roo.form.TextField,  {
    /**
     * @cfg {String} fieldClass The default CSS class for the field (defaults to "x-form-field x-form-num-field")
     */
    fieldClass: "x-form-field x-form-num-field",
    /**
     * @cfg {Boolean} allowDecimals False to disallow decimal values (defaults to true)
     */
    allowDecimals : true,
    /**
     * @cfg {String} decimalSeparator Character(s) to allow as the decimal separator (defaults to '.')
     */
    decimalSeparator : ".",
    /**
     * @cfg {Number} decimalPrecision The maximum precision to display after the decimal separator (defaults to 2)
     */
    decimalPrecision : 2,
    /**
     * @cfg {Boolean} allowNegative False to prevent entering a negative sign (defaults to true)
     */
    allowNegative : true,
    /**
     * @cfg {Number} minValue The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)
     */
    minValue : Number.NEGATIVE_INFINITY,
    /**
     * @cfg {Number} maxValue The maximum allowed value (defaults to Number.MAX_VALUE)
     */
    maxValue : Number.MAX_VALUE,
    /**
     * @cfg {String} minText Error text to display if the minimum value validation fails (defaults to "The minimum value for this field is {minValue}")
     */
    minText : "The minimum value for this field is {0}",
    /**
     * @cfg {String} maxText Error text to display if the maximum value validation fails (defaults to "The maximum value for this field is {maxValue}")
     */
    maxText : "The maximum value for this field is {0}",
    /**
     * @cfg {String} nanText Error text to display if the value is not a valid number.  For example, this can happen
     * if a valid character like '.' or '-' is left in the field with no number (defaults to "{value} is not a valid number")
     */
    nanText : "{0} is not a valid number",

    // private
    initEvents : function(){
        Roo.form.NumberField.superclass.initEvents.call(this);
        var  B = "0123456789";
        if(this.allowDecimals){
            B += this.decimalSeparator;
        }
        if(this.allowNegative){
            B += "-";
        }

        this.stripCharsRe = new  RegExp('[^'+B+']', 'gi');
        var  C = function(e){
            var  k = e.getKey();
            if(!Roo.isIE && (e.isSpecialKey() || k == e.BACKSPACE || k == e.DELETE )){
                return;
            }
            var  c = e.getCharCode();
            if(B.indexOf(String.fromCharCode(c)) === -1){
                e.stopEvent();
            }
        };
        this.el.on("keypress", C, this);
    },

    // private
    validateValue : function(D){
        if(!Roo.form.NumberField.superclass.validateValue.call(this, D)){
            return  false;
        }
        if(D.length < 1){ // if it's blank and textfield didn't flag it then it's valid
             return  true;
        }
        var  E = this.parseValue(D);
        if(isNaN(E)){
            this.markInvalid(String.format(this.nanText, D));
            return  false;
        }
        if(E < this.minValue){
            this.markInvalid(String.format(this.minText, this.minValue));
            return  false;
        }
        if(E > this.maxValue){
            this.markInvalid(String.format(this.maxText, this.maxValue));
            return  false;
        }
        return  true;
    },

    getValue : function(){
        return  this.fixPrecision(this.parseValue(Roo.form.NumberField.superclass.getValue.call(this)));
    },

    // private
    parseValue : function(F){
        F = parseFloat(String(F).replace(this.decimalSeparator, "."));
        return  isNaN(F) ? '' : F;
    },

    // private
    fixPrecision : function(G){
        var  H = isNaN(G);
        if(!this.allowDecimals || this.decimalPrecision == -1 || H || !G){
            return  H ? '' : G;
        }
        return  parseFloat(G).toFixed(this.decimalPrecision);
    },

    setValue : function(v){
        Roo.form.NumberField.superclass.setValue.call(this, String(v).replace(".", this.decimalSeparator));
    },

    // private
    decimalPrecisionFcn : function(v){
        return  Math.floor(v);
    },

    beforeBlur : function(){
        var  v = this.parseValue(this.getRawValue());
        if(v){
            this.setValue(this.fixPrecision(v));
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.DateField
 * @extends Roo.form.TriggerField
 * Provides a date input field with a {@link Roo.DatePicker} dropdown and automatic date validation.
* @constructor
* Create a new DateField
* @param {Object} config
 */
Roo.form.DateField = function(A){
    Roo.form.DateField.superclass.constructor.call(this, A);
    
      this.addEvents({
         
        /**
         * @event select
         * Fires when a date is selected
	     * @param {Roo.form.DateField} combo This combo box
	     * @param {Date} date The date selected
	     */
        'select' : true
         
    });
    
    
    if(typeof  this.minValue == "string") this.minValue = this.parseDate(this.minValue);
    if(typeof  this.maxValue == "string") this.maxValue = this.parseDate(this.maxValue);
    this.ddMatch = null;
    if(this.disabledDates){
        var  dd = this.disabledDates;
        var  re = "(?:";
        for(var  i = 0; i < dd.length; i++){
            re += dd[i];
            if(i != dd.length-1) re += "|";
        }

        this.ddMatch = new  RegExp(re + ")");
    }
};

Roo.extend(Roo.form.DateField, Roo.form.TriggerField,  {
    /**
     * @cfg {String} format
     * The default date format string which can be overriden for localization support.  The format must be
     * valid according to {@link Date#parseDate} (defaults to 'm/d/y').
     */
    format : "m/d/y",
    /**
     * @cfg {String} altFormats
     * Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined
     * format (defaults to 'm/d/Y|m-d-y|m-d-Y|m/d|m-d|d').
     */
    altFormats : "m/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d",
    /**
     * @cfg {Array} disabledDays
     * An array of days to disable, 0 based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
     */
    disabledDays : null,
    /**
     * @cfg {String} disabledDaysText
     * The tooltip to display when the date falls on a disabled day (defaults to 'Disabled')
     */
    disabledDaysText : "Disabled",
    /**
     * @cfg {Array} disabledDates
     * An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular
     * expression so they are very powerful. Some examples:
     * <ul>
     * <li>["03/08/2003", "09/16/2003"] would disable those exact dates</li>
     * <li>["03/08", "09/16"] would disable those days for every year</li>
     * <li>["^03/08"] would only match the beginning (useful if you are using short years)</li>
     * <li>["03/../2006"] would disable every day in March 2006</li>
     * <li>["^03"] would disable every day in every March</li>
     * </ul>
     * In order to support regular expressions, if you are using a date format that has "." in it, you will have to
     * escape the dot when restricting dates. For example: ["03\\.08\\.03"].
     */
    disabledDates : null,
    /**
     * @cfg {String} disabledDatesText
     * The tooltip text to display when the date falls on a disabled date (defaults to 'Disabled')
     */
    disabledDatesText : "Disabled",
    /**
     * @cfg {Date/String} minValue
     * The minimum allowed date. Can be either a Javascript date object or a string date in a
     * valid format (defaults to null).
     */
    minValue : null,
    /**
     * @cfg {Date/String} maxValue
     * The maximum allowed date. Can be either a Javascript date object or a string date in a
     * valid format (defaults to null).
     */
    maxValue : null,
    /**
     * @cfg {String} minText
     * The error text to display when the date in the cell is before minValue (defaults to
     * 'The date in this field must be after {minValue}').
     */
    minText : "The date in this field must be equal to or after {0}",
    /**
     * @cfg {String} maxText
     * The error text to display when the date in the cell is after maxValue (defaults to
     * 'The date in this field must be before {maxValue}').
     */
    maxText : "The date in this field must be equal to or before {0}",
    /**
     * @cfg {String} invalidText
     * The error text to display when the date in the field is invalid (defaults to
     * '{value} is not a valid date - it must be in the format {format}').
     */
    invalidText : "{0} is not a valid date - it must be in the format {1}",
    /**
     * @cfg {String} triggerClass
     * An additional CSS class used to style the trigger button.  The trigger will always get the
     * class 'x-form-trigger' and triggerClass will be <b>appended</b> if specified (defaults to 'x-form-date-trigger'
     * which displays a calendar icon).
     */
    triggerClass : 'x-form-date-trigger',
    

    /**
     * @cfg {bool} useIso
     * if enabled, then the date field will use a hidden field to store the 
     * real value as iso formated date. default (false)
     */ 
    useIso : false,
    /**
     * @cfg {String/Object} autoCreate
     * A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "text", size: "10", autocomplete: "off"})
     */ 
    // private
    defaultAutoCreate : {tag: "input", type: "text", size: "10", autocomplete: "off"},
    
    // private
    hiddenField: false,
    
    onRender : function(ct, B)
    {
        Roo.form.DateField.superclass.onRender.call(this, ct, B);
        if (this.useIso) {
            this.el.dom.removeAttribute('name'); 
            this.hiddenField = this.el.insertSibling({ tag:'input', type:'hidden', name: this.name },
                    'before', true);
            this.hiddenField.value = this.formatDate(this.value, 'Y-m-d');
            // prevent input submission
            this.hiddenName = this.name;
        }
            
            
    },
    
    // private
    validateValue : function(C)
    {
        C = this.formatDate(C);
        if(!Roo.form.DateField.superclass.validateValue.call(this, C)){
            return  false;
        }
        if(C.length < 1){ // if it's blank and textfield didn't flag it then it's valid
             return  true;
        }
        var  D = C;
        C = this.parseDate(C);
        if(!C){
            this.markInvalid(String.format(this.invalidText, D, this.format));
            return  false;
        }
        var  E = C.getTime();
        if(this.minValue && E < this.minValue.getTime()){
            this.markInvalid(String.format(this.minText, this.formatDate(this.minValue)));
            return  false;
        }
        if(this.maxValue && E > this.maxValue.getTime()){
            this.markInvalid(String.format(this.maxText, this.formatDate(this.maxValue)));
            return  false;
        }
        if(this.disabledDays){
            var  day = C.getDay();
            for(var  i = 0; i < this.disabledDays.length; i++) {
            	if(day === this.disabledDays[i]){
            	    this.markInvalid(this.disabledDaysText);
                    return  false;
            	}
            }
        }
        var  F = this.formatDate(C);
        if(this.ddMatch && this.ddMatch.test(F)){
            this.markInvalid(String.format(this.disabledDatesText, F));
            return  false;
        }
        return  true;
    },

    // private
    // Provides logic to override the default TriggerField.validateBlur which just returns true
    validateBlur : function(){
        return  !this.menu || !this.menu.isVisible();
    },

    /**
     * Returns the current date value of the date field.
     * @return {Date} The date value
     */
    getValue : function(){
        
        return   this.hiddenField ? this.hiddenField.value : this.parseDate(Roo.form.DateField.superclass.getValue.call(this)) || "";
    },

    /**
     * Sets the value of the date field.  You can pass a date object or any string that can be parsed into a valid
     * date, using DateField.format as the date format, according to the same rules as {@link Date#parseDate}
     * (the default format used is "m/d/y").
     * <br />Usage:
     * <pre><code>
//All of these calls set the same date value (May 4, 2006)

//Pass a date object:
var dt = new Date('5/4/06');
dateField.setValue(dt);

//Pass a date string (default format):
dateField.setValue('5/4/06');

//Pass a date string (custom format):
dateField.format = 'Y-m-d';
dateField.setValue('2006-5-4');
</code></pre>
     * @param {String/Date} date The date or valid date string
     */
    setValue : function(G){
        if (this.hiddenField) {
            this.hiddenField.value = this.formatDate(this.parseDate(G), 'Y-m-d');
        }

        Roo.form.DateField.superclass.setValue.call(this, this.formatDate(this.parseDate(G)));
    },

    // private
    parseDate : function(H){
        if(!H || H  instanceof  Date){
            return  H;
        }
        var  v = Date.parseDate(H, this.format);
        if(!v && this.altFormats){
            if(!this.altFormatsArray){
                this.altFormatsArray = this.altFormats.split("|");
            }
            for(var  i = 0, len = this.altFormatsArray.length; i < len && !v; i++){
                v = Date.parseDate(H, this.altFormatsArray[i]);
            }
        }
        return  v;
    },

    // private
    formatDate : function(I, J){
        return  (!I || !(I  instanceof  Date)) ?
               I : I.dateFormat(J || this.format);
    },

    // private
    menuListeners : {
        select: function(m, d){
            this.setValue(d);
            this.fireEvent('select', this, d);
        },
        show : function(){ // retain focus styling
            this.onFocus();
        },
        hide : function(){
            this.focus.defer(10, this);
            var  ml = this.menuListeners;
            this.menu.un("select", ml.select,  this);
            this.menu.un("show", ml.show,  this);
            this.menu.un("hide", ml.hide,  this);
        }
    },

    // private
    // Implements the default empty TriggerField.onTriggerClick function to display the DatePicker
    onTriggerClick : function(){
        if(this.disabled){
            return;
        }
        if(this.menu == null){
            this.menu = new  Roo.menu.DateMenu();
        }

        Roo.apply(this.menu.picker,  {
            showClear: this.allowBlank,
            minDate : this.minValue,
            maxDate : this.maxValue,
            disabledDatesRE : this.ddMatch,
            disabledDatesText : this.disabledDatesText,
            disabledDays : this.disabledDays,
            disabledDaysText : this.disabledDaysText,
            format : this.format,
            minText : String.format(this.minText, this.formatDate(this.minValue)),
            maxText : String.format(this.maxText, this.formatDate(this.maxValue))
        });
        this.menu.on(Roo.apply({}, this.menuListeners, {
            scope:this
        }));
        this.menu.picker.setValue(this.getValue() || new  Date());
        this.menu.show(this.el, "tl-bl?");
    },

    beforeBlur : function(){
        var  v = this.parseDate(this.getRawValue());
        if(v){
            this.setValue(v);
        }
    }

    /** @cfg {Boolean} grow @hide */
    /** @cfg {Number} growMin @hide */
    /** @cfg {Number} growMax @hide */
    /**
     * @hide
     * @method autoSize
     */
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.form.ComboBox
 * @extends Roo.form.TriggerField
 * A combobox control with support for autocomplete, remote-loading, paging and many other features.
 * @constructor
 * Create a new ComboBox.
 * @param {Object} config Configuration options
 */
Roo.form.ComboBox = function(A){
    Roo.form.ComboBox.superclass.constructor.call(this, A);
    this.addEvents({
        /**
         * @event expand
         * Fires when the dropdown list is expanded
	     * @param {Roo.form.ComboBox} combo This combo box
	     */
        'expand' : true,
        /**
         * @event collapse
         * Fires when the dropdown list is collapsed
	     * @param {Roo.form.ComboBox} combo This combo box
	     */
        'collapse' : true,
        /**
         * @event beforeselect
         * Fires before a list item is selected. Return false to cancel the selection.
	     * @param {Roo.form.ComboBox} combo This combo box
	     * @param {Roo.data.Record} record The data record returned from the underlying store
	     * @param {Number} index The index of the selected item in the dropdown list
	     */
        'beforeselect' : true,
        /**
         * @event select
         * Fires when a list item is selected
	     * @param {Roo.form.ComboBox} combo This combo box
	     * @param {Roo.data.Record} record The data record returned from the underlying store (or false on clear)
	     * @param {Number} index The index of the selected item in the dropdown list
	     */
        'select' : true,
        /**
         * @event beforequery
         * Fires before all queries are processed. Return false to cancel the query or set cancel to true.
         * The event object passed has these properties:
	     * @param {Roo.form.ComboBox} combo This combo box
	     * @param {String} query The query
	     * @param {Boolean} forceAll true to force "all" query
	     * @param {Boolean} cancel true to cancel the query
	     * @param {Object} e The query event object
	     */
        'beforequery': true
    });
    if(this.transform){
        this.allowDomMove = false;
        var  s = Roo.getDom(this.transform);
        if(!this.hiddenName){
            this.hiddenName = s.name;
        }
        if(!this.store){
            this.mode = 'local';
            var  d = [], opts = s.options;
            for(var  i = 0, len = opts.length;i < len; i++){
                var  o = opts[i];
                var  value = (Roo.isIE ? o.getAttributeNode('value').specified : o.hasAttribute('value')) ? o.value : o.text;
                if(o.selected) {
                    this.value = value;
                }

                d.push([value, o.text]);
            }

            this.store = new  Roo.data.SimpleStore({
                'id': 0,
                fields: ['value', 'text'],
                data : d
            });
            this.valueField = 'value';
            this.displayField = 'text';
        }

        s.name = Roo.id(); // wipe out the name in case somewhere else they have a reference
        if(!this.lazyRender){
            this.target = true;
            this.el = Roo.DomHelper.insertBefore(s, this.autoCreate || this.defaultAutoCreate);
            s.parentNode.removeChild(s); // remove it
            this.render(this.el.parentNode);
        }else {
            s.parentNode.removeChild(s); // remove it
        }

    }
    if (this.store) {
        this.store = Roo.factory(this.store, Roo.data);
    }

    
    this.selectedIndex = -1;
    if(this.mode == 'local'){
        if(A.queryDelay === undefined){
            this.queryDelay = 10;
        }
        if(A.minChars === undefined){
            this.minChars = 0;
        }
    }
};

Roo.extend(Roo.form.ComboBox, Roo.form.TriggerField, {
    /**
     * @cfg {String/HTMLElement/Element} transform The id, DOM node or element of an existing select to convert to a ComboBox
     */
    /**
     * @cfg {Boolean} lazyRender True to prevent the ComboBox from rendering until requested (should always be used when
     * rendering into an Roo.Editor, defaults to false)
     */
    /**
     * @cfg {Boolean/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to:
     * {tag: "input", type: "text", size: "24", autocomplete: "off"})
     */
    /**
     * @cfg {Roo.data.Store} store The data store to which this combo is bound (defaults to undefined)
     */
    /**
     * @cfg {String} title If supplied, a header element is created containing this text and added into the top of
     * the dropdown list (defaults to undefined, with no header element)
     */

     /**
     * @cfg {String/Roo.Template} tpl The template to use to render the output
     */
     
    // private
    defaultAutoCreate : {tag: "input", type: "text", size: "24", autocomplete: "off"},
    /**
     * @cfg {Number} listWidth The width in pixels of the dropdown list (defaults to the width of the ComboBox field)
     */
    listWidth: undefined,
    /**
     * @cfg {String} displayField The underlying data field name to bind to this CombBox (defaults to undefined if
     * mode = 'remote' or 'text' if mode = 'local')
     */
    displayField: undefined,
    /**
     * @cfg {String} valueField The underlying data value name to bind to this CombBox (defaults to undefined if
     * mode = 'remote' or 'value' if mode = 'local'). 
     * Note: use of a valueField requires the user make a selection
     * in order for a value to be mapped.
     */
    valueField: undefined,
    /**
     * @cfg {String} hiddenName If specified, a hidden form field with this name is dynamically generated to store the
     * field's data value (defaults to the underlying DOM element's name)
     */
    hiddenName: undefined,
    /**
     * @cfg {String} listClass CSS class to apply to the dropdown list element (defaults to '')
     */
    listClass: '',
    /**
     * @cfg {String} selectedClass CSS class to apply to the selected item in the dropdown list (defaults to 'x-combo-selected')
     */
    selectedClass: 'x-combo-selected',
    /**
     * @cfg {String} triggerClass An additional CSS class used to style the trigger button.  The trigger will always get the
     * class 'x-form-trigger' and triggerClass will be <b>appended</b> if specified (defaults to 'x-form-arrow-trigger'
     * which displays a downward arrow icon).
     */
    triggerClass : 'x-form-arrow-trigger',
    /**
     * @cfg {Boolean/String} shadow True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right
     */
    shadow:'sides',
    /**
     * @cfg {String} listAlign A valid anchor position value. See {@link Roo.Element#alignTo} for details on supported
     * anchor positions (defaults to 'tl-bl')
     */
    listAlign: 'tl-bl?',
    /**
     * @cfg {Number} maxHeight The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 300)
     */
    maxHeight: 300,
    /**
     * @cfg {String} triggerAction The action to execute when the trigger field is activated.  Use 'all' to run the
     * query specified by the allQuery config option (defaults to 'query')
     */
    triggerAction: 'query',
    /**
     * @cfg {Number} minChars The minimum number of characters the user must type before autocomplete and typeahead activate
     * (defaults to 4, does not apply if editable = false)
     */
    minChars : 4,
    /**
     * @cfg {Boolean} typeAhead True to populate and autoselect the remainder of the text being typed after a configurable
     * delay (typeAheadDelay) if it matches a known value (defaults to false)
     */
    typeAhead: false,
    /**
     * @cfg {Number} queryDelay The length of time in milliseconds to delay between the start of typing and sending the
     * query to filter the dropdown list (defaults to 500 if mode = 'remote' or 10 if mode = 'local')
     */
    queryDelay: 500,
    /**
     * @cfg {Number} pageSize If greater than 0, a paging toolbar is displayed in the footer of the dropdown list and the
     * filter queries will execute with page start and limit parameters.  Only applies when mode = 'remote' (defaults to 0)
     */
    pageSize: 0,
    /**
     * @cfg {Boolean} selectOnFocus True to select any existing text in the field immediately on focus.  Only applies
     * when editable = true (defaults to false)
     */
    selectOnFocus:false,
    /**
     * @cfg {String} queryParam Name of the query as it will be passed on the querystring (defaults to 'query')
     */
    queryParam: 'query',
    /**
     * @cfg {String} loadingText The text to display in the dropdown list while data is loading.  Only applies
     * when mode = 'remote' (defaults to 'Loading...')
     */
    loadingText: 'Loading...',
    /**
     * @cfg {Boolean} resizable True to add a resize handle to the bottom of the dropdown list (defaults to false)
     */
    resizable: false,
    /**
     * @cfg {Number} handleHeight The height in pixels of the dropdown list resize handle if resizable = true (defaults to 8)
     */
    handleHeight : 8,
    /**
     * @cfg {Boolean} editable False to prevent the user from typing text directly into the field, just like a
     * traditional select (defaults to true)
     */
    editable: true,
    /**
     * @cfg {String} allQuery The text query to send to the server to return all records for the list with no filtering (defaults to '')
     */
    allQuery: '',
    /**
     * @cfg {String} mode Set to 'local' if the ComboBox loads local data (defaults to 'remote' which loads from the server)
     */
    mode: 'remote',
    /**
     * @cfg {Number} minListWidth The minimum width of the dropdown list in pixels (defaults to 70, will be ignored if
     * listWidth has a higher value)
     */
    minListWidth : 70,
    /**
     * @cfg {Boolean} forceSelection True to restrict the selected value to one of the values in the list, false to
     * allow the user to set arbitrary text into the field (defaults to false)
     */
    forceSelection:false,
    /**
     * @cfg {Number} typeAheadDelay The length of time in milliseconds to wait until the typeahead text is displayed
     * if typeAhead = true (defaults to 250)
     */
    typeAheadDelay : 250,
    /**
     * @cfg {String} valueNotFoundText When using a name/value combo, if the value passed to setValue is not found in
     * the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined)
     */
    valueNotFoundText : undefined,
    /**
     * @cfg {bool} blockFocus Prevents all focus calls, so it can work with things like HTML edtor bar
     */
    blockFocus : false,
    
    /**
     * @cfg {bool} disableClear Disable showing of clear button.
     */
    disableClear : false,
    
    // private
    onRender : function(ct, B){
        Roo.form.ComboBox.superclass.onRender.call(this, ct, B);
        if(this.hiddenName){
            this.hiddenField = this.el.insertSibling({tag:'input', type:'hidden', name: this.hiddenName, id:  (this.hiddenId||this.hiddenName)},
                    'before', true);
            this.hiddenField.value =
                this.hiddenValue !== undefined ? this.hiddenValue :
                this.value !== undefined ? this.value : '';

            // prevent input submission
            this.el.dom.removeAttribute('name');
        }
        if(Roo.isGecko){
            this.el.dom.setAttribute('autocomplete', 'off');
        }

        var  C = 'x-combo-list';

        this.list = new  Roo.Layer({
            shadow: this.shadow, cls: [C, this.listClass].join(' '), constrain:false
        });

        var  lw = this.listWidth || Math.max(this.wrap.getWidth(), this.minListWidth);
        this.list.setWidth(lw);
        this.list.swallowEvent('mousewheel');
        this.assetHeight = 0;

        if(this.title){
            this.header = this.list.createChild({cls:C+'-hd', html: this.title});
            this.assetHeight += this.header.getHeight();
        }


        this.innerList = this.list.createChild({cls:C+'-inner'});
        this.innerList.on('mouseover', this.onViewOver, this);
        this.innerList.on('mousemove', this.onViewMove, this);
        this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));
        
        if(this.allowBlank && !this.pageSize && !this.disableClear){
            this.footer = this.list.createChild({cls:C+'-ft'});
            this.pageTb = new  Roo.Toolbar(this.footer);
           
        }
        if(this.pageSize){
            this.footer = this.list.createChild({cls:C+'-ft'});
            this.pageTb = new  Roo.PagingToolbar(this.footer, this.store,
                    {pageSize: this.pageSize});
            
        }
        
        if (this.pageTb && this.allowBlank && !this.disableClear) {
            var  _this = this;
            this.pageTb.add(new  Roo.Toolbar.Fill(), {
                cls: 'x-btn-icon x-btn-clear',
                text: '&#160;',
                handler: function()
                {
                    _this.collapse();
                    _this.clearValue();
                    _this.onSelect(false, -1);
                }
            });
        }
        if (this.footer) {
            this.assetHeight += this.footer.getHeight();
        }
        

        if(!this.tpl){
            this.tpl = '<div class="'+C+'-item">{' + this.displayField + '}</div>';
        }


        this.view = new  Roo.View(this.innerList, this.tpl, {
            singleSelect:true, store: this.store, selectedClass: this.selectedClass
        });

        this.view.on('click', this.onViewClick, this);

        this.store.on('beforeload', this.onBeforeLoad, this);
        this.store.on('load', this.onLoad, this);
        this.store.on('loadexception', this.collapse, this);

        if(this.resizable){
            this.resizer = new  Roo.Resizable(this.list,  {
               pinned:true, handles:'se'
            });
            this.resizer.on('resize', function(r, w, h){
                this.maxHeight = h-this.handleHeight-this.list.getFrameWidth('tb')-this.assetHeight;
                this.listWidth = w;
                this.innerList.setWidth(w - this.list.getFrameWidth('lr'));
                this.restrictHeight();
            }, this);
            this[this.pageSize?'footer':'innerList'].setStyle('margin-bottom', this.handleHeight+'px');
        }
        if(!this.editable){
            this.editable = true;
            this.setEditable(false);
        }
    },

    // private
    initEvents : function(){
        Roo.form.ComboBox.superclass.initEvents.call(this);

        this.keyNav = new  Roo.KeyNav(this.el, {
            "up" : function(e){
                this.inKeyMode = true;
                this.selectPrev();
            },

            "down" : function(e){
                if(!this.isExpanded()){
                    this.onTriggerClick();
                }else {
                    this.inKeyMode = true;
                    this.selectNext();
                }
            },

            "enter" : function(e){
                this.onViewClick();
                //return true;
            },

            "esc" : function(e){
                this.collapse();
            },

            "tab" : function(e){
                this.onViewClick(false);
                return  true;
            },

            scope : this,

            doRelay : function(D, E, F){
                if(F == 'down' || this.scope.isExpanded()){
                   return  Roo.KeyNav.prototype.doRelay.apply(this, arguments);
                }
                return  true;
            },

            forceKeyDown: true
        });
        this.queryDelay = Math.max(this.queryDelay || 10,
                this.mode == 'local' ? 10 : 250);
        this.dqTask = new  Roo.util.DelayedTask(this.initQuery, this);
        if(this.typeAhead){
            this.taTask = new  Roo.util.DelayedTask(this.onTypeAhead, this);
        }
        if(this.editable !== false){
            this.el.on("keyup", this.onKeyUp, this);
        }
        if(this.forceSelection){
            this.on('blur', this.doForce, this);
        }
    },

    onDestroy : function(){
        if(this.view){
            this.view.setStore(null);
            this.view.el.removeAllListeners();
            this.view.el.remove();
            this.view.purgeListeners();
        }
        if(this.list){
            this.list.destroy();
        }
        if(this.store){
            this.store.un('beforeload', this.onBeforeLoad, this);
            this.store.un('load', this.onLoad, this);
            this.store.un('loadexception', this.collapse, this);
        }

        Roo.form.ComboBox.superclass.onDestroy.call(this);
    },

    // private
    fireKey : function(e){
        if(e.isNavKeyPress() && !this.list.isVisible()){
            this.fireEvent("specialkey", this, e);
        }
    },

    // private
    onResize: function(w, h){
        Roo.form.ComboBox.superclass.onResize.apply(this, arguments);
        if(this.list && this.listWidth === undefined){
            var  lw = Math.max(w, this.minListWidth);
            this.list.setWidth(lw);
            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));
        }
    },

    /**
     * Allow or prevent the user from directly editing the field text.  If false is passed,
     * the user will only be able to select from the items defined in the dropdown list.  This method
     * is the runtime equivalent of setting the 'editable' config option at config time.
     * @param {Boolean} value True to allow the user to directly edit the field text
     */
    setEditable : function(D){
        if(D == this.editable){
            return;
        }

        this.editable = D;
        if(!D){
            this.el.dom.setAttribute('readOnly', true);
            this.el.on('mousedown', this.onTriggerClick,  this);
            this.el.addClass('x-combo-noedit');
        }else {
            this.el.dom.setAttribute('readOnly', false);
            this.el.un('mousedown', this.onTriggerClick,  this);
            this.el.removeClass('x-combo-noedit');
        }
    },

    // private
    onBeforeLoad : function(){
        if(!this.hasFocus){
            return;
        }

        this.innerList.update(this.loadingText ?
               '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
        this.restrictHeight();
        this.selectedIndex = -1;
    },

    // private
    onLoad : function(){
        if(!this.hasFocus){
            return;
        }
        if(this.store.getCount() > 0){
            this.expand();
            this.restrictHeight();
            if(this.lastQuery == this.allQuery){
                if(this.editable){
                    this.el.dom.select();
                }
                if(!this.selectByValue(this.value, true)){
                    this.select(0, true);
                }
            }else {
                this.selectNext();
                if(this.typeAhead && this.lastKey != Roo.EventObject.BACKSPACE && this.lastKey != Roo.EventObject.DELETE ){
                    this.taTask.delay(this.typeAheadDelay);
                }
            }
        }else {
            this.onEmptyResults();
        }
        //this.el.focus();
    },

    // private
    onTypeAhead : function(){
        if(this.store.getCount() > 0){
            var  r = this.store.getAt(0);
            var  newValue = r.data[this.displayField];
            var  len = newValue.length;
            var  selStart = this.getRawValue().length;
            if(selStart != len){
                this.setRawValue(newValue);
                this.selectText(selStart, newValue.length);
            }
        }
    },

    // private
    onSelect : function(E, F){
        if(this.fireEvent('beforeselect', this, E, F) !== false){
            this.setFromData(F > -1 ? E.data : false);
            this.collapse();
            this.fireEvent('select', this, E, F);
        }
    },

    /**
     * Returns the currently selected field value or empty string if no value is set.
     * @return {String} value The selected value
     */
    getValue : function(){
        if(this.valueField){
            return  typeof  this.value != 'undefined' ? this.value : '';
        }else {
            return  Roo.form.ComboBox.superclass.getValue.call(this);
        }
    },

    /**
     * Clears any text/value currently set in the field
     */
    clearValue : function(){
        if(this.hiddenField){
            this.hiddenField.value = '';
        }

        this.value = '';
        this.setRawValue('');
        this.lastSelectionText = '';
        this.applyEmptyText();
    },

    /**
     * Sets the specified value into the field.  If the value finds a match, the corresponding record text
     * will be displayed in the field.  If the value does not match the data value of an existing item,
     * and the valueNotFoundText config option is defined, it will be displayed as the default field text.
     * Otherwise the field will be blank (although the value will still be set).
     * @param {String} value The value to match
     */
    setValue : function(v){
        var  G = v;
        if(this.valueField){
            var  r = this.findRecord(this.valueField, v);
            if(r){
                G = r.data[this.displayField];
            }else  if(this.valueNotFoundText !== undefined){
                G = this.valueNotFoundText;
            }
        }

        this.lastSelectionText = G;
        if(this.hiddenField){
            this.hiddenField.value = v;
        }

        Roo.form.ComboBox.superclass.setValue.call(this, G);
        this.value = v;
    },
    /**
     * @property {Object} the last set data for the element
     */
    
    lastData : false,
    /**
     * Sets the value of the field based on a object which is related to the record format for the store.
     * @param {Object} value the value to set as. or false on reset?
     */
    setFromData : function(o){
        var  dv = ''; // display value
        var  vv = ''; // value value..
        this.lastData = o;
        if (this.displayField) {
            dv = !o || typeof(o[this.displayField]) == 'undefined' ? '' : o[this.displayField];
        } else  {
            // this is an error condition!!!
            console.log('no value field set for '+ this.name);
        }
        
        if(this.valueField){
            vv = !o || typeof(o[this.valueField]) == 'undefined' ? dv : o[this.valueField];
        }
        if(this.hiddenField){
            this.hiddenField.value = vv;
            
            this.lastSelectionText = dv;
            Roo.form.ComboBox.superclass.setValue.call(this, dv);
            this.value = vv;
            return;
        }

        // no hidden field.. - we store the value in 'value', but still display
        // display field!!!!
        this.lastSelectionText = dv;
        Roo.form.ComboBox.superclass.setValue.call(this, dv);
        this.value = vv;
        
        
    },
    // private
    findRecord : function(H, I){
        var  J;
        if(this.store.getCount() > 0){
            this.store.each(function(r){
                if(r.data[H] == I){
                    J = r;
                    return  false;
                }
            });
        }
        return  J;
    },

    // private
    onViewMove : function(e, t){
        this.inKeyMode = false;
    },

    // private
    onViewOver : function(e, t){
        if(this.inKeyMode){ // prevent key nav and mouse over conflicts
            return;
        }
        var  K = this.view.findItemFromChild(t);
        if(K){
            var  F = this.view.indexOf(K);
            this.select(F, false);
        }
    },

    // private
    onViewClick : function(L){
        var  M = this.view.getSelectedIndexes()[0];
        var  r = this.store.getAt(M);
        if(r){
            this.onSelect(r, M);
        }
        if(L !== false && !this.blockFocus){
            this.el.focus();
        }
    },

    // private
    restrictHeight : function(){
        this.innerList.dom.style.height = '';
        var  N = this.innerList.dom;
        var  h = Math.max(N.clientHeight, N.offsetHeight, N.scrollHeight);
        this.innerList.setHeight(h < this.maxHeight ? 'auto' : this.maxHeight);
        this.list.beginUpdate();
        this.list.setHeight(this.innerList.getHeight()+this.list.getFrameWidth('tb')+(this.resizable?this.handleHeight:0)+this.assetHeight);
        this.list.alignTo(this.el, this.listAlign);
        this.list.endUpdate();
    },

    // private
    onEmptyResults : function(){
        this.collapse();
    },

    /**
     * Returns true if the dropdown list is expanded, else false.
     */
    isExpanded : function(){
        return  this.list.isVisible();
    },

    /**
     * Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
     * @param {String} value The data value of the item to select
     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
     * selected item if it is not currently in view (defaults to true)
     * @return {Boolean} True if the value matched an item in the list, else false
     */
    selectByValue : function(v, O){
        if(v !== undefined && v !== null){
            var  r = this.findRecord(this.valueField || this.displayField, v);
            if(r){
                this.select(this.store.indexOf(r), O);
                return  true;
            }
        }
        return  false;
    },

    /**
     * Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
     * @param {Number} index The zero-based index of the list item to select
     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
     * selected item if it is not currently in view (defaults to true)
     */
    select : function(P, Q){
        this.selectedIndex = P;
        this.view.select(P);
        if(Q !== false){
            var  el = this.view.getNode(P);
            if(el){
                this.innerList.scrollChildIntoView(el, false);
            }
        }
    },

    // private
    selectNext : function(){
        var  ct = this.store.getCount();
        if(ct > 0){
            if(this.selectedIndex == -1){
                this.select(0);
            }else  if(this.selectedIndex < ct-1){
                this.select(this.selectedIndex+1);
            }
        }
    },

    // private
    selectPrev : function(){
        var  ct = this.store.getCount();
        if(ct > 0){
            if(this.selectedIndex == -1){
                this.select(0);
            }else  if(this.selectedIndex != 0){
                this.select(this.selectedIndex-1);
            }
        }
    },

    // private
    onKeyUp : function(e){
        if(this.editable !== false && !e.isSpecialKey()){
            this.lastKey = e.getKey();
            this.dqTask.delay(this.queryDelay);
        }
    },

    // private
    validateBlur : function(){
        return  !this.list || !this.list.isVisible();   
    },

    // private
    initQuery : function(){
        this.doQuery(this.getRawValue());
    },

    // private
    doForce : function(){
        if(this.el.dom.value.length > 0){
            this.el.dom.value =
                this.lastSelectionText === undefined ? '' : this.lastSelectionText;
            this.applyEmptyText();
        }
    },

    /**
     * Execute a query to filter the dropdown list.  Fires the beforequery event prior to performing the
     * query allowing the query action to be canceled if needed.
     * @param {String} query The SQL query to execute
     * @param {Boolean} forceAll True to force the query to execute even if there are currently fewer characters
     * in the field than the minimum specified by the minChars config option.  It also clears any filter previously
     * saved in the current store (defaults to false)
     */
    doQuery : function(q, R){
        if(q === undefined || q === null){
            q = '';
        }
        var  qe = {
            query: q,
            forceAll: R,
            combo: this,
            cancel:false
        };
        if(this.fireEvent('beforequery', qe)===false || qe.cancel){
            return  false;
        }

        q = qe.query;
        R = qe.forceAll;
        if(R === true || (q.length >= this.minChars)){
            if(this.lastQuery != q){
                this.lastQuery = q;
                if(this.mode == 'local'){
                    this.selectedIndex = -1;
                    if(R){
                        this.store.clearFilter();
                    }else {
                        this.store.filter(this.displayField, q);
                    }

                    this.onLoad();
                }else {
                    this.store.baseParams[this.queryParam] = q;
                    this.store.load({
                        params: this.getParams(q)
                    });
                    this.expand();
                }
            }else {
                this.selectedIndex = -1;
                this.onLoad();   
            }
        }
    },

    // private
    getParams : function(q){
        var  p = {};
        //p[this.queryParam] = q;
        if(this.pageSize){
            p.start = 0;
            p.limit = this.pageSize;
        }
        return  p;
    },

    /**
     * Hides the dropdown list if it is currently expanded. Fires the 'collapse' event on completion.
     */
    collapse : function(){
        if(!this.isExpanded()){
            return;
        }

        this.list.hide();
        Roo.get(document).un('mousedown', this.collapseIf, this);
        Roo.get(document).un('mousewheel', this.collapseIf, this);
        this.fireEvent('collapse', this);
    },

    // private
    collapseIf : function(e){
        if(!e.within(this.wrap) && !e.within(this.list)){
            this.collapse();
        }
    },

    /**
     * Expands the dropdown list if it is currently hidden. Fires the 'expand' event on completion.
     */
    expand : function(){
        if(this.isExpanded() || !this.hasFocus){
            return;
        }

        this.list.alignTo(this.el, this.listAlign);
        this.list.show();
        Roo.get(document).on('mousedown', this.collapseIf, this);
        Roo.get(document).on('mousewheel', this.collapseIf, this);
        this.fireEvent('expand', this);
    },

    // private
    // Implements the default empty TriggerField.onTriggerClick function
    onTriggerClick : function(){
        if(this.disabled){
            return;
        }
        if(this.isExpanded()){
            this.collapse();
            if (!this.blockFocus) {
                this.el.focus();
            }
            
        }else  {
            this.hasFocus = true;
            if(this.triggerAction == 'all') {
                this.doQuery(this.allQuery, true);
            } else  {
                this.doQuery(this.getRawValue());
            }
            if (!this.blockFocus) {
                this.el.focus();
            }
        }
    }

    /** 
    * @cfg {Boolean} grow 
    * @hide 
    */
    /** 
    * @cfg {Number} growMin 
    * @hide 
    */
    /** 
    * @cfg {Number} growMax 
    * @hide 
    */
    /**
     * @hide
     * @method autoSize
     */
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.form.Checkbox
 * @extends Roo.form.Field
 * Single checkbox field.  Can be used as a direct replacement for traditional checkbox fields.
 * @constructor
 * Creates a new Checkbox
 * @param {Object} config Configuration options
 */
Roo.form.Checkbox = function(A){
    Roo.form.Checkbox.superclass.constructor.call(this, A);
    this.addEvents({
        /**
         * @event check
         * Fires when the checkbox is checked or unchecked.
	     * @param {Roo.form.Checkbox} this This checkbox
	     * @param {Boolean} checked The new checked value
	     */
        check : true
    });
};

Roo.extend(Roo.form.Checkbox, Roo.form.Field,  {
    /**
     * @cfg {String} focusClass The CSS class to use when the checkbox receives focus (defaults to undefined)
     */
    focusClass : undefined,
    /**
     * @cfg {String} fieldClass The default CSS class for the checkbox (defaults to "x-form-field")
     */
    fieldClass: "x-form-field",
    /**
     * @cfg {Boolean} checked True if the the checkbox should render already checked (defaults to false)
     */
    checked: false,
    /**
     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "checkbox", autocomplete: "off"})
     */
    defaultAutoCreate : { tag: "input", type: 'hidden', autocomplete: "off"},
    /**
     * @cfg {String} boxLabel The text that appears beside the checkbox
     */
    boxLabel : "",
    /**
     * @cfg {String} inputValue The value that should go into the generated input element's value attribute
     */  
    inputValue : '1',
    /**
     * @cfg {String} valueOff The value that should go into the generated input element's value when unchecked.
     */
     valueOff: '0', // value when not checked..

    actionMode : 'viewEl', 
    //
    // private
    itemCls : 'x-menu-check-item x-form-item',
    groupClass : 'x-menu-group-item',
    inputType : 'hidden',
    
    
    inSetChecked: false, // check that we are not calling self...
    
    inputElement: false, // real input element?
    basedOn: false, // ????
    
    isFormField: true, // not sure where this is needed!!!!

    onResize : function(){
        Roo.form.Checkbox.superclass.onResize.apply(this, arguments);
        if(!this.boxLabel){
            this.el.alignTo(this.wrap, 'c-c');
        }
    },

    initEvents : function(){
        Roo.form.Checkbox.superclass.initEvents.call(this);
        this.el.on("click", this.onClick,  this);
        this.el.on("change", this.onClick,  this);
    },


    getResizeEl : function(){
        return  this.wrap;
    },

    getPositionEl : function(){
        return  this.wrap;
    },

    // private
    onRender : function(ct, B){
        Roo.form.Checkbox.superclass.onRender.call(this, ct, B);
        /*
        if(this.inputValue !== undefined){
            this.el.dom.value = this.inputValue;
        }
        */
        //this.wrap = this.el.wrap({cls: "x-form-check-wrap"});
        this.wrap = this.el.wrap({cls: 'x-menu-check-item '});
        var  C = this.wrap.createChild({ 
            tag: 'img', cls: 'x-menu-item-icon', style: 'margin: 0px;' ,src : Roo.BLANK_IMAGE_URL });
        this.viewEl = C;   
        this.wrap.on('click', this.onClick,  this); 
        
        this.el.on('DOMAttrModified', this.setFromHidden,  this); //ff
        this.el.on('propertychange', this.setFromHidden,  this);  //ie
        
        
        
        if(this.boxLabel){
            this.wrap.createChild({tag: 'label', htmlFor: this.el.id, cls: 'x-form-cb-label', html: this.boxLabel});
        //    viewEl.on('click', this.onClick,  this); 
        }

        //if(this.checked){
            this.setChecked(this.checked);
        //}else{
            //this.checked = this.el.dom;
        //}

    },

    // private
    initValue : Roo.emptyFn,

    /**
     * Returns the checked state of the checkbox.
     * @return {Boolean} True if checked, else false
     */
    getValue : function(){
        if(this.el){
            return  String(this.el.dom.value) == String(this.inputValue ) ? this.inputValue : this.valueOff;
        }
        return  this.valueOff;
        
    },

	// private
    onClick : function(){ 
        this.setChecked(!this.checked);

        //if(this.el.dom.checked != this.checked){
        //    this.setValue(this.el.dom.checked);
       // }
    },

    /**
     * Sets the checked state of the checkbox.
     * @param {Boolean/String} checked True, 'true', '1', or 'on' to check the checkbox, any other value will uncheck it.
     */
    setValue : function(v,D){
        //this.checked = (v === true || v === 'true' || v == '1' || String(v).toLowerCase() == 'on');
        //if(this.el && this.el.dom){
        //    this.el.dom.checked = this.checked;
        //    this.el.dom.defaultChecked = this.checked;
        //}
        this.setChecked(v === this.inputValue);
        //this.fireEvent("check", this, this.checked);
    },
    // private..
    setChecked : function(E,F)
    {
        if (this.inSetChecked) {
            this.checked = E;
            return;
        }
        
    
        if(this.wrap){
            this.wrap[E ? 'addClass' : 'removeClass']('x-menu-item-checked');
        }

        this.checked = E;
        if(F !== true){
            this.fireEvent('checkchange', this, E);
        }

        this.inSetChecked = true;
        this.el.dom.value = E ? this.inputValue : this.valueOff;
        this.inSetChecked = false;
        
    },
    // handle setting of hidden value by some other method!!?!?
    setFromHidden: function()
    {
        if(!this.el){
            return;
        }

        //console.log("SET FROM HIDDEN");
        //alert('setFrom hidden');
        this.setValue(this.el.dom.value);
    },
    
    onDestroy : function()
    {
        if(this.viewEl){
            Roo.get(this.viewEl).remove();
        }

         
        Roo.form.Checkbox.superclass.onDestroy.call(this);
    }

});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.Radio
 * @extends Roo.form.Checkbox
 * Single radio field.  Same as Checkbox, but provided as a convenience for automatically setting the input type.
 * Radio grouping is handled automatically by the browser if you give each radio in a group the same name.
 * @constructor
 * Creates a new Radio
 * @param {Object} config Configuration options
 */
Roo.form.Radio = function(){
    Roo.form.Radio.superclass.constructor.apply(this, arguments);
};
Roo.extend(Roo.form.Radio, Roo.form.Checkbox, {
    inputType: 'radio',

    /**
     * If this radio is part of a group, it will return the selected value
     * @return {String}
     */
    getGroupValue : function(){
        return  this.el.up('form').child('input[name='+this.el.dom.name+']:checked', true).value;
    }
});
//<script type="text/javascript">

/*
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 * licensing@extjs.com
 * 
 * http://www.extjs.com/license
 */
 
 /*
  * 
  * Known bugs:
  * Default CSS appears to render it as fixed text by default (should really be Sans-Serif)
  * - IE ? - no idea how much works there.
  * 
  * 
  * 
  */
 

/**
 * @class Ext.form.HtmlEditor
 * @extends Ext.form.Field
 * Provides a lightweight HTML Editor component.
 * WARNING - THIS CURRENTlY ONLY WORKS ON FIREFOX - USE FCKeditor for a cross platform version
 * 
 * <br><br><b>Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT
 * supported by this editor.</b><br/><br/>
 * An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an Editor within
 * any element that has display set to 'none' can cause problems in Safari and Firefox.<br/><br/>
 */
Roo.form.HtmlEditor = Roo.extend(Roo.form.Field, {
      /**
     * @cfg {Array} toolbars Array of toolbars. - defaults to just the Standard one
     */
    toolbars : false,
    /**
     * @cfg {String} createLinkText The default text for the create link prompt
     */
    createLinkText : 'Please enter the URL for the link:',
    /**
     * @cfg {String} defaultLinkValue The default value for the create link prompt (defaults to http:/ /)
     */
    defaultLinkValue : 'http:/'+'/',
   
    
    // id of frame..
    frameId: false,
    
    // private properties
    validationEvent : false,
    deferHeight: true,
    initialized : false,
    activated : false,
    sourceEditMode : false,
    onFocus : Roo.emptyFn,
    iframePad:3,
    hideMode:'offsets',
    defaultAutoCreate : {
        tag: "textarea",
        style:"width:500px;height:300px;",
        autocomplete: "off"
    },

    // private
    initComponent : function(){
        this.addEvents({
            /**
             * @event initialize
             * Fires when the editor is fully initialized (including the iframe)
             * @param {HtmlEditor} this
             */
            initialize: true,
            /**
             * @event activate
             * Fires when the editor is first receives the focus. Any insertion must wait
             * until after this event.
             * @param {HtmlEditor} this
             */
            activate: true,
             /**
             * @event beforesync
             * Fires before the textarea is updated with content from the editor iframe. Return false
             * to cancel the sync.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            beforesync: true,
             /**
             * @event beforepush
             * Fires before the iframe editor is updated with content from the textarea. Return false
             * to cancel the push.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            beforepush: true,
             /**
             * @event sync
             * Fires when the textarea is updated with content from the editor iframe.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            sync: true,
             /**
             * @event push
             * Fires when the iframe editor is updated with content from the textarea.
             * @param {HtmlEditor} this
             * @param {String} html
             */
            push: true,
             /**
             * @event editmodechange
             * Fires when the editor switches edit modes
             * @param {HtmlEditor} this
             * @param {Boolean} sourceEdit True if source edit, false if standard editing.
             */
            editmodechange: true,
            /**
             * @event editorevent
             * Fires when on any editor (mouse up/down cursor movement etc.) - used for toolbar hooks.
             * @param {HtmlEditor} this
             */
            editorevent: true
        })
    },

    /**
     * Protected method that will not generally be called directly. It
     * is called when the editor creates its toolbar. Override this method if you need to
     * add custom toolbar buttons.
     * @param {HtmlEditor} editor
     */
    createToolbar : function(A){
        if (!A.toolbars || !A.toolbars.length) {
            A.toolbars = [ new  Roo.form.HtmlEditor.ToolbarStandard() ]; // can be empty?
        }
        
        for (var  i =0 ; i < A.toolbars.length;i++) {
            A.toolbars[i].init(A);
        }
         
        
    },

    /**
     * Protected method that will not generally be called directly. It
     * is called when the editor initializes the iframe with HTML contents. Override this method if you
     * want to change the initialization markup of the iframe (e.g. to add stylesheets).
     */
    getDocMarkup : function(){
        return  '<html><head><style type="text/css">body{border:0;margin:0;padding:3px;height:98%;cursor:text;}</style></head><body></body></html>';
    },

    // private
    onRender : function(ct, B){
        Roo.form.HtmlEditor.superclass.onRender.call(this, ct, B);
        this.el.dom.style.border = '0 none';
        this.el.dom.setAttribute('tabIndex', -1);
        this.el.addClass('x-hidden');
        if(Roo.isIE){ // fix IE 1px bogus margin
            this.el.applyStyles('margin-top:-1px;margin-bottom:-1px;')
        }

        this.wrap = this.el.wrap({
            cls:'x-html-editor-wrap', cn:{cls:'x-html-editor-tb'}
        });

        this.frameId = Roo.id();
        this.createToolbar(this);
        
        
        
        
      
        
        var  C = this.wrap.createChild({
            tag: 'iframe',
            id: this.frameId,
            name: this.frameId,
            frameBorder : 'no',
            'src' : Roo.SSL_SECURE_URL ? Roo.SSL_SECURE_URL  :  "javascript:false"
        });
        
       // console.log(iframe);
        //this.wrap.dom.appendChild(iframe);

        this.iframe = C.dom;

         this.assignDocWin();
        
        this.doc.designMode = 'on';
       
        this.doc.open();
        this.doc.write(this.getDocMarkup());
        this.doc.close();

        
        var  D = { // must defer to wait for browser to be ready
            run : function(){
                //console.log("run task?" + this.doc.readyState);
                this.assignDocWin();
                if(this.doc.body || this.doc.readyState == 'complete'){
                    try {
                        
                       
                        this.doc.designMode="on";
                    } catch (e) {
                        return;
                    }

                    Roo.TaskMgr.stop(D);
                    this.initEditor.defer(10, this);
                }
            },
            interval : 10,
            duration:10000,
            scope: this
        };
        Roo.TaskMgr.start(D);

        if(!this.width){
            this.setSize(this.el.getSize());
        }
    },

    // private
    onResize : function(w, h){
        Roo.form.HtmlEditor.superclass.onResize.apply(this, arguments);
        if(this.el && this.iframe){
            if(typeof  w == 'number'){
                var  aw = w - this.wrap.getFrameWidth('lr');
                this.el.setWidth(this.adjustWidth('textarea', aw));
                this.iframe.style.width = aw + 'px';
            }
            if(typeof  h == 'number'){
                var  tbh = 0;
                for (var  i =0; i < this.toolbars.length;i++) {
                    // fixme - ask toolbars for heights?
                    tbh += this.toolbars[i].tb.el.getHeight();
                }
                
                
                
                
                var  ah = h - this.wrap.getFrameWidth('tb') - tbh;// this.tb.el.getHeight();
                this.el.setHeight(this.adjustWidth('textarea', ah));
                this.iframe.style.height = ah + 'px';
                if(this.doc){
                    (this.doc.body || this.doc.documentElement).style.height = (ah - (this.iframePad*2)) + 'px';
                }
            }
        }
    },

    /**
     * Toggles the editor between standard and source edit mode.
     * @param {Boolean} sourceEdit (optional) True for source edit, false for standard
     */
    toggleSourceEdit : function(E){
        
        this.sourceEditMode = E === true;
        
        if(this.sourceEditMode){
          
            this.syncValue();
            this.iframe.className = 'x-hidden';
            this.el.removeClass('x-hidden');
            this.el.dom.removeAttribute('tabIndex');
            this.el.focus();
        }else {
             
            this.pushValue();
            this.iframe.className = '';
            this.el.addClass('x-hidden');
            this.el.dom.setAttribute('tabIndex', -1);
            this.deferFocus();
        }

        this.setSize(this.wrap.getSize());
        this.fireEvent('editmodechange', this, this.sourceEditMode);
    },

    // private used internally
    createLink : function(){
        var  F = prompt(this.createLinkText, this.defaultLinkValue);
        if(F && F != 'http:/'+'/'){
            this.relayCmd('createlink', F);
        }
    },

    // private (for BoxComponent)
    adjustSize : Roo.BoxComponent.prototype.adjustSize,

    // private (for BoxComponent)
    getResizeEl : function(){
        return  this.wrap;
    },

    // private (for BoxComponent)
    getPositionEl : function(){
        return  this.wrap;
    },

    // private
    initEvents : function(){
        this.originalValue = this.getValue();
    },

    /**
     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide
     * @method
     */
    markInvalid : Roo.emptyFn,
    /**
     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide
     * @method
     */
    clearInvalid : Roo.emptyFn,

    setValue : function(v){
        Roo.form.HtmlEditor.superclass.setValue.call(this, v);
        this.pushValue();
    },

    /**
     * Protected method that will not generally be called directly. If you need/want
     * custom HTML cleanup, this is the method you should override.
     * @param {String} html The HTML to be cleaned
     * return {String} The cleaned HTML
     */
    cleanHtml : function(G){
        G = String(G);
        if(G.length > 5){
            if(Roo.isSafari){ // strip safari nonsense
                G = G.replace(/\sclass="(?:Apple-style-span|khtml-block-placeholder)"/gi, '');
            }
        }
        if(G == '&nbsp;'){
            G = '';
        }
        return  G;
    },

    /**
     * Protected method that will not generally be called directly. Syncs the contents
     * of the editor iframe with the textarea.
     */
    syncValue : function(){
        if(this.initialized){
            var  bd = (this.doc.body || this.doc.documentElement);
            var  G = bd.innerHTML;
            if(Roo.isSafari){
                var  bs = bd.getAttribute('style'); // Safari puts text-align styles on the body element!
                var  m = bs.match(/text-align:(.*?);/i);
                if(m && m[1]){
                    G = '<div style="'+m[0]+'">' + G + '</div>';
                }
            }

            G = this.cleanHtml(G);
            if(this.fireEvent('beforesync', this, G) !== false){
                this.el.dom.value = G;
                this.fireEvent('sync', this, G);
            }
        }
    },

    /**
     * Protected method that will not generally be called directly. Pushes the value of the textarea
     * into the iframe editor.
     */
    pushValue : function(){
        if(this.initialized){
            var  v = this.el.dom.value;
            if(v.length < 1){
                v = '&#160;';
            }
            if(this.fireEvent('beforepush', this, v) !== false){
                (this.doc.body || this.doc.documentElement).innerHTML = v;
                this.fireEvent('push', this, v);
            }
        }
    },

    // private
    deferFocus : function(){
        this.focus.defer(10, this);
    },

    // doc'ed in Field
    focus : function(){
        if(this.win && !this.sourceEditMode){
            this.win.focus();
        }else {
            this.el.focus();
        }
    },
    
    assignDocWin: function()
    {
        var  H = this.iframe;
        
         if(Roo.isIE){
            this.doc = H.contentWindow.document;
            this.win = H.contentWindow;
        } else  {
            this.doc = (H.contentDocument || Roo.get(this.frameId).dom.document);
            this.win = Roo.get(this.frameId).dom.contentWindow;
        }
    },
    
    // private
    initEditor : function(){
        //console.log("INIT EDITOR");
        this.assignDocWin();
        
        
        
        this.doc.designMode="on";
        this.doc.open();
        this.doc.write(this.getDocMarkup());
        this.doc.close();
        
        var  I = (this.doc.body || this.doc.documentElement);
        //var ss = this.el.getStyles('font-size', 'font-family', 'background-image', 'background-repeat');
        // this copies styles from the containing element into thsi one..
        // not sure why we need all of this..
        var  ss = this.el.getStyles('font-size', 'background-image', 'background-repeat');
        ss['background-attachment'] = 'fixed'; // w3c
        I.bgProperties = 'fixed'; // ie
        Roo.DomHelper.applyStyles(I, ss);
        Roo.EventManager.on(this.doc, {
            'mousedown': this.onEditorEvent,
            'dblclick': this.onEditorEvent,
            'click': this.onEditorEvent,
            'keyup': this.onEditorEvent,
            buffer:100,
            scope: this
        });
        if(Roo.isGecko){
            Roo.EventManager.on(this.doc, 'keypress', this.applyCommand, this);
        }
        if(Roo.isIE || Roo.isSafari || Roo.isOpera){
            Roo.EventManager.on(this.doc, 'keydown', this.fixKeys, this);
        }

        this.initialized = true;

        this.fireEvent('initialize', this);
        this.pushValue();
    },

    // private
    onDestroy : function(){
        
        
        
        if(this.rendered){
            
            for (var  i =0; i < this.toolbars.length;i++) {
                // fixme - ask toolbars for heights?
                this.toolbars[i].onDestroy();
            }

            
            this.wrap.dom.innerHTML = '';
            this.wrap.remove();
        }
    },

    // private
    onFirstFocus : function(){
        
        this.assignDocWin();
        
        
        this.activated = true;
        for (var  i =0; i < this.toolbars.length;i++) {
            this.toolbars[i].onFirstFocus();
        }
       
        if(Roo.isGecko){ // prevent silly gecko errors
            this.win.focus();
            var  s = this.win.getSelection();
            if(!s.focusNode || s.focusNode.nodeType != 3){
                var  r = s.getRangeAt(0);
                r.selectNodeContents((this.doc.body || this.doc.documentElement));
                r.collapse(true);
                this.deferFocus();
            }
            try{
                this.execCmd('useCSS', true);
                this.execCmd('styleWithCSS', false);
            }catch(e){}
        }

        this.fireEvent('activate', this);
    },

    // private
    adjustFont: function(J){
        var  K = J.cmd == 'increasefontsize' ? 1 : -1;
        //if(Roo.isSafari){ // safari
        //    adjust *= 2;
       // }
        var  v = parseInt(this.doc.queryCommandValue('FontSize')|| 3, 10);
        if(Roo.isSafari){ // safari
            var  sm = { 10 : 1, 13: 2, 16:3, 18:4, 24: 5, 32:6, 48: 7 };
            v =  (v < 10) ? 10 : v;
            v =  (v > 48) ? 48 : v;
            v = typeof(sm[v]) == 'undefined' ? 1 : sm[v];
            
        }

        
        
        v = Math.max(1, v+K);
        
        this.execCmd('FontSize', v  );
    },

    onEditorEvent : function(e){
        this.fireEvent('editorevent', this, e);
      //  this.updateToolbar();
        this.syncValue();
    },

    insertTag : function(tg)
    {
        // could be a bit smarter... -> wrap the current selected tRoo..
        
        this.execCmd("formatblock",   tg);
        
    },
    
    insertText : function(L)
    {
        
        
        range = this.createRange();
        range.deleteContents();
               //alert(Sender.getAttribute('label'));
               
        range.insertNode(this.doc.createTextNode(L));
    } ,
    
    // private
    relayBtnCmd : function(M){
        this.relayCmd(M.cmd);
    },

    /**
     * Executes a Midas editor command on the editor document and performs necessary focus and
     * toolbar updates. <b>This should only be called after the editor is initialized.</b>
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    relayCmd : function(N, O){
        this.win.focus();
        this.execCmd(N, O);
        this.fireEvent('editorevent', this);
        //this.updateToolbar();
        this.deferFocus();
    },

    /**
     * Executes a Midas editor command directly on the editor document.
     * For visual commands, you should use {@link #relayCmd} instead.
     * <b>This should only be called after the editor is initialized.</b>
     * @param {String} cmd The Midas command
     * @param {String/Boolean} value (optional) The value to pass to the command (defaults to null)
     */
    execCmd : function(P, Q){
        this.doc.execCommand(P, false, Q === undefined ? null : Q);
        this.syncValue();
    },

    // private
    applyCommand : function(e){
        if(e.ctrlKey){
            var  c = e.getCharCode(), P;
            if(c > 0){
                c = String.fromCharCode(c);
                switch(c){
                    case  'b':
                        P = 'bold';
                    break;
                    case  'i':
                        P = 'italic';
                    break;
                    case  'u':
                        P = 'underline';
                    break;
                }
                if(P){
                    this.win.focus();
                    this.execCmd(P);
                    this.deferFocus();
                    e.preventDefault();
                }
            }
        }
    },

    /**
     * Inserts the passed text at the current cursor position. Note: the editor must be initialized and activated
     * to insert tRoo.
     * @param {String} text
     */
    insertAtCursor : function(R){
        if(!this.activated){
            return;
        }
        if(Roo.isIE){
            this.win.focus();
            var  r = this.doc.selection.createRange();
            if(r){
                r.collapse(true);
                r.pasteHTML(R);
                this.syncValue();
                this.deferFocus();
            }
        }else  if(Roo.isGecko || Roo.isOpera){
            this.win.focus();
            this.execCmd('InsertHTML', R);
            this.deferFocus();
        }else  if(Roo.isSafari){
            this.execCmd('InsertText', R);
            this.deferFocus();
        }
    },

    // private
    fixKeys : function(){ // load time branching for fastest keydown performance
        if(Roo.isIE){
            return  function(e){
                var  k = e.getKey(), r;
                if(k == e.TAB){
                    e.stopEvent();
                    r = this.doc.selection.createRange();
                    if(r){
                        r.collapse(true);
                        r.pasteHTML('&#160;&#160;&#160;&#160;');
                        this.deferFocus();
                    }
                }else  if(k == e.ENTER){
                    r = this.doc.selection.createRange();
                    if(r){
                        var  target = r.parentElement();
                        if(!target || target.tagName.toLowerCase() != 'li'){
                            e.stopEvent();
                            r.pasteHTML('<br />');
                            r.collapse(false);
                            r.select();
                        }
                    }
                }
            };
        }else  if(Roo.isOpera){
            return  function(e){
                var  k = e.getKey();
                if(k == e.TAB){
                    e.stopEvent();
                    this.win.focus();
                    this.execCmd('InsertHTML','&#160;&#160;&#160;&#160;');
                    this.deferFocus();
                }
            };
        }else  if(Roo.isSafari){
            return  function(e){
                var  k = e.getKey();
                if(k == e.TAB){
                    e.stopEvent();
                    this.execCmd('InsertText','\t');
                    this.deferFocus();
                }
             };
        }
    }(),
    
    getAllAncestors: function()
    {
        var  p = this.getSelectedNode();
        var  a = [];
        if (!p) {
            a.push(p); // push blank onto stack..
            p = this.getParentElement();
        }
        
        
        while (p && (p.nodeType == 1) && (p.tagName.toLowerCase() != 'body')) {
            a.push(p);
            p = p.parentNode;
        }

        a.push(this.doc.body);
        return  a;
    },
    lastSel : false,
    lastSelNode : false,
    
    
    getSelection : function() 
    {
        this.assignDocWin();
        return  Roo.isIE ? this.doc.selection : this.win.getSelection();
    },
    
    getSelectedNode: function() 
    {
        // this may only work on Gecko!!!
        
        // should we cache this!!!!
        
        
        
         
        var  S = this.createRange(this.getSelection());
        
        if (Roo.isIE) {
            var  parent = S.parentElement();
            while (true) {
                var  testRange = S.duplicate();
                testRange.moveToElementText(parent);
                if (testRange.inRange(S)) {
                    break;
                }
                if ((parent.nodeType != 1) || (parent.tagName.toLowerCase() == 'body')) {
                    break;
                }

                parent = parent.parentElement;
            }
            return  parent;
        }
        
        
        var  ar = S.endContainer.childNodes;
        if (!ar.length) {
            ar = S.commonAncestorContainer.childNodes;
            //alert(ar.length);
        }
        var  T = [];
        var  U = [];
        var  V = false;
        for (var  i=0;i<ar.length;i++) {
            if ((ar[i].nodeType == 3) && (!ar[i].data.length)) { // empty text ? 
                continue;
            }
            // fullly contained node.
            
            if (this.rangeIntersectsNode(S,ar[i]) && this.rangeCompareNode(S,ar[i]) == 3) {
                T.push(ar[i]);
                continue;
            }
            
            // probably selected..
            if ((ar[i].nodeType == 1) && this.rangeIntersectsNode(S,ar[i]) && (this.rangeCompareNode(S,ar[i]) > 0)) {
                U.push(ar[i]);
                continue;
            }
            if (!this.rangeIntersectsNode(S,ar[i])|| (this.rangeCompareNode(S,ar[i]) == 0))  {
                continue;
            }

            
            
            V = true;
        }
        if (!T.length && U.length) {
            T= U;
        }
        if (V || !T.length || (T.length > 1)) {
            return  false;
        }
        
        return  T[0];
    },
    createRange: function(W)
    {
        // this has strange effects when using with 
        // top toolbar - not sure if it's a great idea.
        //this.editor.contentWindow.focus();
        if (typeof  W != "undefined") {
            try {
                return  W.getRangeAt ? W.getRangeAt(0) : W.createRange();
            } catch(e) {
                return  this.doc.createRange();
            }
        } else  {
            return  this.doc.createRange();
        }
    },
    getParentElement: function()
    {
        
        this.assignDocWin();
        var  X = Roo.isIE ? this.doc.selection : this.win.getSelection();
        
        var  Y = this.createRange(X);
         
        try {
            var  p = Y.commonAncestorContainer;
            while (p.nodeType == 3) { // text node
                p = p.parentNode;
            }
            return  p;
        } catch (e) {
            return  null;
        }
    
    },
    
    
    
    // BC Hacks - cause I cant work out what i was trying to do..
    rangeIntersectsNode : function(Z, b)
    {
        var  d = b.ownerDocument.createRange();
        try {
            d.selectNode(b);
        }
        catch (e) {
            nodeRange.selectNodeContents(node);
        }

        return  Z.compareBoundaryPoints(Range.END_TO_START, d) == -1 &&
                 Z.compareBoundaryPoints(Range.START_TO_END, d) == 1;
    },
    rangeCompareNode : function(f, g) {
        var  j = g.ownerDocument.createRange();
        try {
            j.selectNode(g);
        } catch (e) {
            nodeRange.selectNodeContents(node);
        }
        var  k = f.compareBoundaryPoints(Range.START_TO_START, j) == 1;
        var  l = f.compareBoundaryPoints(Range.END_TO_END, j) == -1;

        if (k && !l)
            return  0;
        if (!k && l)
            return  1;
        if (k && l)
            return  2;

        return  3;
    }

    
    
    // hide stuff that is not compatible
    /**
     * @event blur
     * @hide
     */
    /**
     * @event change
     * @hide
     */
    /**
     * @event focus
     * @hide
     */
    /**
     * @event specialkey
     * @hide
     */
    /**
     * @cfg {String} fieldClass @hide
     */
    /**
     * @cfg {String} focusClass @hide
     */
    /**
     * @cfg {String} autoCreate @hide
     */
    /**
     * @cfg {String} inputType @hide
     */
    /**
     * @cfg {String} invalidClass @hide
     */
    /**
     * @cfg {String} invalidText @hide
     */
    /**
     * @cfg {String} msgFx @hide
     */
    /**
     * @cfg {String} validateOnBlur @hide
     */
});
// <script type="text/javascript">
/*
 * Based on
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *  
 
 */

/**
 * @class Roo.form.HtmlEditorToolbar1
 * Basic Toolbar
 * 
 * Usage:
 *
 new Roo.form.HtmlEditor({
    ....
    toolbars : [
        new Roo.form.HtmlEditorToolbar1({
            disable : { fonts: 1 , format: 1, ..., ... , ...],
            btns : [ .... ]
        })
    }
     
 * 
 * @cfg {Object} disable List of elements to disable..
 * @cfg {Array} btns List of additional buttons.
 * 
 * 
 * NEEDS Extra CSS? 
 * .x-html-editor-tb .x-edit-none .x-btn-text { background: none; }
 */
 
Roo.form.HtmlEditor.ToolbarStandard = function(A)
{
    
    Roo.apply(this, A);
    //Roo.form.HtmlEditorToolbar1.superclass.constructor.call(this, editor.wrap.dom.firstChild, [], config);
    // dont call parent... till later.
}


Roo.apply(Roo.form.HtmlEditor.ToolbarStandard.prototype,  {
    
    tb: false,
    
    rendered: false,
    
    editor : false,
    /**
     * @cfg {Object} disable  List of toolbar elements to disable
         
     */
    disable : false,
      /**
     * @cfg {Array} fontFamilies An array of available font families
     */
    fontFamilies : [
        'Arial',
        'Courier New',
        'Tahoma',
        'Times New Roman',
        'Verdana'
    ],
    
    specialChars : [
           "&#169;",
          "&#174;",     
          "&#8482;",    
          "&#163;" ,    
         // "&#8212;",    
          "&#8230;",    
          "&#247;" ,    
        //  "&#225;" ,     ?? a acute?
           "&#8364;"    , //Euro
       //   "&#8220;"    ,
        //  "&#8221;"    ,
        //  "&#8226;"    ,
          "&#176;"  //   , // degrees

         // "&#233;"     , // e ecute
         // "&#250;"     , // u ecute?
    ],
    inputElements : [ 
            "form", "input:text", "input:hidden", "input:checkbox", "input:radio", "input:password", 
            "input:submit", "input:button", "select", "textarea", "label" ],
    formats : [
        ["p"] ,  
        ["h1"],["h2"],["h3"],["h4"],["h5"],["h6"], 
        ["pre"],[ "code"], 
        ["abbr"],[ "acronym"],[ "address"],[ "cite"],[ "samp"],[ "var"]
    ],
     /**
     * @cfg {String} defaultFont default font to use.
     */
    defaultFont: 'tahoma',
   
    fontSelect : false,
    
    
    formatCombo : false,
    
    init : function(B)
    {
        this.editor = B;
        
        
        var  C = B.frameId;
        var  D = this;
        function  E(id, G, H){
            var  I = C + '-'+ id ;
            return  {
                id : I,
                cmd : id,
                cls : 'x-btn-icon x-edit-'+id,
                enableToggle:G !== false,
                scope: B, // was editor...
                handler:H||B.relayBtnCmd,
                clickEvent:'mousedown',
                tooltip: D.buttonTips[id] || undefined, ///tips ???
                tabIndex:-1
            };
        }
        
        
        
        var  tb = new  Roo.Toolbar(B.wrap.dom.firstChild);
        this.tb = tb;
         // stop form submits
        tb.el.on('click', function(e){
            e.preventDefault(); // what does this do?
        });

        if(!this.disable.font && !Roo.isSafari){
            /* why no safari for fonts
            editor.fontSelect = tb.el.createChild({
                tag:'select',
                tabIndex: -1,
                cls:'x-font-select',
                html: editor.createFontOptions()
            });
            editor.fontSelect.on('change', function(){
                var font = editor.fontSelect.dom.value;
                editor.relayCmd('fontname', font);
                editor.deferFocus();
            }, editor);
            tb.add(
                editor.fontSelect.dom,
                '-'
            );
            */
        };
        if(!this.disable.formats){
            this.formatCombo = new  Roo.form.ComboBox({
                store: new  Roo.data.SimpleStore({
                    id : 'tag',
                    fields: ['tag'],
                    data : this.formats // from states.js
                }),
                blockFocus : true,
                //autoCreate : {tag: "div",  size: "20"},
                displayField:'tag',
                typeAhead: false,
                mode: 'local',
                editable : false,
                triggerAction: 'all',
                emptyText:'Add tag',
                selectOnFocus:true,
                width:135,
                listeners : {
                    'select': function(c, r, i) {
                        B.insertTag(r.get('tag'));
                        B.focus();
                    }
                }

            });
            tb.addField(this.formatCombo);
            
        }
        
        if(!this.disable.format){
            tb.add(
                E('bold'),
                E('italic'),
                E('underline')
            );
        };
        if(!this.disable.fontSize){
            tb.add(
                '-',
                
                
                E('increasefontsize', false, B.adjustFont),
                E('decreasefontsize', false, B.adjustFont)
            );
        };
        
        
        if(this.disable.colors){
            tb.add(
                '-', {
                    id:B.frameId +'-forecolor',
                    cls:'x-btn-icon x-edit-forecolor',
                    clickEvent:'mousedown',
                    tooltip: this.buttonTips['forecolor'] || undefined,
                    tabIndex:-1,
                    menu : new  Roo.menu.ColorMenu({
                        allowReselect: true,
                        focus: Roo.emptyFn,
                        value:'000000',
                        plain:true,
                        selectHandler: function(cp, G){
                            B.execCmd('forecolor', Roo.isSafari || Roo.isIE ? '#'+G : G);
                            B.deferFocus();
                        },
                        scope: B,
                        clickEvent:'mousedown'
                    })
                }, {
                    id:B.frameId +'backcolor',
                    cls:'x-btn-icon x-edit-backcolor',
                    clickEvent:'mousedown',
                    tooltip: this.buttonTips['backcolor'] || undefined,
                    tabIndex:-1,
                    menu : new  Roo.menu.ColorMenu({
                        focus: Roo.emptyFn,
                        value:'FFFFFF',
                        plain:true,
                        allowReselect: true,
                        selectHandler: function(cp, H){
                            if(Roo.isGecko){
                                B.execCmd('useCSS', false);
                                B.execCmd('hilitecolor', H);
                                B.execCmd('useCSS', true);
                                B.deferFocus();
                            }else {
                                B.execCmd(Roo.isOpera ? 'hilitecolor' : 'backcolor', 
                                    Roo.isSafari || Roo.isIE ? '#'+H : H);
                                B.deferFocus();
                            }
                        },
                        scope:B,
                        clickEvent:'mousedown'
                    })
                }
            );
        };
        // now add all the items...
        

        if(!this.disable.alignments){
            tb.add(
                '-',
                E('justifyleft'),
                E('justifycenter'),
                E('justifyright')
            );
        };

        //if(!Roo.isSafari){
            if(!this.disable.links){
                tb.add(
                    '-',
                    E('createlink', false, B.createLink)    /// MOVE TO HERE?!!?!?!?!
                );
            };

            if(!this.disable.lists){
                tb.add(
                    '-',
                    E('insertorderedlist'),
                    E('insertunorderedlist')
                );
            }
            if(!this.disable.sourceEdit){
                tb.add(
                    '-',
                    E('sourceedit', true, function(G){
                        this.toggleSourceEdit(G.pressed);
                    })
                );
            }
        //}
        
        var  F = { };
        // special menu.. - needs to be tidied up..
        if (!this.disable.special) {
            F = {
                text: "&#169;",
                cls: 'x-edit-none',
                menu : {
                    items : []
                   }
            };
            for (var  i =0; i < this.specialChars.length; i++) {
                F.menu.items.push({
                    
                    text: this.specialChars[i],
                    handler: function(a,b) {
                        B.insertAtCursor(String.fromCharCode(a.text.replace('&#','').replace(';', '')));
                    },
                    tabIndex:-1
                });
            }

            
            
            tb.add(F);
            
            
        }
        if (this.btns) {
            for(var  i =0; i< this.btns.length;i++) {
                var  b = this.btns[i];
                b.cls =  'x-edit-none';
                b.scope = B;
                tb.add(b);
            }
        
        }

        
        
        
        // disable everything...
        
        this.tb.items.each(function(G){
           if(G.id != B.frameId+ '-sourceedit'){
                G.disable();
            }
        });
        this.rendered = true;
        
        // the all the btns;
        B.on('editorevent', this.updateToolbar, this);
        // other toolbars need to implement this..
        //editor.on('editmodechange', this.updateToolbar, this);
    },
    
    
    
    /**
     * Protected method that will not generally be called directly. It triggers
     * a toolbar update by reading the markup state of the current selection in the editor.
     */
    updateToolbar: function(){

        if(!this.editor.activated){
            this.editor.onFirstFocus();
            return;
        }

        var  G = this.tb.items.map, 
            H = this.editor.doc,
            I = this.editor.frameId;

        if(!this.disable.font && !Roo.isSafari){
            /*
            var name = (doc.queryCommandValue('FontName')||this.editor.defaultFont).toLowerCase();
            if(name != this.fontSelect.dom.value){
                this.fontSelect.dom.value = name;
            }
            */
        }
        if(!this.disable.format){
            G[I + '-bold'].toggle(H.queryCommandState('bold'));
            G[I + '-italic'].toggle(H.queryCommandState('italic'));
            G[I + '-underline'].toggle(H.queryCommandState('underline'));
        }
        if(!this.disable.alignments){
            G[I + '-justifyleft'].toggle(H.queryCommandState('justifyleft'));
            G[I + '-justifycenter'].toggle(H.queryCommandState('justifycenter'));
            G[I + '-justifyright'].toggle(H.queryCommandState('justifyright'));
        }
        if(!Roo.isSafari && !this.disable.lists){
            G[I + '-insertorderedlist'].toggle(H.queryCommandState('insertorderedlist'));
            G[I + '-insertunorderedlist'].toggle(H.queryCommandState('insertunorderedlist'));
        }
        
        var  J = this.editor.getAllAncestors();
        if (this.formatCombo) {
            
            
            var  store = this.formatCombo.store;
            this.formatCombo.setValue("");
            for (var  i =0; i < J.length;i++) {
                if (J[i] && store.query('tag',J[i].tagName.toLowerCase(), true).length) {
                    // select it..
                    this.formatCombo.setValue(J[i].tagName.toLowerCase());
                    break;
                }
            }
        }

        
        
        
        // hides menus... - so this cant be on a menu...
        Roo.menu.MenuMgr.hideAll();

        //this.editorsyncValue();
    },
   
    
    createFontOptions : function(){
        var  K = [], fs = this.fontFamilies, ff, lc;
        for(var  i = 0, len = fs.length; i< len; i++){
            ff = fs[i];
            lc = ff.toLowerCase();
            K.push(
                '<option value="',lc,'" style="font-family:',ff,';"',
                    (this.defaultFont == lc ? ' selected="true">' : '>'),
                    ff,
                '</option>'
            );
        }
        return  K.join('');
    },
    
    toggleSourceEdit : function(L){
        if(L === undefined){
            L = !this.sourceEditMode;
        }

        this.sourceEditMode = L === true;
        var  M = this.tb.items.get(this.editor.frameId +'-sourceedit');
        // just toggle the button?
        if(M.pressed !== this.editor.sourceEditMode){
            M.toggle(this.editor.sourceEditMode);
            return;
        }
        
        if(this.sourceEditMode){
            this.tb.items.each(function(N){
                if(N.cmd != 'sourceedit'){
                    N.disable();
                }
            });
          
        }else {
            if(this.initialized){
                this.tb.items.each(function(O){
                    O.enable();
                });
            }
            
        }

        // tell the editor that it's been pressed..
        this.editor.toggleSourceEdit(L);
       
    },
     /**
     * Object collection of toolbar tooltips for the buttons in the editor. The key
     * is the command id associated with that button and the value is a valid QuickTips object.
     * For example:
<pre><code>
{
    bold : {
        title: 'Bold (Ctrl+B)',
        text: 'Make the selected text bold.',
        cls: 'x-html-editor-tip'
    },
    italic : {
        title: 'Italic (Ctrl+I)',
        text: 'Make the selected text italic.',
        cls: 'x-html-editor-tip'
    },
    ...
</code></pre>
    * @type Object
     */
    buttonTips : {
        bold : {
            title: 'Bold (Ctrl+B)',
            text: 'Make the selected text bold.',
            cls: 'x-html-editor-tip'
        },
        italic : {
            title: 'Italic (Ctrl+I)',
            text: 'Make the selected text italic.',
            cls: 'x-html-editor-tip'
        },
        underline : {
            title: 'Underline (Ctrl+U)',
            text: 'Underline the selected text.',
            cls: 'x-html-editor-tip'
        },
        increasefontsize : {
            title: 'Grow Text',
            text: 'Increase the font size.',
            cls: 'x-html-editor-tip'
        },
        decreasefontsize : {
            title: 'Shrink Text',
            text: 'Decrease the font size.',
            cls: 'x-html-editor-tip'
        },
        backcolor : {
            title: 'Text Highlight Color',
            text: 'Change the background color of the selected text.',
            cls: 'x-html-editor-tip'
        },
        forecolor : {
            title: 'Font Color',
            text: 'Change the color of the selected text.',
            cls: 'x-html-editor-tip'
        },
        justifyleft : {
            title: 'Align Text Left',
            text: 'Align text to the left.',
            cls: 'x-html-editor-tip'
        },
        justifycenter : {
            title: 'Center Text',
            text: 'Center text in the editor.',
            cls: 'x-html-editor-tip'
        },
        justifyright : {
            title: 'Align Text Right',
            text: 'Align text to the right.',
            cls: 'x-html-editor-tip'
        },
        insertunorderedlist : {
            title: 'Bullet List',
            text: 'Start a bulleted list.',
            cls: 'x-html-editor-tip'
        },
        insertorderedlist : {
            title: 'Numbered List',
            text: 'Start a numbered list.',
            cls: 'x-html-editor-tip'
        },
        createlink : {
            title: 'Hyperlink',
            text: 'Make the selected text a hyperlink.',
            cls: 'x-html-editor-tip'
        },
        sourceedit : {
            title: 'Source Edit',
            text: 'Switch to source editing mode.',
            cls: 'x-html-editor-tip'
        }
    },
    // private
    onDestroy : function(){
        if(this.rendered){
            
            this.tb.items.each(function(N){
                if(N.menu){
                    N.menu.removeAll();
                    if(N.menu.el){
                        N.menu.el.destroy();
                    }
                }

                N.destroy();
            });
             
        }
    },
    onFirstFocus: function() {
        this.tb.items.each(function(N){
           N.enable();
        });
    }
});





// <script type="text/javascript">
/*
 * Based on
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *  
 
 */

 
/**
 * @class Roo.form.HtmlEditor.ToolbarContext
 * Context Toolbar
 * 
 * Usage:
 *
 new Roo.form.HtmlEditor({
    ....
    toolbars : [
        new Roo.form.HtmlEditor.ToolbarStandard(),
        new Roo.form.HtmlEditor.ToolbarContext()
        })
    }
     
 * 
 * @config : {Object} disable List of elements to disable.. (not done yet.)
 * 
 * 
 */

Roo.form.HtmlEditor.ToolbarContext = function(A)
{
    
    Roo.apply(this, A);
    //Roo.form.HtmlEditorToolbar1.superclass.constructor.call(this, editor.wrap.dom.firstChild, [], config);
    // dont call parent... till later.
}

Roo.form.HtmlEditor.ToolbarContext.types = {
    'IMG' : {
        width : {
            title: "Width",
            width: 40
        },
        height:  {
            title: "Height",
            width: 40
        },
        align: {
            title: "Align",
            opts : [ [""],[ "left"],[ "right"],[ "center"],[ "top"]],
            width : 80
            
        },
        border: {
            title: "Border",
            width: 40
        },
        alt: {
            title: "Alt",
            width: 120
        },
        src : {
            title: "Src",
            width: 220
        }
        
    },
    'A' : {
        name : {
            title: "Name",
            width: 50
        },
        href:  {
            title: "Href",
            width: 220
        } // border?
        
    },
    'TABLE' : {
        rows : {
            title: "Rows",
            width: 20
        },
        cols : {
            title: "Cols",
            width: 20
        },
        width : {
            title: "Width",
            width: 40
        },
        height : {
            title: "Height",
            width: 40
        },
        border : {
            title: "Border",
            width: 20
        }
    },
    'TD' : {
        width : {
            title: "Width",
            width: 40
        },
        height : {
            title: "Height",
            width: 40
        },   
        align: {
            title: "Align",
            opts : [[""],[ "left"],[ "center"],[ "right"],[ "justify"],[ "char"]],
            width: 40
        },
        valign: {
            title: "Valign",
            opts : [[""],[ "top"],[ "middle"],[ "bottom"],[ "baseline"]],
            width: 40
        },
        colspan: {
            title: "Colspan",
            width: 20
            
        }
    },
    'INPUT' : {
        name : {
            title: "name",
            width: 120
        },
        value : {
            title: "Value",
            width: 120
        },
        width : {
            title: "Width",
            width: 40
        }
    },
    'LABEL' : {
        'for' : {
            title: "For",
            width: 120
        }
    },
    'TEXTAREA' : {
          name : {
            title: "name",
            width: 120
        },
        rows : {
            title: "Rows",
            width: 20
        },
        cols : {
            title: "Cols",
            width: 20
        }
    },
    'SELECT' : {
        name : {
            title: "name",
            width: 120
        },
        selectoptions : {
            title: "Options",
            width: 200
        }
    },
    'BODY' : {
        title : {
            title: "title",
            width: 120,
            disabled : true
        }
    }
};



Roo.apply(Roo.form.HtmlEditor.ToolbarContext.prototype,  {
    
    tb: false,
    
    rendered: false,
    
    editor : false,
    /**
     * @cfg {Object} disable  List of toolbar elements to disable
         
     */
    disable : false,
    
    
    
    toolbars : false,
    
    init : function(B)
    {
        this.editor = B;
        
        
        var  C = B.frameId;
        var  D = this;
        function  E(id, G, H){
            var  I = C + '-'+ id ;
            return  {
                id : I,
                cmd : id,
                cls : 'x-btn-icon x-edit-'+id,
                enableToggle:G !== false,
                scope: B, // was editor...
                handler:H||B.relayBtnCmd,
                clickEvent:'mousedown',
                tooltip: D.buttonTips[id] || undefined, ///tips ???
                tabIndex:-1
            };
        }
        // create a new element.
        var  F = B.wrap.createChild({
                tag: 'div'
            }, B.wrap.dom.firstChild.nextSibling, true);
        
        // can we do this more than once??
        
         // stop form submits
      
 
        // disable everything...
        var  ty= Roo.form.HtmlEditor.ToolbarContext.types;
        this.toolbars = {};
           
        for (var  i  in   ty) {
            this.toolbars[i] = this.buildToolbar(ty[i],i);
        }

        this.tb = this.toolbars.BODY;
        this.tb.el.show();
        
         
        this.rendered = true;
        
        // the all the btns;
        B.on('editorevent', this.updateToolbar, this);
        // other toolbars need to implement this..
        //editor.on('editmodechange', this.updateToolbar, this);
    },
    
    
    
    /**
     * Protected method that will not generally be called directly. It triggers
     * a toolbar update by reading the markup state of the current selection in the editor.
     */
    updateToolbar: function(){

        if(!this.editor.activated){
            this.editor.onFirstFocus();
            return;
        }

        
        var  G = this.editor.getAllAncestors();
        
        // pick
        var  ty= Roo.form.HtmlEditor.ToolbarContext.types;
        var  H = G.length ? (G[0] ?  G[0]  : G[1]) : this.editor.doc.body;
        H = H ? H : this.editor.doc.body;
        H = H.tagName.length ? H : this.editor.doc.body;
        var  tn = H.tagName.toUpperCase();
        H = typeof(ty[tn]) != 'undefined' ? H : this.editor.doc.body;
        tn = H.tagName.toUpperCase();
        if (this.tb.name  == tn) {
            return; // no change
        }

        this.tb.el.hide();
        ///console.log("show: " + tn);
        this.tb =  this.toolbars[tn];
        this.tb.el.show();
        this.tb.fields.each(function(e) {
            e.setValue(H.getAttribute(e.name));
        });
        this.tb.selectedNode = H;
        
        
        Roo.menu.MenuMgr.hideAll();

        //this.editorsyncValue();
    },
   
       
    // private
    onDestroy : function(){
        if(this.rendered){
            
            this.tb.items.each(function(I){
                if(I.menu){
                    I.menu.removeAll();
                    if(I.menu.el){
                        I.menu.el.destroy();
                    }
                }

                I.destroy();
            });
             
        }
    },
    onFirstFocus: function() {
        // need to do this for all the toolbars..
        this.tb.items.each(function(I){
           I.enable();
        });
    },
    buildToolbar: function(I, nm)
    {
        var  J = this.editor;
         // create a new element.
        var  K = J.wrap.createChild({
                tag: 'div'
            }, J.wrap.dom.firstChild.nextSibling, true);
        
       
        var  tb = new  Roo.Toolbar(K);
        tb.add(nm+ ":&nbsp;");
        for (var  i  in  I) {
            var  item = I[i];
            tb.add(item.title + ":&nbsp;");
            if (item.opts) {
                // fixme
                
              
                tb.addField( new  Roo.form.ComboBox({
                    store: new  Roo.data.SimpleStore({
                        id : 'val',
                        fields: ['val'],
                        data : item.opts // from states.js
                    }),
                    name : i,
                    displayField:'val',
                    typeAhead: false,
                    mode: 'local',
                    editable : false,
                    triggerAction: 'all',
                    emptyText:'Select',
                    selectOnFocus:true,
                    width: item.width ? item.width  : 130,
                    listeners : {
                        'select': function(c, r, i) {
                            tb.selectedNode.setAttribute(c.name, r.get('val'));
                        }
                    }

                }));
                continue;
                    
                
                
                
                
                tb.addField( new  Roo.form.TextField({
                    name: i,
                    width: 100,
                    //allowBlank:false,
                    value: ''
                }));
                continue;
            }

            tb.addField( new  Roo.form.TextField({
                name: i,
                width: item.width,
                //allowBlank:true,
                value: '',
                listeners: {
                    'change' : function(f, nv, ov) {
                        tb.selectedNode.setAttribute(f.name, nv);
                    }
                }
            }));
             
        }

        tb.el.on('click', function(e){
            e.preventDefault(); // what does this do?
        });
        tb.el.setVisibilityMode( Roo.Element.DISPLAY);
        tb.el.hide();
        tb.name = nm;
        // dont need to disable them... as they will get hidden
        return  tb;
         
        
    }
    
    
    
    
});






/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.BasicForm
 * @extends Roo.util.Observable
 * Supplies the functionality to do "actions" on forms and initialize Roo.form.Field types on existing markup.
 * @constructor
 * @param {String/HTMLElement/Roo.Element} el The form element or its id
 * @param {Object} config Configuration options
 */
Roo.form.BasicForm = function(el, A){
    Roo.apply(this, A);
    /*
     * The Roo.form.Field items in this form.
     * @type MixedCollection
     */
    this.items = new  Roo.util.MixedCollection(false, function(o){
        return  o.id || (o.id = Roo.id());
    });
    this.addEvents({
        /**
         * @event beforeaction
         * Fires before any action is performed. Return false to cancel the action.
         * @param {Form} this
         * @param {Action} action The action to be performed
         */
        beforeaction: true,
        /**
         * @event actionfailed
         * Fires when an action fails.
         * @param {Form} this
         * @param {Action} action The action that failed
         */
        actionfailed : true,
        /**
         * @event actioncomplete
         * Fires when an action is completed.
         * @param {Form} this
         * @param {Action} action The action that completed
         */
        actioncomplete : true
    });
    if(el){
        this.initEl(el);
    }

    Roo.form.BasicForm.superclass.constructor.call(this);
};

Roo.extend(Roo.form.BasicForm, Roo.util.Observable, {
    /**
     * @cfg {String} method
     * The request method to use (GET or POST) for form actions if one isn't supplied in the action options.
     */
    /**
     * @cfg {DataReader} reader
     * An Roo.data.DataReader (e.g. {@link Roo.data.XmlReader}) to be used to read data when executing "load" actions.
     * This is optional as there is built-in support for processing JSON.
     */
    /**
     * @cfg {DataReader} errorReader
     * An Roo.data.DataReader (e.g. {@link Roo.data.XmlReader}) to be used to read data when reading validation errors on "submit" actions.
     * This is completely optional as there is built-in support for processing JSON.
     */
    /**
     * @cfg {String} url
     * The URL to use for form actions if one isn't supplied in the action options.
     */
    /**
     * @cfg {Boolean} fileUpload
     * Set to true if this form is a file upload.
     */
    /**
     * @cfg {Object} baseParams
     * Parameters to pass with all requests. e.g. baseParams: {id: '123', foo: 'bar'}.
     */
    /**
     * @cfg {Number} timeout Timeout for form actions in seconds (default is 30 seconds).
     */
    timeout: 30,

    // private
    activeAction : null,

    /**
     * @cfg {Boolean} trackResetOnLoad If set to true, form.reset() resets to the last loaded
     * or setValues() data instead of when the form was first created.
     */
    trackResetOnLoad : false,

    /**
     * By default wait messages are displayed with Roo.MessageBox.wait. You can target a specific
     * element by passing it or its id or mask the form itself by passing in true.
     * @type Mixed
     */
    waitMsgTarget : undefined,

    // private
    initEl : function(el){
        this.el = Roo.get(el);
        this.id = this.el.id || Roo.id();
        this.el.on('submit', this.onSubmit, this);
        this.el.addClass('x-form');
    },

    // private
    onSubmit : function(e){
        e.stopEvent();
    },

    /**
     * Returns true if client-side validation on the form is successful.
     * @return Boolean
     */
    isValid : function(){
        var  B = true;
        this.items.each(function(f){
           if(!f.validate()){
               B = false;
           }
        });
        return  B;
    },

    /**
     * Returns true if any fields in this form have changed since their original load.
     * @return Boolean
     */
    isDirty : function(){
        var  C = false;
        this.items.each(function(f){
           if(f.isDirty()){
               C = true;
               return  false;
           }
        });
        return  C;
    },

    /**
     * Performs a predefined action (submit or load) or custom actions you define on this form.
     * @param {String} actionName The name of the action type
     * @param {Object} options (optional) The options to pass to the action.  All of the config options listed
     * below are supported by both the submit and load actions unless otherwise noted (custom actions could also
     * accept other config options):
     * <pre>
Property          Type             Description
----------------  ---------------  ----------------------------------------------------------------------------------
url               String           The url for the action (defaults to the form's url)
method            String           The form method to use (defaults to the form's method, or POST if not defined)
params            String/Object    The params to pass (defaults to the form's baseParams, or none if not defined)
clientValidation  Boolean          Applies to submit only.  Pass true to call form.isValid() prior to posting to
                                   validate the form on the client (defaults to false)
     * </pre>
     * @return {BasicForm} this
     */
    doAction : function(D, E){
        if(typeof  D == 'string'){
            D = new  Roo.form.Action.ACTION_TYPES[D](this, E);
        }
        if(this.fireEvent('beforeaction', this, D) !== false){
            this.beforeAction(D);
            D.run.defer(100, D);
        }
        return  this;
    },

    /**
     * Shortcut to do a submit action.
     * @param {Object} options The options to pass to the action (see {@link #doAction} for details)
     * @return {BasicForm} this
     */
    submit : function(F){
        this.doAction('submit', F);
        return  this;
    },

    /**
     * Shortcut to do a load action.
     * @param {Object} options The options to pass to the action (see {@link #doAction} for details)
     * @return {BasicForm} this
     */
    load : function(G){
        this.doAction('load', G);
        return  this;
    },

    /**
     * Persists the values in this form into the passed Roo.data.Record object in a beginEdit/endEdit block.
     * @param {Record} record The record to edit
     * @return {BasicForm} this
     */
    updateRecord : function(H){
        H.beginEdit();
        var  fs = H.fields;
        fs.each(function(f){
            var  I = this.findField(f.name);
            if(I){
                H.set(f.name, I.getValue());
            }
        }, this);
        H.endEdit();
        return  this;
    },

    /**
     * Loads an Roo.data.Record into this form.
     * @param {Record} record The record to load
     * @return {BasicForm} this
     */
    loadRecord : function(I){
        this.setValues(I.data);
        return  this;
    },

    // private
    beforeAction : function(J){
        var  o = J.options;
        if(o.waitMsg){
            if(this.waitMsgTarget === true){
                this.el.mask(o.waitMsg, 'x-mask-loading');
            }else  if(this.waitMsgTarget){
                this.waitMsgTarget = Roo.get(this.waitMsgTarget);
                this.waitMsgTarget.mask(o.waitMsg, 'x-mask-loading');
            }else {
                Roo.MessageBox.wait(o.waitMsg, o.waitTitle || this.waitTitle || 'Please Wait...');
            }
        }
    },

    // private
    afterAction : function(K, L){
        this.activeAction = null;
        var  o = K.options;
        if(o.waitMsg){
            if(this.waitMsgTarget === true){
                this.el.unmask();
            }else  if(this.waitMsgTarget){
                this.waitMsgTarget.unmask();
            }else {
                Roo.MessageBox.updateProgress(1);
                Roo.MessageBox.hide();
            }
        }
        if(L){
            if(o.reset){
                this.reset();
            }

            Roo.callback(o.success, o.scope, [this, K]);
            this.fireEvent('actioncomplete', this, K);
        }else {
            Roo.callback(o.failure, o.scope, [this, K]);
            this.fireEvent('actionfailed', this, K);
        }
    },

    /**
     * Find a Roo.form.Field in this form by id, dataIndex, name or hiddenName
     * @param {String} id The value to search for
     * @return Field
     */
    findField : function(id){
        var  M = this.items.get(id);
        if(!M){
            this.items.each(function(f){
                if(f.isFormField && (f.dataIndex == id || f.id == id || f.getName() == id)){
                    M = f;
                    return  false;
                }
            });
        }
        return  M || null;
    },


    /**
     * Mark fields in this form invalid in bulk.
     * @param {Array/Object} errors Either an array in the form [{id:'fieldId', msg:'The message'},...] or an object hash of {id: msg, id2: msg2}
     * @return {BasicForm} this
     */
    markInvalid : function(N){
        if(N  instanceof  Array){
            for(var  i = 0, len = N.length; i < len; i++){
                var  fieldError = N[i];
                var  f = this.findField(fieldError.id);
                if(f){
                    f.markInvalid(fieldError.msg);
                }
            }
        }else {
            var  M, id;
            for(id  in  N){
                if(typeof  N[id] != 'function' && (M = this.findField(id))){
                    M.markInvalid(N[id]);
                }
            }
        }
        return  this;
    },

    /**
     * Set values for fields in this form in bulk.
     * @param {Array/Object} values Either an array in the form [{id:'fieldId', value:'foo'},...] or an object hash of {id: value, id2: value2}
     * @return {BasicForm} this
     */
    setValues : function(O){
        if(O  instanceof  Array){ // array of objects
            for(var  i = 0, len = O.length; i < len; i++){
                var  v = O[i];
                var  f = this.findField(v.id);
                if(f){
                    f.setValue(v.value);
                    if(this.trackResetOnLoad){
                        f.originalValue = f.getValue();
                    }
                }
            }
        }else { // object hash
            var  M, id;
            for(id  in  O){
                if(typeof  O[id] != 'function' && (M = this.findField(id))){
                    
                    if (M.setFromData && 
                        M.valueField && 
                        M.displayField &&
                        // combos' with local stores can 
                        // be queried via setValue()
                        // to set their value..
                        (M.store && !M.store.isLocal)
                        ) {
                        // it's a combo
                        var  sd = { };
                        sd[M.valueField] = typeof(O[M.hiddenName]) == 'undefined' ? '' : O[M.hiddenName];
                        sd[M.displayField] = typeof(O[M.name]) == 'undefined' ? '' : O[M.name];
                        M.setFromData(sd);
                        
                    } else  {
                        M.setValue(O[id]);
                    }
                    
                    
                    if(this.trackResetOnLoad){
                        M.originalValue = M.getValue();
                    }
                }
            }
        }
        return  this;
    },

    /**
     * Returns the fields in this form as an object with key/value pairs. If multiple fields exist with the same name
     * they are returned as an array.
     * @param {Boolean} asString
     * @return {Object}
     */
    getValues : function(P){
        var  fs = Roo.lib.Ajax.serializeForm(this.el.dom);
        if(P === true){
            return  fs;
        }
        return  Roo.urlDecode(fs);
    },

    /**
     * Clears all invalid messages in this form.
     * @return {BasicForm} this
     */
    clearInvalid : function(){
        this.items.each(function(f){
           f.clearInvalid();
        });
        return  this;
    },

    /**
     * Resets this form.
     * @return {BasicForm} this
     */
    reset : function(){
        this.items.each(function(f){
            f.reset();
        });
        return  this;
    },

    /**
     * Add Roo.form components to this form.
     * @param {Field} field1
     * @param {Field} field2 (optional)
     * @param {Field} etc (optional)
     * @return {BasicForm} this
     */
    add : function(){
        this.items.addAll(Array.prototype.slice.call(arguments, 0));
        return  this;
    },


    /**
     * Removes a field from the items collection (does NOT remove its markup).
     * @param {Field} field
     * @return {BasicForm} this
     */
    remove : function(Q){
        this.items.remove(Q);
        return  this;
    },

    /**
     * Looks at the fields in this form, checks them for an id attribute,
     * and calls applyTo on the existing dom element with that id.
     * @return {BasicForm} this
     */
    render : function(){
        this.items.each(function(f){
            if(f.isFormField && !f.rendered && document.getElementById(f.id)){ // if the element exists
                f.applyTo(f.id);
            }
        });
        return  this;
    },

    /**
     * Calls {@link Ext#apply} for all fields in this form with the passed object.
     * @param {Object} values
     * @return {BasicForm} this
     */
    applyToFields : function(o){
        this.items.each(function(f){
           Roo.apply(f, o);
        });
        return  this;
    },

    /**
     * Calls {@link Ext#applyIf} for all field in this form with the passed object.
     * @param {Object} values
     * @return {BasicForm} this
     */
    applyIfToFields : function(o){
        this.items.each(function(f){
           Roo.applyIf(f, o);
        });
        return  this;
    }
});

// back compat
Roo.BasicForm = Roo.form.BasicForm;
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.form.Form
 * @extends Roo.form.BasicForm
 * Adds the ability to dynamically render forms with JavaScript to {@link Roo.form.BasicForm}.
 * @constructor
 * @param {Object} config Configuration options
 */
Roo.form.Form = function(A){
    var  B =  [];
    if (A.items) {
        B = A.items;
        delete  A.items;
    }

    
    
    Roo.form.Form.superclass.constructor.call(this, null, A);
    this.url = this.url || this.action;
    if(!this.root){
        this.root = new  Roo.form.Layout(Roo.applyIf({
            id: Roo.id()
        }, A));
    }

    this.active = this.root;
    /**
     * Array of all the buttons that have been added to this form via {@link addButton}
     * @type Array
     */
    this.buttons = [];
    this.allItems = [];
    this.addEvents({
        /**
         * @event clientvalidation
         * If the monitorValid config option is true, this event fires repetitively to notify of valid state
         * @param {Form} this
         * @param {Boolean} valid true if the form has passed client-side validation
         */
        clientvalidation: true,
        /**
         * @event rendered
         * Fires when the form is rendered
         * @param {Roo.form.Form} form
         */
        rendered : true
    });
    
    Roo.each(B, this.addxtype, this);
    
    
    
};

Roo.extend(Roo.form.Form, Roo.form.BasicForm, {
    /**
     * @cfg {Number} labelWidth The width of labels. This property cascades to child containers.
     */
    /**
     * @cfg {String} itemCls A css class to apply to the x-form-item of fields. This property cascades to child containers.
     */
    /**
     * @cfg {String} buttonAlign Valid values are "left," "center" and "right" (defaults to "center")
     */
    buttonAlign:'center',

    /**
     * @cfg {Number} minButtonWidth Minimum width of all buttons in pixels (defaults to 75)
     */
    minButtonWidth:75,

    /**
     * @cfg {String} labelAlign Valid values are "left," "top" and "right" (defaults to "left").
     * This property cascades to child containers if not set.
     */
    labelAlign:'left',

    /**
     * @cfg {Boolean} monitorValid If true the form monitors its valid state <b>client-side</b> and
     * fires a looping event with that state. This is required to bind buttons to the valid
     * state using the config value formBind:true on the button.
     */
    monitorValid : false,

    /**
     * @cfg {Number} monitorPoll The milliseconds to poll valid state, ignored if monitorValid is not true (defaults to 200)
     */
    monitorPoll : 200,

    /**
     * Opens a new {@link Roo.form.Column} container in the layout stack. If fields are passed after the config, the
     * fields are added and the column is closed. If no fields are passed the column remains open
     * until end() is called.
     * @param {Object} config The config to pass to the column
     * @param {Field} field1 (optional)
     * @param {Field} field2 (optional)
     * @param {Field} etc (optional)
     * @return Column The column container object
     */
    column : function(c){
        var  C = new  Roo.form.Column(c);
        this.start(C);
        if(arguments.length > 1){ // duplicate code required because of Opera
            this.add.apply(this, Array.prototype.slice.call(arguments, 1));
            this.end();
        }
        return  C;
    },

    /**
     * Opens a new {@link Roo.form.FieldSet} container in the layout stack. If fields are passed after the config, the
     * fields are added and the fieldset is closed. If no fields are passed the fieldset remains open
     * until end() is called.
     * @param {Object} config The config to pass to the fieldset
     * @param {Field} field1 (optional)
     * @param {Field} field2 (optional)
     * @param {Field} etc (optional)
     * @return FieldSet The fieldset container object
     */
    fieldset : function(c){
        var  fs = new  Roo.form.FieldSet(c);
        this.start(fs);
        if(arguments.length > 1){ // duplicate code required because of Opera
            this.add.apply(this, Array.prototype.slice.call(arguments, 1));
            this.end();
        }
        return  fs;
    },

    /**
     * Opens a new {@link Roo.form.Layout} container in the layout stack. If fields are passed after the config, the
     * fields are added and the container is closed. If no fields are passed the container remains open
     * until end() is called.
     * @param {Object} config The config to pass to the Layout
     * @param {Field} field1 (optional)
     * @param {Field} field2 (optional)
     * @param {Field} etc (optional)
     * @return Layout The container object
     */
    container : function(c){
        var  l = new  Roo.form.Layout(c);
        this.start(l);
        if(arguments.length > 1){ // duplicate code required because of Opera
            this.add.apply(this, Array.prototype.slice.call(arguments, 1));
            this.end();
        }
        return  l;
    },

    /**
     * Opens the passed container in the layout stack. The container can be any {@link Roo.form.Layout} or subclass.
     * @param {Object} container A Roo.form.Layout or subclass of Layout
     * @return {Form} this
     */
    start : function(c){
        // cascade label info
        Roo.applyIf(c, {'labelAlign': this.active.labelAlign, 'labelWidth': this.active.labelWidth, 'itemCls': this.active.itemCls});
        this.active.stack.push(c);
        c.ownerCt = this.active;
        this.active = c;
        return  this;
    },

    /**
     * Closes the current open container
     * @return {Form} this
     */
    end : function(){
        if(this.active == this.root){
            return  this;
        }

        this.active = this.active.ownerCt;
        return  this;
    },

    /**
     * Add Roo.form components to the current open container (e.g. column, fieldset, etc.).  Fields added via this method
     * can also be passed with an additional property of fieldLabel, which if supplied, will provide the text to display
     * as the label of the field.
     * @param {Field} field1
     * @param {Field} field2 (optional)
     * @param {Field} etc. (optional)
     * @return {Form} this
     */
    add : function(){
        this.active.stack.push.apply(this.active.stack, arguments);
        this.allItems.push.apply(this.allItems,arguments);
        var  r = [];
        for(var  i = 0, a = arguments, len = a.length; i < len; i++) {
            if(a[i].isFormField){
                r.push(a[i]);
            }
        }
        if(r.length > 0){
            Roo.form.Form.superclass.add.apply(this, r);
        }
        return  this;
    },
     /**
     * Find any element that has been added to a form, using it's ID or name
     * This can include framesets, columns etc. along with regular fields..
     * @param {String} id - id or name to find.
     
     * @return {Element} e - or false if nothing found.
     */
    findbyId : function(id)
    {
        var  D = false;
        if (!id) {
            return  D;
        }

        Ext.each(this.allItems, function(f){
            if (f.id == id || f.name == id ){
                D = f;
                return  false;
            }
        });
        return  D;
    },

    
    
    /**
     * Render this form into the passed container. This should only be called once!
     * @param {String/HTMLElement/Element} container The element this component should be rendered into
     * @return {Form} this
     */
    render : function(ct){
        ct = Roo.get(ct);
        var  o = this.autoCreate || {
            tag: 'form',
            method : this.method || 'POST',
            id : this.id || Roo.id()
        };
        this.initEl(ct.createChild(o));

        this.root.render(this.el);

        this.items.each(function(f){
            f.render('x-form-el-'+f.id);
        });

        if(this.buttons.length > 0){
            // tables are required to maintain order and for correct IE layout
            var  tb = this.el.createChild({cls:'x-form-btns-ct', cn: {
                cls:"x-form-btns x-form-btns-"+this.buttonAlign,
                html:'<table cellspacing="0"><tbody><tr></tr></tbody></table><div class="x-clear"></div>'
            }}, null, true);
            var  tr = tb.getElementsByTagName('tr')[0];
            for(var  i = 0, len = this.buttons.length; i < len; i++) {
                var  b = this.buttons[i];
                var  td = document.createElement('td');
                td.className = 'x-form-btn-td';
                b.render(tr.appendChild(td));
            }
        }
        if(this.monitorValid){ // initialize after render
            this.startMonitoring();
        }

        this.fireEvent('rendered', this);
        return  this;
    },

    /**
     * Adds a button to the footer of the form - this <b>must</b> be called before the form is rendered.
     * @param {String/Object} config A string becomes the button text, an object can either be a Button config
     * object or a valid Roo.DomHelper element config
     * @param {Function} handler The function called when the button is clicked
     * @param {Object} scope (optional) The scope of the handler function
     * @return {Roo.Button}
     */
    addButton : function(E, F, G){
        var  bc = {
            handler: F,
            scope: G,
            minWidth: this.minButtonWidth,
            hideParent:true
        };
        if(typeof  E == "string"){
            bc.text = E;
        }else {
            Roo.apply(bc, E);
        }
        var  H = new  Roo.Button(null, bc);
        this.buttons.push(H);
        return  H;
    },

     /**
     * Adds a series of form elements (using the xtype property as the factory method.
     * Valid xtypes are:  TextField, TextArea .... Button, Layout, FieldSet, Column, (and 'end' to close a block)
     * @param {Object} config 
     */
    
    addxtype : function()
    {
        var  ar = Array.prototype.slice.call(arguments, 0);
        var  I = false;
        for(var  i = 0; i < ar.length; i++) {
            if (!ar[i]) {
                continue; // skip -- if this happends something invalid got sent, we 
                // should ignore it, as basically that interface element will not show up
                // and that should be pretty obvious!!
            }
            
            if (Roo.form[ar[i].xtype]) {
                ar[i].form = this;
                var  fe = Roo.factory(ar[i], Roo.form);
                if (!I) {
                    I = fe;
                }

                fe.form = this;
                if (fe.store) {
                    fe.store.form = this;
                }
                if (fe.isLayout) {  
                         
                    this.start(fe);
                    this.allItems.push(fe);
                    if (fe.items && fe.addxtype) {
                        fe.addxtype.apply(fe, fe.items);
                        delete  fe.items;
                    }

                     this.end();
                    continue;
                }

                
                
                 
                this.add(fe);
              //  console.log('adding ' + ar[i].xtype);
            }
            if (ar[i].xtype == 'Button') {  
                //console.log('adding button');
                //console.log(ar[i]);
                this.addButton(ar[i]);
                this.allItems.push(fe);
                continue;
            }
            
            if (ar[i].xtype == 'end') { // so we can add fieldsets... / layout etc.
                alert('end is not supported on xtype any more, use items');
            //    this.end();
            //    //console.log('adding end');
            }
            
        }
        return  I;
    },
    
    /**
     * Starts monitoring of the valid state of this form. Usually this is done by passing the config
     * option "monitorValid"
     */
    startMonitoring : function(){
        if(!this.bound){
            this.bound = true;
            Roo.TaskMgr.start({
                run : this.bindHandler,
                interval : this.monitorPoll || 200,
                scope: this
            });
        }
    },

    /**
     * Stops monitoring of the valid state of this form
     */
    stopMonitoring : function(){
        this.bound = false;
    },

    // private
    bindHandler : function(){
        if(!this.bound){
            return  false; // stops binding
        }
        var  J = true;
        this.items.each(function(f){
            if(!f.isValid(true)){
                J = false;
                return  false;
            }
        });
        for(var  i = 0, len = this.buttons.length; i < len; i++){
            var  H = this.buttons[i];
            if(H.formBind === true && H.disabled === J){
                H.setDisabled(!J);
            }
        }

        this.fireEvent('clientvalidation', this, J);
    }
    
    
    
    
    
    
    
    
});


// back compat
Roo.Form = Roo.form.Form;

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
 /**
 * @class Roo.form.Action
 * Internal Class used to handle form actions
 * @constructor
 * @param {Roo.form.BasicForm} el The form element or its id
 * @param {Object} config Configuration options
 */
 
 
// define the action interface
Roo.form.Action = function(A, B){
    this.form = A;
    this.options = B || {};
};
/**
 * Client Validation Failed
 * @const 
 */
Roo.form.Action.CLIENT_INVALID = 'client';
/**
 * Server Validation Failed
 * @const 
 */
 Roo.form.Action.SERVER_INVALID = 'server';
 /**
 * Connect to Server Failed
 * @const 
 */
Roo.form.Action.CONNECT_FAILURE = 'connect';
/**
 * Reading Data from Server Failed
 * @const 
 */
Roo.form.Action.LOAD_FAILURE = 'load';

Roo.form.Action.prototype = {
    type : 'default',
    failureType : undefined,
    response : undefined,
    result : undefined,

    // interface method
    run : function(C){

    },

    // interface method
    success : function(D){

    },

    // interface method
    handleResponse : function(E){

    },

    // default connection failure
    failure : function(F){
        this.response = F;
        this.failureType = Roo.form.Action.CONNECT_FAILURE;
        this.form.afterAction(this, false);
    },

    processResponse : function(G){
        this.response = G;
        if(!G.responseText){
            return  true;
        }

        this.result = this.handleResponse(G);
        return  this.result;
    },

    // utility functions used internally
    getUrl : function(H){
        var  I = this.options.url || this.form.url || this.form.el.dom.action;
        if(H){
            var  p = this.getParams();
            if(p){
                I += (I.indexOf('?') != -1 ? '&' : '?') + p;
            }
        }
        return  I;
    },

    getMethod : function(){
        return  (this.options.method || this.form.method || this.form.el.dom.method || 'POST').toUpperCase();
    },

    getParams : function(){
        var  bp = this.form.baseParams;
        var  p = this.options.params;
        if(p){
            if(typeof  p == "object"){
                p = Roo.urlEncode(Roo.applyIf(p, bp));
            }else  if(typeof  p == 'string' && bp){
                p += '&' + Roo.urlEncode(bp);
            }
        }else  if(bp){
            p = Roo.urlEncode(bp);
        }
        return  p;
    },

    createCallback : function(){
        return  {
            success: this.success,
            failure: this.failure,
            scope: this,
            timeout: (this.form.timeout*1000),
            upload: this.form.fileUpload ? this.success : undefined
        };
    }
};

Roo.form.Action.Submit = function(J, K){
    Roo.form.Action.Submit.superclass.constructor.call(this, J, K);
};

Roo.extend(Roo.form.Action.Submit, Roo.form.Action, {
    type : 'submit',

    run : function(){
        var  o = this.options;
        var  L = this.getMethod();
        var  M = L == 'POST';
        if(o.clientValidation === false || this.form.isValid()){
            Roo.Ajax.request(Roo.apply(this.createCallback(), {
                form:this.form.el.dom,
                url:this.getUrl(!M),
                method: L,
                params:M ? this.getParams() : null,
                isUpload: this.form.fileUpload
            }));

        }else  if (o.clientValidation !== false){ // client validation failed
            this.failureType = Roo.form.Action.CLIENT_INVALID;
            this.form.afterAction(this, false);
        }
    },

    success : function(N){
        var  O = this.processResponse(N);
        if(O === true || O.success){
            this.form.afterAction(this, true);
            return;
        }
        if(O.errors){
            this.form.markInvalid(O.errors);
            this.failureType = Roo.form.Action.SERVER_INVALID;
        }

        this.form.afterAction(this, false);
    },

    handleResponse : function(P){
        if(this.form.errorReader){
            var  rs = this.form.errorReader.read(P);
            var  errors = [];
            if(rs.records){
                for(var  i = 0, len = rs.records.length; i < len; i++) {
                    var  r = rs.records[i];
                    errors[i] = r.data;
                }
            }
            if(errors.length < 1){
                errors = null;
            }
            return  {
                success : rs.success,
                errors : errors
            };
        }
        var  Q = false;
        try {
            Q = Roo.decode(P.responseText);
        } catch (e) {
            ret = {
                success: false,
                errorMsg: "Failed to read server message: " + response.responseText,
                errors : []
            };
        }
        return  Q;
        
    }
});


Roo.form.Action.Load = function(R, S){
    Roo.form.Action.Load.superclass.constructor.call(this, R, S);
    this.reader = this.form.reader;
};

Roo.extend(Roo.form.Action.Load, Roo.form.Action, {
    type : 'load',

    run : function(){
        Roo.Ajax.request(Roo.apply(
                this.createCallback(), {
                    method:this.getMethod(),
                    url:this.getUrl(false),
                    params:this.getParams()
        }));
    },

    success : function(T){
        var  U = this.processResponse(T);
        if(U === true || !U.success || !U.data){
            this.failureType = Roo.form.Action.LOAD_FAILURE;
            this.form.afterAction(this, false);
            return;
        }

        this.form.clearInvalid();
        this.form.setValues(U.data);
        this.form.afterAction(this, true);
    },

    handleResponse : function(V){
        if(this.form.reader){
            var  rs = this.form.reader.read(V);
            var  data = rs.records && rs.records[0] ? rs.records[0].data : null;
            return  {
                success : rs.success,
                data : data
            };
        }
        return  Roo.decode(V.responseText);
    }
});

Roo.form.Action.ACTION_TYPES = {
    'load' : Roo.form.Action.Load,
    'submit' : Roo.form.Action.Submit
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.form.Layout
 * @extends Roo.Component
 * Creates a container for layout and rendering of fields in an {@link Roo.form.Form}.
 * @constructor
 * @param {Object} config Configuration options
 */
Roo.form.Layout = function(A){
    var  B = [];
    if (A.items) {
        B = A.items;
        delete  A.items;
    }

    Roo.form.Layout.superclass.constructor.call(this, A);
    this.stack = [];
    Roo.each(B, this.addxtype, this);
     
};

Roo.extend(Roo.form.Layout, Roo.Component, {
    /**
     * @cfg {String/Object} autoCreate
     * A DomHelper element spec used to autocreate the layout (defaults to {tag: 'div', cls: 'x-form-ct'})
     */
    /**
     * @cfg {String/Object/Function} style
     * A style specification string, e.g. "width:100px", or object in the form {width:"100px"}, or
     * a function which returns such a specification.
     */
    /**
     * @cfg {String} labelAlign
     * Valid values are "left," "top" and "right" (defaults to "left")
     */
    /**
     * @cfg {Number} labelWidth
     * Fixed width in pixels of all field labels (defaults to undefined)
     */
    /**
     * @cfg {Boolean} clear
     * True to add a clearing element at the end of this layout, equivalent to CSS clear: both (defaults to true)
     */
    clear : true,
    /**
     * @cfg {String} labelSeparator
     * The separator to use after field labels (defaults to ':')
     */
    labelSeparator : ':',
    /**
     * @cfg {Boolean} hideLabels
     * True to suppress the display of field labels in this layout (defaults to false)
     */
    hideLabels : false,

    // private
    defaultAutoCreate : {tag: 'div', cls: 'x-form-ct'},
    
    isLayout : true,
    
    // private
    onRender : function(ct, C){
        if(this.el){ // from markup
            this.el = Roo.get(this.el);
        }else  {  // generate
            var  cfg = this.getAutoCreate();
            this.el = ct.createChild(cfg, C);
        }
        if(this.style){
            this.el.applyStyles(this.style);
        }
        if(this.labelAlign){
            this.el.addClass('x-form-label-'+this.labelAlign);
        }
        if(this.hideLabels){
            this.labelStyle = "display:none";
            this.elementStyle = "padding-left:0;";
        }else {
            if(typeof  this.labelWidth == 'number'){
                this.labelStyle = "width:"+this.labelWidth+"px;";
                this.elementStyle = "padding-left:"+((this.labelWidth+(typeof  this.labelPad == 'number' ? this.labelPad : 5))+'px')+";";
            }
            if(this.labelAlign == 'top'){
                this.labelStyle = "width:auto;";
                this.elementStyle = "padding-left:0;";
            }
        }
        var  D = this.stack;
        var  E = D.length;
        if(E > 0){
            if(!this.fieldTpl){
                var  t = new  Roo.Template(
                    '<div class="x-form-item {5}">',
                        '<label for="{0}" style="{2}">{1}{4}</label>',
                        '<div class="x-form-element" id="x-form-el-{0}" style="{3}">',
                        '</div>',
                    '</div><div class="x-form-clear-left"></div>'
                );
                t.disableFormats = true;
                t.compile();
                Roo.form.Layout.prototype.fieldTpl = t;
            }
            for(var  i = 0; i < E; i++) {
                if(D[i].isFormField){
                    this.renderField(D[i]);
                }else {
                    this.renderComponent(D[i]);
                }
            }
        }
        if(this.clear){
            this.el.createChild({cls:'x-form-clear'});
        }
    },

    // private
    renderField : function(f){
        f.fieldEl = Roo.get(this.fieldTpl.append(this.el, [
               f.id, //0
               f.fieldLabel, //1
               f.labelStyle||this.labelStyle||'', //2
               this.elementStyle||'', //3
               typeof  f.labelSeparator == 'undefined' ? this.labelSeparator : f.labelSeparator, //4
               f.itemCls||this.itemCls||''  //5
       ], true).getPrevSibling());
    },

    // private
    renderComponent : function(c){
        c.render(c.isLayout ? this.el : this.el.createChild());    
    },
    /**
     * Adds a object form elements (using the xtype property as the factory method.)
     * Valid xtypes are:  TextField, TextArea .... Button, Layout, FieldSet, Column
     * @param {Object} config 
     */
    addxtype : function(o)
    {
        // create the lement.
        o.form = this.form;
        var  fe = Roo.factory(o, Roo.form);
        this.form.allItems.push(fe);
        this.stack.push(fe);
        
        if (fe.isFormField) {
            this.form.items.add(fe);
        }
         
        return  fe;
    }
});

/**
 * @class Roo.form.Column
 * @extends Roo.form.Layout
 * Creates a column container for layout and rendering of fields in an {@link Roo.form.Form}.
 * @constructor
 * @param {Object} config Configuration options
 */
Roo.form.Column = function(F){
    Roo.form.Column.superclass.constructor.call(this, F);
};

Roo.extend(Roo.form.Column, Roo.form.Layout, {
    /**
     * @cfg {Number/String} width
     * The fixed width of the column in pixels or CSS value (defaults to "auto")
     */
    /**
     * @cfg {String/Object} autoCreate
     * A DomHelper element spec used to autocreate the column (defaults to {tag: 'div', cls: 'x-form-ct x-form-column'})
     */

    // private
    defaultAutoCreate : {tag: 'div', cls: 'x-form-ct x-form-column'},

    // private
    onRender : function(ct, G){
        Roo.form.Column.superclass.onRender.call(this, ct, G);
        if(this.width){
            this.el.setWidth(this.width);
        }
    }
});


/**
 * @class Roo.form.Row
 * @extends Roo.form.Layout
 * Creates a row container for layout and rendering of fields in an {@link Roo.form.Form}.
 * @constructor
 * @param {Object} config Configuration options
 */

 
Roo.form.Row = function(H){
    Roo.form.Row.superclass.constructor.call(this, H);
};
 
Roo.extend(Roo.form.Row, Roo.form.Layout, {
      /**
     * @cfg {Number/String} width
     * The fixed width of the column in pixels or CSS value (defaults to "auto")
     */
    /**
     * @cfg {Number/String} height
     * The fixed height of the column in pixels or CSS value (defaults to "auto")
     */
    defaultAutoCreate : {tag: 'div', cls: 'x-form-ct x-form-row'},
    
    padWidth : 20,
    // private
    onRender : function(ct, I){
        //console.log('row render');
        if(!this.rowTpl){
            var  t = new  Roo.Template(
                '<div class="x-form-item {5}" style="float:left;width:{6}px">',
                    '<label for="{0}" style="{2}">{1}{4}</label>',
                    '<div class="x-form-element" id="x-form-el-{0}" style="{3}">',
                    '</div>',
                '</div>'
            );
            t.disableFormats = true;
            t.compile();
            Roo.form.Layout.prototype.rowTpl = t;
        }

        this.fieldTpl = this.rowTpl;
        
        //console.log('lw' + this.labelWidth +', la:' + this.labelAlign);
        var  J = 100;
        
        if ((this.labelAlign != 'top')) {
            if (typeof  this.labelWidth == 'number') {
                J = this.labelWidth
            }

            this.padWidth =  20 + J;
            
        }

        
        Roo.form.Column.superclass.onRender.call(this, ct, I);
        if(this.width){
            this.el.setWidth(this.width);
        }
        if(this.height){
            this.el.setHeight(this.height);
        }
    },
    
    // private
    renderField : function(f){
        f.fieldEl = this.fieldTpl.append(this.el, [
               f.id, f.fieldLabel,
               f.labelStyle||this.labelStyle||'',
               this.elementStyle||'',
               typeof  f.labelSeparator == 'undefined' ? this.labelSeparator : f.labelSeparator,
               f.itemCls||this.itemCls||'',
               f.width ? f.width + this.padWidth : 160 + this.padWidth
       ],true);
    }
});
 

/**
 * @class Roo.form.FieldSet
 * @extends Roo.form.Layout
 * Creates a fieldset container for layout and rendering of fields in an {@link Roo.form.Form}.
 * @constructor
 * @param {Object} config Configuration options
 */
Roo.form.FieldSet = function(K){
    Roo.form.FieldSet.superclass.constructor.call(this, K);
};

Roo.extend(Roo.form.FieldSet, Roo.form.Layout, {
    /**
     * @cfg {String} legend
     * The text to display as the legend for the FieldSet (defaults to '')
     */
    /**
     * @cfg {String/Object} autoCreate
     * A DomHelper element spec used to autocreate the fieldset (defaults to {tag: 'fieldset', cn: {tag:'legend'}})
     */

    // private
    defaultAutoCreate : {tag: 'fieldset', cn: {tag:'legend'}},

    // private
    onRender : function(ct, L){
        Roo.form.FieldSet.superclass.onRender.call(this, ct, L);
        if(this.legend){
            this.setLegend(this.legend);
        }
    },

    // private
    setLegend : function(M){
        if(this.rendered){
            this.el.child('legend').update(M);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.form.VTypes
 * Overridable validation definitions. The validations provided are basic and intended to be easily customizable and extended.
 * @singleton
 */
Roo.form.VTypes = function(){
    // closure these in so they are only created once.
    var  A = /^[a-zA-Z_]+$/;
    var  B = /^[a-zA-Z0-9_]+$/;
    var  C = /^([\w]+)(.[\w]+)*@([\w-]+\.){1,5}([A-Za-z]){2,4}$/;
    var  D = /(((https?)|(ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;

    // All these messages and functions are configurable
    return  {
        /**
         * The function used to validate email addresses
         * @param {String} value The email address
         */
        'email' : function(v){
            return  C.test(v);
        },
        /**
         * The error text to display when the email validation function returns false
         * @type String
         */
        'emailText' : 'This field should be an e-mail address in the format "user@domain.com"',
        /**
         * The keystroke filter mask to be applied on email input
         * @type RegExp
         */
        'emailMask' : /[a-z0-9_\.\-@]/i,

        /**
         * The function used to validate URLs
         * @param {String} value The URL
         */
        'url' : function(v){
            return  D.test(v);
        },
        /**
         * The error text to display when the url validation function returns false
         * @type String
         */
        'urlText' : 'This field should be a URL in the format "http:/'+'/www.domain.com"',
        
        /**
         * The function used to validate alpha values
         * @param {String} value The value
         */
        'alpha' : function(v){
            return  A.test(v);
        },
        /**
         * The error text to display when the alpha validation function returns false
         * @type String
         */
        'alphaText' : 'This field should only contain letters and _',
        /**
         * The keystroke filter mask to be applied on alpha input
         * @type RegExp
         */
        'alphaMask' : /[a-z_]/i,

        /**
         * The function used to validate alphanumeric values
         * @param {String} value The value
         */
        'alphanum' : function(v){
            return  B.test(v);
        },
        /**
         * The error text to display when the alphanumeric validation function returns false
         * @type String
         */
        'alphanumText' : 'This field should only contain letters, numbers and _',
        /**
         * The keystroke filter mask to be applied on alphanumeric input
         * @type RegExp
         */
        'alphanumMask' : /[a-z0-9_]/i
    };
}();
//<script type="text/javascript">

/**
 * @class Roo.form.FCKeditor
 * @extends Roo.form.TextArea
 * Wrapper around the FCKEditor http://www.fckeditor.net
 * @constructor
 * Creates a new FCKeditor
 * @param {Object} config Configuration options
 */
Roo.form.FCKeditor = function(A){
    Roo.form.FCKeditor.superclass.constructor.call(this, A);
    this.addEvents({
         /**
         * @event editorinit
         * Fired when the editor is initialized - you can add extra handlers here..
         * @param {FCKeditor} this
         * @param {Object} the FCK object.
         */
        editorinit : true
    });
    
    
};
Roo.form.FCKeditor.editors = { };
Roo.extend(Roo.form.FCKeditor, Roo.form.TextArea,
{
    //defaultAutoCreate : {
    //    tag : "textarea",style   : "width:100px;height:60px;" ,autocomplete    : "off"
    //},
    // private
    /**
     * @cfg {Object} fck options - see fck manual for details.
     */
    fckconfig : false,
    
    /**
     * @cfg {Object} fck toolbar set (Basic or Default)
     */
    toolbarSet : 'Basic',
    /**
     * @cfg {Object} fck BasePath
     */ 
    basePath : '/fckeditor/',
    
    
    frame : false,
    
    value : '',
    
   
    onRender : function(ct, B)
    {
        if(!this.el){
            this.defaultAutoCreate = {
                tag: "textarea",
                style:"width:300px;height:60px;",
                autocomplete: "off"
            };
        }

        Roo.form.FCKeditor.superclass.onRender.call(this, ct, B);
        /*
        if(this.grow){
            this.textSizeEl = Roo.DomHelper.append(document.body, {tag: "pre", cls: "x-form-grow-sizer"});
            if(this.preventScrollbars){
                this.el.setStyle("overflow", "hidden");
            }
            this.el.setHeight(this.growMin);
        }
        */
        //console.log('onrender' + this.getId() );
        Roo.form.FCKeditor.editors[this.getId()] = this;
         

        this.replaceTextarea() ;
        
    },
    
    getEditor : function() {
        return  this.fckEditor;
    },
    /**
     * Sets a data value into the field and validates it.  To set the value directly without validation see {@link #setRawValue}.
     * @param {Mixed} value The value to set
     */
    
    
    setValue : function(C)
    {
        //console.log('setValue: ' + value);
        
        if(typeof(C) == 'undefined') { // not sure why this is happending...
            return;
        }

        Roo.form.FCKeditor.superclass.setValue.apply(this,[C]);
        
        //if(!this.el || !this.getEditor()) {
        //    this.value = value;
            //this.setValue.defer(100,this,[value]);    
        //    return;
        //} 
        
        if(!this.getEditor()) {
            return;
        }

        
        this.getEditor().SetData(C);
        
        //

    },

    /**
     * Returns the normalized data value (undefined or emptyText will be returned as '').  To return the raw value see {@link #getRawValue}.
     * @return {Mixed} value The field value
     */
    getValue : function()
    {
        
        if (this.frame && this.frame.dom.style.display == 'none') {
            return  Roo.form.FCKeditor.superclass.getValue.call(this);
        }
        
        if(!this.el || !this.getEditor()) {
           
           // this.getValue.defer(100,this); 
            return  this.value;
        }
       
        
        var  D=this.getEditor().GetData();
        Roo.form.FCKeditor.superclass.setValue.apply(this,[D]);
        return  Roo.form.FCKeditor.superclass.getValue.call(this);
        

    },

    /**
     * Returns the raw data value which may or may not be a valid, defined value.  To return a normalized value see {@link #getValue}.
     * @return {Mixed} value The field value
     */
    getRawValue : function()
    {
        if (this.frame && this.frame.dom.style.display == 'none') {
            return  Roo.form.FCKeditor.superclass.getRawValue.call(this);
        }
        
        if(!this.el || !this.getEditor()) {
            //this.getRawValue.defer(100,this); 
            return  this.value;
            return;
        }
        
        
        
        var  E=this.getEditor().GetData();
        Roo.form.FCKeditor.superclass.setRawValue.apply(this,[E]);
        return  Roo.form.FCKeditor.superclass.getRawValue.call(this);
         
    },
    
    setSize : function(w,h) {
        
        
        
        //if (this.frame && this.frame.dom.style.display == 'none') {
        //    Roo.form.FCKeditor.superclass.setSize.apply(this, [w, h]);
        //    return;
        //}
        //if(!this.el || !this.getEditor()) {
        //    this.setSize.defer(100,this, [w,h]); 
        //    return;
        //}
        
        
        
        Roo.form.FCKeditor.superclass.setSize.apply(this, [w, h]);
        
        this.frame.dom.setAttribute('width', w);
        this.frame.dom.setAttribute('height', h);
        this.frame.setSize(w,h);
        
    },
    
    toggleSourceEdit : function(F) {
        
      
         
        this.el.dom.style.display = F ? '' : 'none';
        this.frame.dom.style.display = F ?  'none' : '';
        
    },
    
    
    focus: function(G)
    {
        if (this.frame.dom.style.display == 'none') {
            return  Roo.form.FCKeditor.superclass.focus.call(this);
        }
        if(!this.el || !this.getEditor()) {
            this.focus.defer(100,this, [G]); 
            return;
        }
        
        
        
        
        var  H = this.getEditor().EditorDocument.getElementsByTagName(G);
        this.getEditor().Focus();
        if (H.length) {
            if (!this.getEditor().Selection.GetSelection()) {
                this.focus.defer(100,this, [G]); 
                return;
            }
            
            
            var  r = this.getEditor().EditorDocument.createRange();
            r.setStart(H[0],0);
            r.setEnd(H[0],0);
            this.getEditor().Selection.GetSelection().removeAllRanges();
            this.getEditor().Selection.GetSelection().addRange(r);
            this.getEditor().Focus();
        }
        
    },
    
    
    
    replaceTextarea : function()
    {
        if ( document.getElementById( this.getId() + '___Frame' ) )
            return ;
        //if ( !this.checkBrowser || this._isCompatibleBrowser() )
        //{
            // We must check the elements firstly using the Id and then the name.
        var  I = document.getElementById( this.getId() );
        
        var  J = document.getElementsByName( this.getId() ) ;
         
        I.style.display = 'none' ;

        if ( I.tabIndex ) {            
            this.TabIndex = I.tabIndex ;
        }

        
        this._insertHtmlBefore( this._getConfigHtml(), I ) ;
        this._insertHtmlBefore( this._getIFrameHtml(), I ) ;
        this.frame = Roo.get(this.getId() + '___Frame')
    },
    
    _getConfigHtml : function()
    {
        var  K = '' ;

        for ( var  o  in  this.fckconfig ) {
            K += K.length > 0  ? '&amp;' : '';
            K += encodeURIComponent( o ) + '=' + encodeURIComponent( this.fckconfig[o] ) ;
        }

        return  '<input type="hidden" id="' + this.getId() + '___Config" value="' + K + '" style="display:none" />' ;
    },
    
    
    _getIFrameHtml : function()
    {
        var  L = 'fckeditor.html' ;
        /* no idea what this is about..
        try
        {
            if ( (/fcksource=true/i).test( window.top.location.search ) )
                sFile = 'fckeditor.original.html' ;
        }
        catch (e) { 
        */

        var  M = this.basePath + 'editor/' + L + '?InstanceName=' + encodeURIComponent( this.getId() ) ;
        M += this.toolbarSet ? ( '&amp;Toolbar=' + this.toolbarSet)  : '';
        
        
        var  N = '<iframe id="' + this.getId() +
            '___Frame" src="' + M +
            '" width="' + this.width +
            '" height="' + this.height + '"' +
            (this.tabIndex ?  ' tabindex="' + this.tabIndex + '"' :'' ) +
            ' frameborder="0" scrolling="no"></iframe>' ;

        return  N ;
    },
    
    _insertHtmlBefore : function( O, P )
    {
        if ( P.insertAdjacentHTML )	{
            // IE
            P.insertAdjacentHTML( 'beforeBegin', O ) ;
        } else  { // Gecko
            var  oRange = document.createRange() ;
            oRange.setStartBefore( P ) ;
            var  oFragment = oRange.createContextualFragment( O );
            P.parentNode.insertBefore( oFragment, P ) ;
        }
    }
    
    
  
    
    
    
    

});

//Roo.reg('fckeditor', Roo.form.FCKeditor);

function  Q(R){
    var  f = Roo.form.FCKeditor.editors[R.Name];
    f.fckEditor = R;
    //console.log("loaded");
    f.fireEvent('editorinit', f, R);
} 
  

 
















//<script type="text/javascript">
/**
 * @class Roo.form.GridField
 * @extends Roo.form.Field
 * Embed a grid (or editable grid into a form)
 * STATUS ALPHA
 * @constructor
 * Creates a new GridField
 * @param {Object} config Configuration options
 */
Roo.form.GridField = function(A){
    Roo.form.GridField.superclass.constructor.call(this, A);
     
};

Roo.extend(Roo.form.GridField, Roo.form.Field,  {
    /**
     * @cfg {Number} width  - used to restrict width of grid..
     */
    width : 100,
    /**
     * @cfg {Number} height - used to restrict height of grid..
     */
    height : 50,
     /**
     * @cfg {Object} xgrid (xtype'd description of grid) Grid or EditorGrid
     */
    xgrid : false, 
    /**
     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to
     * {tag: "input", type: "checkbox", autocomplete: "off"})
     */
   // defaultAutoCreate : { tag: 'div' },
    defaultAutoCreate : { tag: 'input', type: 'hidden', autocomplete: 'off'},
    /**
     * @cfg {String} addTitle Text to include for adding a title.
     */
    addTitle : false,
    //
    onResize : function(){
        Roo.form.Field.superclass.onResize.apply(this, arguments);
    },

    initEvents : function(){
        // Roo.form.Checkbox.superclass.initEvents.call(this);
        // has no events...
       
    },


    getResizeEl : function(){
        return  this.wrap;
    },

    getPositionEl : function(){
        return  this.wrap;
    },

    // private
    onRender : function(ct, B){
        
        this.style = this.style || 'overflow: hidden; border:1px solid #c3daf9;';
        var  C = this.style;
        delete  this.style;
        
        Roo.form.DisplayImage.superclass.onRender.call(this, ct, B);
        this.wrap = this.el.wrap({cls: ''}); // not sure why ive done thsi...
        this.viewEl = this.wrap.createChild({ tag: 'div' });
        if (C) {
            this.viewEl.applyStyles(C);
        }
        if (this.width) {
            this.viewEl.setWidth(this.width);
        }
        if (this.height) {
            this.viewEl.setHeight(this.height);
        }

        //if(this.inputValue !== undefined){
        //this.setValue(this.value);
        
        
        this.grid = new  Roo.grid[this.xgrid.xtype](this.viewEl, this.xgrid);
        
        
        this.grid.render();
        this.grid.getDataSource().on('remove', this.refreshValue, this);
        this.grid.getDataSource().on('update', this.refreshValue, this);
        this.grid.on('afteredit', this.refreshValue, this);
 
    },
     
    
    /**
     * Sets the value of the item. 
     * @param {String} either an object  or a string..
     */
    setValue : function(v){
        //this.value = v;
        v = v || []; // empty set..
        // this does not seem smart - it really only affects memoryproxy grids..
        if (this.grid && this.grid.getDataSource() && typeof(v) != 'undefined') {
            var  ds = this.grid.getDataSource();
            // assumes a json reader..
            var  data = {}

            data[ds.reader.meta.root ] =  typeof(v) == 'string' ? Roo.decode(v) : v;
            ds.loadData( data);
        }

        Roo.form.GridField.superclass.setValue.call(this, v);
        this.refreshValue();
        // should load data in the grid really....
    },
    
    // private
    refreshValue: function() {
         var  D = [];
        this.grid.getDataSource().each(function(r) {
            D.push(r.data);
        });
        this.el.dom.value = Roo.encode(D);
    }
    
     
    
    
});
//<script type="text/javasscript">
 

/**
 * @class Roo.DDView
 * A DnD enabled version of Roo.View.
 * @param {Element/String} container The Element in which to create the View.
 * @param {String} tpl The template string used to create the markup for each element of the View
 * @param {Object} config The configuration properties. These include all the config options of
 * {@link Roo.View} plus some specific to this class.<br>
 * <p>
 * Drag/drop is implemented by adding {@link Roo.data.Record}s to the target DDView. If copying is
 * not being performed, the original {@link Roo.data.Record} is removed from the source DDView.<br>
 * <p>
 * The following extra CSS rules are needed to provide insertion point highlighting:<pre><code>
.x-view-drag-insert-above {
	border-top:1px dotted #3366cc;
}
.x-view-drag-insert-below {
	border-bottom:1px dotted #3366cc;
}
</code></pre>
 * 
 */
 
Roo.DDView = function(A, B, C) {
    Roo.DDView.superclass.constructor.apply(this, arguments);
    this.getEl().setStyle("outline", "0px none");
    this.getEl().unselectable();
    if (this.dragGroup) {
		this.setDraggable(this.dragGroup.split(","));
    }
    if (this.dropGroup) {
		this.setDroppable(this.dropGroup.split(","));
    }
    if (this.deletable) {
    	this.setDeletable();
    }

    this.isDirtyFlag = false;
	this.addEvents({
		"drop" : true
	});
};

Roo.extend(Roo.DDView, Roo.View, {
/**	@cfg {String/Array} dragGroup The ddgroup name(s) for the View's DragZone. */
/**	@cfg {String/Array} dropGroup The ddgroup name(s) for the View's DropZone. */
/**	@cfg {Boolean} copy Causes drag operations to copy nodes rather than move. */
/**	@cfg {Boolean} allowCopy Causes ctrl/drag operations to copy nodes rather than move. */

	isFormField: true,

	reset: Roo.emptyFn,
	
	clearInvalid: Roo.form.Field.prototype.clearInvalid,

	validate: function() {
		return  true;
	},
	
	destroy: function() {
		this.purgeListeners();
		this.getEl.removeAllListeners();
		this.getEl().remove();
		if (this.dragZone) {
			if (this.dragZone.destroy) {
				this.dragZone.destroy();
			}
		}
		if (this.dropZone) {
			if (this.dropZone.destroy) {
				this.dropZone.destroy();
			}
		}
	},

/**	Allows this class to be an Roo.form.Field so it can be found using {@link Roo.form.BasicForm#findField}. */
	getName: function() {
		return  this.name;
	},

/**	Loads the View from a JSON string representing the Records to put into the Store. */
	setValue: function(v) {
		if (!this.store) {
			throw  "DDView.setValue(). DDView must be constructed with a valid Store";
		}
		var  D = {};
		D[this.store.reader.meta.root] = v ? [].concat(v) : [];
		this.store.proxy = new  Roo.data.MemoryProxy(D);
		this.store.load();
	},

/**	@return {String} a parenthesised list of the ids of the Records in the View. */
	getValue: function() {
		var  E = '(';
		this.store.each(function(F) {
			E += F.id + ',';
		});
		return  E.substr(0, E.length - 1) + ')';
	},
	
	getIds: function() {
		var  i = 0, F = new  Array(this.store.getCount());
		this.store.each(function(G) {
			F[i++] = G.id;
		});
		return  F;
	},
	
	isDirty: function() {
		return  this.isDirtyFlag;
	},

/**
 *	Part of the Roo.dd.DropZone interface. If no target node is found, the
 *	whole Element becomes the target, and this causes the drop gesture to append.
 */
    getTargetFromEvent : function(e) {
		var  G = e.getTarget();
		while ((G !== null) && (G.parentNode != this.el.dom)) {
    		G = G.parentNode;
		}
		if (!G) {
			G = this.el.dom.lastChild || this.el.dom;
		}
		return  G;
    },

/**
 *	Create the drag data which consists of an object which has the property "ddel" as
 *	the drag proxy element. 
 */
    getDragData : function(e) {
        var  H = this.findItemFromChild(e.getTarget());
		if(H) {
			this.handleSelection(e);
			var  selNodes = this.getSelectedNodes();
            var  dragData = {
                source: this,
                copy: this.copy || (this.allowCopy && e.ctrlKey),
                nodes: selNodes,
                records: []
			};
			var  selectedIndices = this.getSelectedIndexes();
			for (var  i = 0; i < selectedIndices.length; i++) {
				dragData.records.push(this.store.getAt(selectedIndices[i]));
			}
			if (selNodes.length == 1) {
				dragData.ddel = H.cloneNode(true);	// the div element
			} else  {
				var  div = document.createElement('div'); // create the multi element drag "ghost"
				div.className = 'multi-proxy';
				for (var  i = 0, len = selNodes.length; i < len; i++) {
					div.appendChild(selNodes[i].cloneNode(true));
				}

				dragData.ddel = div;
			}
            //console.log(dragData)
            //console.log(dragData.ddel.innerHTML)
			return  dragData;
		}
        //console.log('nodragData')
		return  false;
    },
    
/**	Specify to which ddGroup items in this DDView may be dragged. */
    setDraggable: function(I) {
    	if (I  instanceof  Array) {
    		Roo.each(I, this.setDraggable, this);
    		return;
    	}
    	if (this.dragZone) {
    		this.dragZone.addToGroup(I);
    	} else  {
			this.dragZone = new  Roo.dd.DragZone(this.getEl(), {
				containerScroll: true,
				ddGroup: I 

			});
//			Draggability implies selection. DragZone's mousedown selects the element.
			if (!this.multiSelect) { this.singleSelect = true; }


//			Wire the DragZone's handlers up to methods in *this*
			this.dragZone.getDragData = this.getDragData.createDelegate(this);
		}
    },

/**	Specify from which ddGroup this DDView accepts drops. */
    setDroppable: function(J) {
    	if (J  instanceof  Array) {
    		Roo.each(J, this.setDroppable, this);
    		return;
    	}
    	if (this.dropZone) {
    		this.dropZone.addToGroup(J);
    	} else  {
			this.dropZone = new  Roo.dd.DropZone(this.getEl(), {
				containerScroll: true,
				ddGroup: J
			});

//			Wire the DropZone's handlers up to methods in *this*
			this.dropZone.getTargetFromEvent = this.getTargetFromEvent.createDelegate(this);
			this.dropZone.onNodeEnter = this.onNodeEnter.createDelegate(this);
			this.dropZone.onNodeOver = this.onNodeOver.createDelegate(this);
			this.dropZone.onNodeOut = this.onNodeOut.createDelegate(this);
			this.dropZone.onNodeDrop = this.onNodeDrop.createDelegate(this);
		}
    },

/**	Decide whether to drop above or below a View node. */
    getDropPoint : function(e, n, dd){
    	if (n == this.el.dom) { return  "above"; }
		var  t = Roo.lib.Dom.getY(n), b = t + n.offsetHeight;
		var  c = t + (b - t) / 2;
		var  y = Roo.lib.Event.getPageY(e);
		if(y <= c) {
			return  "above";
		}else {
			return  "below";
		}
    },

    onNodeEnter : function(n, dd, e, K){
		return  false;
    },
    
    onNodeOver : function(n, dd, e, L){
		var  pt = this.getDropPoint(e, n, dd);
		// set the insert point style on the target node
		var  M = this.dropNotAllowed;
		if (pt) {
			var  targetElClass;
			if (pt == "above"){
				M = n.previousSibling ? "x-tree-drop-ok-between" : "x-tree-drop-ok-above";
				targetElClass = "x-view-drag-insert-above";
			} else  {
				M = n.nextSibling ? "x-tree-drop-ok-between" : "x-tree-drop-ok-below";
				targetElClass = "x-view-drag-insert-below";
			}
			if (this.lastInsertClass != targetElClass){
				Roo.fly(n).replaceClass(this.lastInsertClass, targetElClass);
				this.lastInsertClass = targetElClass;
			}
		}
		return  M;
	},

    onNodeOut : function(n, dd, e, N){
		this.removeDropIndicators(n);
    },

    onNodeDrop : function(n, dd, e, O){
    	if (this.fireEvent("drop", this, n, dd, e, O) === false) {
    		return  false;
    	}
    	var  pt = this.getDropPoint(e, n, dd);
		var  P = (n == this.el.dom) ? this.nodes.length : n.nodeIndex;
		if (pt == "below") { P++; }
		for (var  i = 0; i < O.records.length; i++) {
			var  r = O.records[i];
			var  dup = this.store.getById(r.id);
			if (dup && (dd != this.dragZone)) {
				Roo.fly(this.getNode(this.store.indexOf(dup))).frame("red", 1);
			} else  {
				if (O.copy) {
					this.store.insert(P++, r.copy());
				} else  {
					O.source.isDirtyFlag = true;
					r.store.remove(r);
					this.store.insert(P++, r);
				}

				this.isDirtyFlag = true;
			}
		}

		this.dragZone.cachedTarget = null;
		return  true;
    },

    removeDropIndicators : function(n){
		if(n){
			Roo.fly(n).removeClass([
				"x-view-drag-insert-above",
				"x-view-drag-insert-below"]);
			this.lastInsertClass = "_noclass";
		}
    },

/**
 *	Utility method. Add a delete option to the DDView's context menu.
 *	@param {String} imageUrl The URL of the "delete" icon image.
 */
	setDeletable: function(Q) {
		if (!this.singleSelect && !this.multiSelect) {
			this.singleSelect = true;
		}
		var  c = this.getContextMenu();
		this.contextMenu.on("itemclick", function(R) {
			switch (R.id) {
				case  "delete":
					this.remove(this.getSelectedIndexes());
					break;
			}
		}, this);
		this.contextMenu.add({
			icon: Q,
			id: "delete",
			text: 'Delete'
		});
	},
	
/**	Return the context menu for this DDView. */
	getContextMenu: function() {
		if (!this.contextMenu) {
//			Create the View's context menu
			this.contextMenu = new  Roo.menu.Menu({
				id: this.id + "-contextmenu"
			});
			this.el.on("contextmenu", this.showContextMenu, this);
		}
		return  this.contextMenu;
	},
	
	disableContextMenu: function() {
		if (this.contextMenu) {
			this.el.un("contextmenu", this.showContextMenu, this);
		}
	},

	showContextMenu: function(e, R) {
        R = this.findItemFromChild(e.getTarget());
		if (R) {
			e.stopEvent();
			this.select(this.getNode(R), this.multiSelect && e.ctrlKey, true);
			this.contextMenu.showAt(e.getXY());
	    }
    },

/**
 *	Remove {@link Roo.data.Record}s at the specified indices.
 *	@param {Array/Number} selectedIndices The index (or Array of indices) of Records to remove.
 */
    remove: function(S) {
		S = [].concat(S);
		for (var  i = 0; i < S.length; i++) {
			var  rec = this.store.getAt(S[i]);
			this.store.remove(rec);
		}
    },

/**
 *	Double click fires the event, but also, if this is draggable, and there is only one other
 *	related DropZone, it transfers the selected node.
 */
    onDblClick : function(e){
        var  T = this.findItemFromChild(e.getTarget());
        if(T){
            if (this.fireEvent("dblclick", this, this.indexOf(T), T, e) === false) {
            	return  false;
            }
            if (this.dragGroup) {
	            var  targets = Roo.dd.DragDropMgr.getRelated(this.dragZone, true);
	            while (targets.indexOf(this.dropZone) > -1) {
		            targets.remove(this.dropZone);
				}
	            if (targets.length == 1) {
					this.dragZone.cachedTarget = null;
	            	var  el = Roo.get(targets[0].getEl());
	            	var  box = el.getBox(true);
	            	targets[0].onNodeDrop(el.dom, {
	            		target: el.dom,
	            		xy: [box.x, box.y + box.height - 1]
	            	}, null, this.getDragData(e));
	            }
	        }
        }
    },
    
    handleSelection: function(e) {
		this.dragZone.cachedTarget = null;
        var  U = this.findItemFromChild(e.getTarget());
        if (!U) {
        	this.clearSelections(true);
        	return;
        }
		if (U && (this.multiSelect || this.singleSelect)){
			if(this.multiSelect && e.shiftKey && (!e.ctrlKey) && this.lastSelection){
				this.select(this.getNodes(this.indexOf(this.lastSelection), U.nodeIndex), false);
			}else  if (this.isSelected(this.getNode(U)) && e.ctrlKey){
				this.unselect(U);
			} else  {
				this.select(U, this.multiSelect && e.ctrlKey);
				this.lastSelection = U;
			}
		}
    },

    onItemClick : function(V, W, e){
		if(this.fireEvent("beforeclick", this, W, V, e) === false){
			return  false;
		}
		return  true;
    },

    unselect : function(X, Y){
		var  Z = this.getNode(X);
		if(Z && this.isSelected(Z)){
			if(this.fireEvent("beforeselect", this, Z, this.selections) !== false){
				Roo.fly(Z).removeClass(this.selectedClass);
				this.selections.remove(Z);
				if(!Y){
					this.fireEvent("selectionchange", this, this.selections);
				}
			}
		}
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.LayoutManager
 * @extends Roo.util.Observable
 * Base class for layout managers.
 */
Roo.LayoutManager = function(A, B){
    Roo.LayoutManager.superclass.constructor.call(this);
    this.el = Roo.get(A);
    // ie scrollbar fix
    if(this.el.dom == document.body && Roo.isIE && !B.allowScroll){
        document.body.scroll = "no";
    }else  if(this.el.dom != document.body && this.el.getStyle('position') == 'static'){
        this.el.position('relative');
    }

    this.id = this.el.id;
    this.el.addClass("x-layout-container");
    /** false to disable window resize monitoring @type Boolean */
    this.monitorWindowResize = true;
    this.regions = {};
    this.addEvents({
        /**
         * @event layout
         * Fires when a layout is performed. 
         * @param {Roo.LayoutManager} this
         */
        "layout" : true,
        /**
         * @event regionresized
         * Fires when the user resizes a region. 
         * @param {Roo.LayoutRegion} region The resized region
         * @param {Number} newSize The new size (width for east/west, height for north/south)
         */
        "regionresized" : true,
        /**
         * @event regioncollapsed
         * Fires when a region is collapsed. 
         * @param {Roo.LayoutRegion} region The collapsed region
         */
        "regioncollapsed" : true,
        /**
         * @event regionexpanded
         * Fires when a region is expanded.  
         * @param {Roo.LayoutRegion} region The expanded region
         */
        "regionexpanded" : true
    });
    this.updating = false;
    Roo.EventManager.onWindowResize(this.onWindowResize, this, true);
};

Roo.extend(Roo.LayoutManager, Roo.util.Observable, {
    /**
     * Returns true if this layout is currently being updated
     * @return {Boolean}
     */
    isUpdating : function(){
        return  this.updating; 
    },
    
    /**
     * Suspend the LayoutManager from doing auto-layouts while
     * making multiple add or remove calls
     */
    beginUpdate : function(){
        this.updating = true;    
    },
    
    /**
     * Restore auto-layouts and optionally disable the manager from performing a layout
     * @param {Boolean} noLayout true to disable a layout update 
     */
    endUpdate : function(C){
        this.updating = false;
        if(!C){
            this.layout();
        }    
    },
    
    layout: function(){
        
    },
    
    onRegionResized : function(D, E){
        this.fireEvent("regionresized", D, E);
        this.layout();
    },
    
    onRegionCollapsed : function(F){
        this.fireEvent("regioncollapsed", F);
    },
    
    onRegionExpanded : function(G){
        this.fireEvent("regionexpanded", G);
    },
        
    /**
     * Returns the size of the current view. This method normalizes document.body and element embedded layouts and
     * performs box-model adjustments.
     * @return {Object} The size as an object {width: (the width), height: (the height)}
     */
    getViewSize : function(){
        var  H;
        if(this.el.dom != document.body){
            H = this.el.getSize();
        }else {
            H = {width: Roo.lib.Dom.getViewWidth(), height: Roo.lib.Dom.getViewHeight()};
        }

        H.width -= this.el.getBorderWidth("lr")-this.el.getPadding("lr");
        H.height -= this.el.getBorderWidth("tb")-this.el.getPadding("tb");
        return  H;
    },
    
    /**
     * Returns the Element this layout is bound to.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.el;
    },
    
    /**
     * Returns the specified region.
     * @param {String} target The region key ('center', 'north', 'south', 'east' or 'west')
     * @return {Roo.LayoutRegion}
     */
    getRegion : function(I){
        return  this.regions[I.toLowerCase()];
    },
    
    onWindowResize : function(){
        if(this.monitorWindowResize){
            this.layout();
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.BorderLayout
 * @extends Roo.LayoutManager
 * This class represents a common layout manager used in desktop applications. For screenshots and more details,
 * please see: <br><br>
 * <a href="http://www.jackslocum.com/yui/2006/10/19/cross-browser-web-20-layouts-with-yahoo-ui/">Cross Browser Layouts - Part 1</a><br>
 * <a href="http://www.jackslocum.com/yui/2006/10/28/cross-browser-web-20-layouts-part-2-ajax-feed-viewer-20/">Cross Browser Layouts - Part 2</a><br><br>
 * Example:
 <pre><code>
 var layout = new Roo.BorderLayout(document.body, {
    north: {
        initialSize: 25,
        titlebar: false
    },
    west: {
        split:true,
        initialSize: 200,
        minSize: 175,
        maxSize: 400,
        titlebar: true,
        collapsible: true
    },
    east: {
        split:true,
        initialSize: 202,
        minSize: 175,
        maxSize: 400,
        titlebar: true,
        collapsible: true
    },
    south: {
        split:true,
        initialSize: 100,
        minSize: 100,
        maxSize: 200,
        titlebar: true,
        collapsible: true
    },
    center: {
        titlebar: true,
        autoScroll:true,
        resizeTabs: true,
        minTabWidth: 50,
        preferredTabWidth: 150
    }
});

// shorthand
var CP = Roo.ContentPanel;

layout.beginUpdate();
layout.add("north", new CP("north", "North"));
layout.add("south", new CP("south", {title: "South", closable: true}));
layout.add("west", new CP("west", {title: "West"}));
layout.add("east", new CP("autoTabs", {title: "Auto Tabs", closable: true}));
layout.add("center", new CP("center1", {title: "Close Me", closable: true}));
layout.add("center", new CP("center2", {title: "Center Panel", closable: false}));
layout.getRegion("center").showPanel("center1");
layout.endUpdate();
</code></pre>

<b>The container the layout is rendered into can be either the body element or any other element.
If it is not the body element, the container needs to either be an absolute positioned element,
or you will need to add "position:relative" to the css of the container.  You will also need to specify
the container size if it is not the body element.</b>

* @constructor
* Create a new BorderLayout
* @param {String/HTMLElement/Element} container The container this layout is bound to
* @param {Object} config Configuration options
 */
Roo.BorderLayout = function(A, B){
    B = B || {};
    Roo.BorderLayout.superclass.constructor.call(this, A, B);
    this.factory = B.factory || Roo.BorderLayout.RegionFactory;
    for(var  i = 0, len = this.factory.validRegions.length; i < len; i++) {
    	var  target = this.factory.validRegions[i];
    	if(B[target]){
    	    this.addRegion(target, B[target]);
    	}
    }
};

Roo.extend(Roo.BorderLayout, Roo.LayoutManager, {
    /**
     * Creates and adds a new region if it doesn't already exist.
     * @param {String} target The target region key (north, south, east, west or center).
     * @param {Object} config The regions config object
     * @return {BorderLayoutRegion} The new region
     */
    addRegion : function(C, D){
        if(!this.regions[C]){
            var  r = this.factory.create(C, this, D);
    	    this.bindRegion(C, r);
        }
        return  this.regions[C];
    },

    // private (kinda)
    bindRegion : function(E, r){
        this.regions[E] = r;
        r.on("visibilitychange", this.layout, this);
        r.on("paneladded", this.layout, this);
        r.on("panelremoved", this.layout, this);
        r.on("invalidated", this.layout, this);
        r.on("resized", this.onRegionResized, this);
        r.on("collapsed", this.onRegionCollapsed, this);
        r.on("expanded", this.onRegionExpanded, this);
    },

    /**
     * Performs a layout update.
     */
    layout : function(){
        if(this.updating) return;
        var  F = this.getViewSize();
        var  w = F.width;
        var  h = F.height;
        var  G = w;
        var  H = h;
        var  I = 0;
        var  J = 0;
        //var x = 0, y = 0;

        var  rs = this.regions;
        var  K = rs["north"];
        var  L = rs["south"]; 
        var  M = rs["west"];
        var  N = rs["east"];
        var  O = rs["center"];
        //if(this.hideOnLayout){ // not supported anymore
            //c.el.setStyle("display", "none");
        //}
        if(K && K.isVisible()){
            var  b = K.getBox();
            var  m = K.getMargins();
            b.width = w - (m.left+m.right);
            b.x = m.left;
            b.y = m.top;
            I = b.height + b.y + m.bottom;
            H -= I;
            K.updateBox(this.safeBox(b));
        }
        if(L && L.isVisible()){
            var  b = L.getBox();
            var  m = L.getMargins();
            b.width = w - (m.left+m.right);
            b.x = m.left;
            var  totalHeight = (b.height + m.top + m.bottom);
            b.y = h - totalHeight + m.top;
            H -= totalHeight;
            L.updateBox(this.safeBox(b));
        }
        if(M && M.isVisible()){
            var  b = M.getBox();
            var  m = M.getMargins();
            b.height = H - (m.top+m.bottom);
            b.x = m.left;
            b.y = I + m.top;
            var  totalWidth = (b.width + m.left + m.right);
            J += totalWidth;
            G -= totalWidth;
            M.updateBox(this.safeBox(b));
        }
        if(N && N.isVisible()){
            var  b = N.getBox();
            var  m = N.getMargins();
            b.height = H - (m.top+m.bottom);
            var  totalWidth = (b.width + m.left + m.right);
            b.x = w - totalWidth + m.left;
            b.y = I + m.top;
            G -= totalWidth;
            N.updateBox(this.safeBox(b));
        }
        if(O){
            var  m = O.getMargins();
            var  centerBox = {
                x: J + m.left,
                y: I + m.top,
                width: G - (m.left+m.right),
                height: H - (m.top+m.bottom)
            };
            //if(this.hideOnLayout){
                //center.el.setStyle("display", "block");
            //}
            O.updateBox(this.safeBox(centerBox));
        }

        this.el.repaint();
        this.fireEvent("layout", this);
    },

    // private
    safeBox : function(P){
        P.width = Math.max(0, P.width);
        P.height = Math.max(0, P.height);
        return  P;
    },

    /**
     * Adds a ContentPanel (or subclass) to this layout.
     * @param {String} target The target region key (north, south, east, west or center).
     * @param {Roo.ContentPanel} panel The panel to add
     * @return {Roo.ContentPanel} The added panel
     */
    add : function(Q, R){
         
        Q = Q.toLowerCase();
        return  this.regions[Q].add(R);
    },

    /**
     * Remove a ContentPanel (or subclass) to this layout.
     * @param {String} target The target region key (north, south, east, west or center).
     * @param {Number/String/Roo.ContentPanel} panel The index, id or panel to remove
     * @return {Roo.ContentPanel} The removed panel
     */
    remove : function(S, T){
        S = S.toLowerCase();
        return  this.regions[S].remove(T);
    },

    /**
     * Searches all regions for a panel with the specified id
     * @param {String} panelId
     * @return {Roo.ContentPanel} The panel or null if it wasn't found
     */
    findPanel : function(U){
        var  rs = this.regions;
        for(var  S  in  rs){
            if(typeof  rs[S] != "function"){
                var  p = rs[S].getPanel(U);
                if(p){
                    return  p;
                }
            }
        }
        return  null;
    },

    /**
     * Searches all regions for a panel with the specified id and activates (shows) it.
     * @param {String/ContentPanel} panelId The panels id or the panel itself
     * @return {Roo.ContentPanel} The shown panel or null
     */
    showPanel : function(V) {
      var  rs = this.regions;
      for(var  S  in  rs){
         var  r = rs[S];
         if(typeof  r != "function"){
            if(r.hasPanel(V)){
               return  r.showPanel(V);
            }
         }
      }
      return  null;
   },

   /**
     * Restores this layout's state using Roo.state.Manager or the state provided by the passed provider.
     * @param {Roo.state.Provider} provider (optional) An alternate state provider
     */
    restoreState : function(W){
        if(!W){
            W = Roo.state.Manager;
        }
        var  sm = new  Roo.LayoutStateManager();
        sm.init(this, W);
    },

    /**
     * Adds a batch of multiple ContentPanels dynamically by passing a special regions config object.  This config
     * object should contain properties for each region to add ContentPanels to, and each property's value should be
     * a valid ContentPanel config object.  Example:
     * <pre><code>
// Create the main layout
var layout = new Roo.BorderLayout('main-ct', {
    west: {
        split:true,
        minSize: 175,
        titlebar: true
    },
    center: {
        title:'Components'
    }
}, 'main-ct');

// Create and add multiple ContentPanels at once via configs
layout.batchAdd({
   west: {
       id: 'source-files',
       autoCreate:true,
       title:'Ext Source Files',
       autoScroll:true,
       fitToFrame:true
   },
   center : {
       el: cview,
       autoScroll:true,
       fitToFrame:true,
       toolbar: tb,
       resizeEl:'cbody'
   }
});
</code></pre>
     * @param {Object} regions An object containing ContentPanel configs by region name
     */
    batchAdd : function(X){
        this.beginUpdate();
        for(var  rname  in  X){
            var  lr = this.regions[rname];
            if(lr){
                this.addTypedPanels(lr, X[rname]);
            }
        }

        this.endUpdate();
    },

    // private
    addTypedPanels : function(lr, ps){
        if(typeof  ps == 'string'){
            lr.add(new  Roo.ContentPanel(ps));
        }
        else  if(ps  instanceof  Array){
            for(var  i =0, len = ps.length; i < len; i++){
                this.addTypedPanels(lr, ps[i]);
            }
        }
        else  if(!ps.events){ // raw config?
            var  el = ps.el;
            delete  ps.el; // prevent conflict
            lr.add(new  Roo.ContentPanel(el || Roo.id(), ps));
        }
        else  {  // panel object assumed!
            lr.add(ps);
        }
    },
    /**
     * Adds a xtype elements to the layout.
     * <pre><code>

layout.addxtype({
       xtype : 'ContentPanel',
       region: 'west',
       items: [ .... ]
   }
);

layout.addxtype({
        xtype : 'NestedLayoutPanel',
        region: 'west',
        layout: {
           center: { },
           west: { }   
        },
        items : [ ... list of content panels or nested layout panels.. ]
   }
);
</code></pre>
     * @param {Object} cfg Xtype definition of item to add.
     */
    addxtype : function(Y)
    {
        // basically accepts a pannel...
        // can accept a layout region..!?!?
       // console.log('BorderLayout add ' + cfg.xtype)
        
        if (!Y.xtype.match(/Panel$/)) {
            return  false;
        }
        var  Z = false;
        var  a = Y.region;
        delete  Y.region;
        
          
        var  c = [];
        if (Y.items) {
            c = Y.items;
            delete  Y.items;
        }
        
        
        switch(Y.xtype) 
        {
            case  'ContentPanel':  // ContentPanel (el, cfg)
                if(Y.autoCreate) {
                    Z = new  Roo[Y.xtype](Y); // new panel!!!!!
                } else  {
                    var  el = this.el.createChild();
                    Z = new  Roo[Y.xtype](el, Y); // new panel!!!!!
                }

                
                this.add(a, Z);
                break;
            
            
            case  'TreePanel': // our new panel!
                Y.el = this.el.createChild();
                Z = new  Roo[Y.xtype](Y); // new panel!!!!!
                this.add(a, Z);
                break;
            
            case  'NestedLayoutPanel': 
                // create a new Layout (which is  a Border Layout...
                var  el = this.el.createChild();
                var  clayout = Y.layout;
                delete  Y.layout;
                clayout.items   = clayout.items  || [];
                // replace this exitems with the clayout ones..
                c = clayout.items;
                 
                
                if (a == 'center' && this.active && this.getRegion('center').panels.length < 1) {
                    Y.background = false;
                }
                var  layout = new  Roo.BorderLayout(el, clayout);
                
                Z = new  Roo[Y.xtype](layout, Y); // new panel!!!!!
                //console.log('adding nested layout panel '  + cfg.toSource());
                this.add(a, Z);
                
                break;
                
            case  'GridPanel': 
            
                // needs grid and region
                
                //var el = this.getRegion(region).el.createChild();
                var  el = this.el.createChild();
                // create the grid first...
                
                var  grid = new  Roo.grid[Y.grid.xtype](el, Y.grid);
                delete  Y.grid;
                if (a == 'center' && this.active ) {
                    Y.background = false;
                }

                Z = new  Roo[Y.xtype](grid, Y); // new panel!!!!!
                
                this.add(a, Z);
                if (Y.background) {
                    Z.on('activate', function(gp) {
                        if (!gp.grid.rendered) {
                            gp.grid.render();
                        }
                    });
                } else  {
                    grid.render();
                }
                break;
           
               
                
                
            default: 
                alert("Can not add '" + Y.xtype + "' to BorderLayout");
                return;
             // GridPanel (grid, cfg)
            
        }

        this.beginUpdate();
        // add children..
        Roo.each(c, function(i)  {
            Z.addxtype(i);
        });
        this.endUpdate();
        return  Z;
        
    }
});

/**
 * Shortcut for creating a new BorderLayout object and adding one or more ContentPanels to it in a single step, handling
 * the beginUpdate and endUpdate calls internally.  The key to this method is the <b>panels</b> property that can be
 * provided with each region config, which allows you to add ContentPanel configs in addition to the region configs
 * during creation.  The following code is equivalent to the constructor-based example at the beginning of this class:
 * <pre><code>
// shorthand
var CP = Roo.ContentPanel;

var layout = Roo.BorderLayout.create({
    north: {
        initialSize: 25,
        titlebar: false,
        panels: [new CP("north", "North")]
    },
    west: {
        split:true,
        initialSize: 200,
        minSize: 175,
        maxSize: 400,
        titlebar: true,
        collapsible: true,
        panels: [new CP("west", {title: "West"})]
    },
    east: {
        split:true,
        initialSize: 202,
        minSize: 175,
        maxSize: 400,
        titlebar: true,
        collapsible: true,
        panels: [new CP("autoTabs", {title: "Auto Tabs", closable: true})]
    },
    south: {
        split:true,
        initialSize: 100,
        minSize: 100,
        maxSize: 200,
        titlebar: true,
        collapsible: true,
        panels: [new CP("south", {title: "South", closable: true})]
    },
    center: {
        titlebar: true,
        autoScroll:true,
        resizeTabs: true,
        minTabWidth: 50,
        preferredTabWidth: 150,
        panels: [
            new CP("center1", {title: "Close Me", closable: true}),
            new CP("center2", {title: "Center Panel", closable: false})
        ]
    }
}, document.body);

layout.getRegion("center").showPanel("center1");
</code></pre>
 * @param config
 * @param targetEl
 */
Roo.BorderLayout.create = function(d, e){
    var  f = new  Roo.BorderLayout(e || document.body, d);
    f.beginUpdate();
    var  g = Roo.BorderLayout.RegionFactory.validRegions;
    for(var  j = 0, jlen = g.length; j < jlen; j++){
        var  lr = g[j];
        if(f.regions[lr] && d[lr].panels){
            var  r = f.regions[lr];
            var  ps = d[lr].panels;
            f.addTypedPanels(r, ps);
        }
    }

    f.endUpdate();
    return  f;
};

// private
Roo.BorderLayout.RegionFactory = {
    // private
    validRegions : ["north","south","east","west","center"],

    // private
    create : function(k, l, n){
        k = k.toLowerCase();
        if(n.lightweight || n.basic){
            return  new  Roo.BasicLayoutRegion(l, n, k);
        }
        switch(k){
            case  "north":
                return  new  Roo.NorthLayoutRegion(l, n);
            case  "south":
                return  new  Roo.SouthLayoutRegion(l, n);
            case  "east":
                return  new  Roo.EastLayoutRegion(l, n);
            case  "west":
                return  new  Roo.WestLayoutRegion(l, n);
            case  "center":
                return  new  Roo.CenterLayoutRegion(l, n);
        }
        throw  'Layout region "'+k+'" not supported.';
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.BasicLayoutRegion
 * @extends Roo.util.Observable
 * This class represents a lightweight region in a layout manager. This region does not move dom nodes
 * and does not have a titlebar, tabs or any other features. All it does is size and position 
 * panels. To create a BasicLayoutRegion, add lightweight:true or basic:true to your regions config.
 */
Roo.BasicLayoutRegion = function(A, B, C, D){
    this.mgr = A;
    this.position  = C;
    this.events = {
        /**
         * @scope Roo.BasicLayoutRegion
         */
        
        /**
         * @event beforeremove
         * Fires before a panel is removed (or closed). To cancel the removal set "e.cancel = true" on the event argument.
         * @param {Roo.LayoutRegion} this
         * @param {Roo.ContentPanel} panel The panel
         * @param {Object} e The cancel event object
         */
        "beforeremove" : true,
        /**
         * @event invalidated
         * Fires when the layout for this region is changed.
         * @param {Roo.LayoutRegion} this
         */
        "invalidated" : true,
        /**
         * @event visibilitychange
         * Fires when this region is shown or hidden 
         * @param {Roo.LayoutRegion} this
         * @param {Boolean} visibility true or false
         */
        "visibilitychange" : true,
        /**
         * @event paneladded
         * Fires when a panel is added. 
         * @param {Roo.LayoutRegion} this
         * @param {Roo.ContentPanel} panel The panel
         */
        "paneladded" : true,
        /**
         * @event panelremoved
         * Fires when a panel is removed. 
         * @param {Roo.LayoutRegion} this
         * @param {Roo.ContentPanel} panel The panel
         */
        "panelremoved" : true,
        /**
         * @event collapsed
         * Fires when this region is collapsed.
         * @param {Roo.LayoutRegion} this
         */
        "collapsed" : true,
        /**
         * @event expanded
         * Fires when this region is expanded.
         * @param {Roo.LayoutRegion} this
         */
        "expanded" : true,
        /**
         * @event slideshow
         * Fires when this region is slid into view.
         * @param {Roo.LayoutRegion} this
         */
        "slideshow" : true,
        /**
         * @event slidehide
         * Fires when this region slides out of view. 
         * @param {Roo.LayoutRegion} this
         */
        "slidehide" : true,
        /**
         * @event panelactivated
         * Fires when a panel is activated. 
         * @param {Roo.LayoutRegion} this
         * @param {Roo.ContentPanel} panel The activated panel
         */
        "panelactivated" : true,
        /**
         * @event resized
         * Fires when the user resizes this region. 
         * @param {Roo.LayoutRegion} this
         * @param {Number} newSize The new size (width for east/west, height for north/south)
         */
        "resized" : true
    };
    /** A collection of panels in this region. @type Roo.util.MixedCollection */
    this.panels = new  Roo.util.MixedCollection();
    this.panels.getKey = this.getPanelId.createDelegate(this);
    this.box = null;
    this.activePanel = null;
    // ensure listeners are added...
    
    if (B.listeners || B.events) {
        Roo.BasicLayoutRegion.superclass.constructor.call(this, {
            listeners : B.listeners || {},
            events : B.events || {}
        });
    }
    
    if(D !== true){
        this.applyConfig(B);
    }
};

Roo.extend(Roo.BasicLayoutRegion, Roo.util.Observable, {
    getPanelId : function(p){
        return  p.getId();
    },
    
    applyConfig : function(E){
        this.margins = E.margins || this.margins || {top: 0, left: 0, right:0, bottom: 0};
        this.config = E;
        
    },
    
    /**
     * Resizes the region to the specified size. For vertical regions (west, east) this adjusts 
     * the width, for horizontal (north, south) the height.
     * @param {Number} newSize The new width or height
     */
    resizeTo : function(F){
        var  el = this.el ? this.el :
                 (this.activePanel ? this.activePanel.getEl() : null);
        if(el){
            switch(this.position){
                case  "east":
                case  "west":
                    el.setWidth(F);
                    this.fireEvent("resized", this, F);
                break;
                case  "north":
                case  "south":
                    el.setHeight(F);
                    this.fireEvent("resized", this, F);
                break;                
            }
        }
    },
    
    getBox : function(){
        return  this.activePanel ? this.activePanel.getEl().getBox(false, true) : null;
    },
    
    getMargins : function(){
        return  this.margins;
    },
    
    updateBox : function(G){
        this.box = G;
        var  el = this.activePanel.getEl();
        el.dom.style.left = G.x + "px";
        el.dom.style.top = G.y + "px";
        this.activePanel.setSize(G.width, G.height);
    },
    
    /**
     * Returns the container element for this region.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.activePanel;
    },
    
    /**
     * Returns true if this region is currently visible.
     * @return {Boolean}
     */
    isVisible : function(){
        return  this.activePanel ? true : false;
    },
    
    setActivePanel : function(H){
        H = this.getPanel(H);
        if(this.activePanel && this.activePanel != H){
            this.activePanel.setActiveState(false);
            this.activePanel.getEl().setLeftTop(-10000,-10000);
        }

        this.activePanel = H;
        H.setActiveState(true);
        if(this.box){
            H.setSize(this.box.width, this.box.height);
        }

        this.fireEvent("panelactivated", this, H);
        this.fireEvent("invalidated");
    },
    
    /**
     * Show the specified panel.
     * @param {Number/String/ContentPanel} panelId The panels index, id or the panel itself
     * @return {Roo.ContentPanel} The shown panel or null
     */
    showPanel : function(I){
        if(I = this.getPanel(I)){
            this.setActivePanel(I);
        }
        return  I;
    },
    
    /**
     * Get the active panel for this region.
     * @return {Roo.ContentPanel} The active panel or null
     */
    getActivePanel : function(){
        return  this.activePanel;
    },
    
    /**
     * Add the passed ContentPanel(s)
     * @param {ContentPanel...} panel The ContentPanel(s) to add (you can pass more than one)
     * @return {Roo.ContentPanel} The panel added (if only one was added)
     */
    add : function(J){
        if(arguments.length > 1){
            for(var  i = 0, len = arguments.length; i < len; i++) {
            	this.add(arguments[i]);
            }
            return  null;
        }
        if(this.hasPanel(J)){
            this.showPanel(J);
            return  J;
        }
        var  el = J.getEl();
        if(el.dom.parentNode != this.mgr.el.dom){
            this.mgr.el.dom.appendChild(el.dom);
        }
        if(J.setRegion){
            J.setRegion(this);
        }

        this.panels.add(J);
        el.setStyle("position", "absolute");
        if(!J.background){
            this.setActivePanel(J);
            if(this.config.initialSize && this.panels.getCount()==1){
                this.resizeTo(this.config.initialSize);
            }
        }

        this.fireEvent("paneladded", this, J);
        return  J;
    },
    
    /**
     * Returns true if the panel is in this region.
     * @param {Number/String/ContentPanel} panel The panels index, id or the panel itself
     * @return {Boolean}
     */
    hasPanel : function(K){
        if(typeof  K == "object"){ // must be panel obj
            K = K.getId();
        }
        return  this.getPanel(K) ? true : false;
    },
    
    /**
     * Removes the specified panel. If preservePanel is not true (either here or in the config), the panel is destroyed.
     * @param {Number/String/ContentPanel} panel The panels index, id or the panel itself
     * @param {Boolean} preservePanel Overrides the config preservePanel option
     * @return {Roo.ContentPanel} The panel that was removed
     */
    remove : function(L, M){
        L = this.getPanel(L);
        if(!L){
            return  null;
        }
        var  e = {};
        this.fireEvent("beforeremove", this, L, e);
        if(e.cancel === true){
            return  null;
        }
        var  N = L.getId();
        this.panels.removeKey(N);
        return  L;
    },
    
    /**
     * Returns the panel specified or null if it's not in this region.
     * @param {Number/String/ContentPanel} panel The panels index, id or the panel itself
     * @return {Roo.ContentPanel}
     */
    getPanel : function(id){
        if(typeof  id == "object"){ // must be panel obj
            return  id;
        }
        return  this.panels.get(id);
    },
    
    /**
     * Returns this regions position (north/south/east/west/center).
     * @return {String} 
     */
    getPosition: function(){
        return  this.position;    
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.LayoutRegion
 * @extends Roo.BasicLayoutRegion
 * This class represents a region in a layout manager.
 * @cfg {Boolean} collapsible False to disable collapsing (defaults to true)
 * @cfg {Boolean} collapsed True to set the initial display to collapsed (defaults to false)
 * @cfg {Boolean} floatable False to disable floating (defaults to true)
 * @cfg {Object} margins Margins for the element (defaults to {top: 0, left: 0, right:0, bottom: 0})
 * @cfg {Object} cmargins Margins for the element when collapsed (defaults to: north/south {top: 2, left: 0, right:0, bottom: 2} or east/west {top: 0, left: 2, right:2, bottom: 0})
 * @cfg {String} tabPosition "top" or "bottom" (defaults to "bottom")
 * @cfg {String} collapsedTitle Optional string message to display in the collapsed block of a north or south region
 * @cfg {Boolean} alwaysShowTabs True to always display tabs even when there is only 1 panel (defaults to false)
 * @cfg {Boolean} autoScroll True to enable overflow scrolling (defaults to false)
 * @cfg {Boolean} titlebar True to display a title bar (defaults to true)
 * @cfg {String} title The title for the region (overrides panel titles)
 * @cfg {Boolean} animate True to animate expand/collapse (defaults to false)
 * @cfg {Boolean} autoHide False to disable auto hiding when the mouse leaves the "floated" region (defaults to true)
 * @cfg {Boolean} preservePanels True to preserve removed panels so they can be readded later (defaults to false)
 * @cfg {Boolean} closeOnTab True to place the close icon on the tabs instead of the region titlebar (defaults to false)
 * @cfg {Boolean} hideTabs True to hide the tab strip (defaults to false)
 * @cfg {Boolean} resizeTabs True to enable automatic tab resizing. This will resize the tabs so they are all the same size and fit within
 * the space available, similar to FireFox 1.5 tabs (defaults to false)
 * @cfg {Number} minTabWidth The minimum tab width (defaults to 40)
 * @cfg {Number} preferredTabWidth The preferred tab width (defaults to 150)
 * @cfg {Boolean} showPin True to show a pin button
* @cfg {Boolean} hidden True to start the region hidden (defaults to false)
* @cfg {Boolean} hideWhenEmpty True to hide the region when it has no panels
* @cfg {Boolean} disableTabTips True to disable tab tooltips
* @cfg {Number} width  For East/West panels
* @cfg {Number} height For North/South panels
* @cfg {Boolean} split To show the splitter
 */
Roo.LayoutRegion = function(A, B, C){
    Roo.LayoutRegion.superclass.constructor.call(this, A, B, C, true);
    var  dh = Roo.DomHelper;
    /** This region's container element 
    * @type Roo.Element */
    this.el = dh.append(A.el.dom, {tag: "div", cls: "x-layout-panel x-layout-panel-" + this.position}, true);
    /** This region's title element 
    * @type Roo.Element */

    this.titleEl = dh.append(this.el.dom, {tag: "div", unselectable: "on", cls: "x-unselectable x-layout-panel-hd x-layout-title-"+this.position, children:[
        {tag: "span", cls: "x-unselectable x-layout-panel-hd-text", unselectable: "on", html: "&#160;"},
        {tag: "div", cls: "x-unselectable x-layout-panel-hd-tools", unselectable: "on"}
    ]}, true);
    this.titleEl.enableDisplayMode();
    /** This region's title text element 
    * @type HTMLElement */
    this.titleTextEl = this.titleEl.dom.firstChild;
    this.tools = Roo.get(this.titleEl.dom.childNodes[1], true);
    this.closeBtn = this.createTool(this.tools.dom, "x-layout-close");
    this.closeBtn.enableDisplayMode();
    this.closeBtn.on("click", this.closeClicked, this);
    this.closeBtn.hide();

    this.createBody(B);
    this.visible = true;
    this.collapsed = false;

    if(B.hideWhenEmpty){
        this.hide();
        this.on("paneladded", this.validateVisibility, this);
        this.on("panelremoved", this.validateVisibility, this);
    }

    this.applyConfig(B);
};

Roo.extend(Roo.LayoutRegion, Roo.BasicLayoutRegion, {

    createBody : function(){
        /** This region's body element 
        * @type Roo.Element */
        this.bodyEl = this.el.createChild({tag: "div", cls: "x-layout-panel-body"});
    },

    applyConfig : function(c){
        if(c.collapsible && this.position != "center" && !this.collapsedEl){
            var  dh = Roo.DomHelper;
            if(c.titlebar !== false){
                this.collapseBtn = this.createTool(this.tools.dom, "x-layout-collapse-"+this.position);
                this.collapseBtn.on("click", this.collapse, this);
                this.collapseBtn.enableDisplayMode();

                if(c.showPin === true || this.showPin){
                    this.stickBtn = this.createTool(this.tools.dom, "x-layout-stick");
                    this.stickBtn.enableDisplayMode();
                    this.stickBtn.on("click", this.expand, this);
                    this.stickBtn.hide();
                }
            }

            /** This region's collapsed element
            * @type Roo.Element */
            this.collapsedEl = dh.append(this.mgr.el.dom, {cls: "x-layout-collapsed x-layout-collapsed-"+this.position, children:[
                {cls: "x-layout-collapsed-tools", children:[{cls: "x-layout-ctools-inner"}]}
            ]}, true);
            if(c.floatable !== false){
               this.collapsedEl.addClassOnOver("x-layout-collapsed-over");
               this.collapsedEl.on("click", this.collapseClick, this);
            }

            if(c.collapsedTitle && (this.position == "north" || this.position== "south")) {
                this.collapsedTitleTextEl = dh.append(this.collapsedEl.dom, {tag: "div", cls: "x-unselectable x-layout-panel-hd-text",
                   id: "message", unselectable: "on", style:{"float":"left"}});
               this.collapsedTitleTextEl.innerHTML = c.collapsedTitle;
             }

            this.expandBtn = this.createTool(this.collapsedEl.dom.firstChild.firstChild, "x-layout-expand-"+this.position);
            this.expandBtn.on("click", this.expand, this);
        }
        if(this.collapseBtn){
            this.collapseBtn.setVisible(c.collapsible == true);
        }

        this.cmargins = c.cmargins || this.cmargins ||
                         (this.position == "west" || this.position == "east" ?
                             {top: 0, left: 2, right:2, bottom: 0} :
                             {top: 2, left: 0, right:0, bottom: 2});
        this.margins = c.margins || this.margins || {top: 0, left: 0, right:0, bottom: 0};
        this.bottomTabs = c.tabPosition != "top";
        this.autoScroll = c.autoScroll || false;
        if(this.autoScroll){
            this.bodyEl.setStyle("overflow", "auto");
        }else {
            this.bodyEl.setStyle("overflow", "hidden");
        }
        //if(c.titlebar !== false){
            if((!c.titlebar && !c.title) || c.titlebar === false){
                this.titleEl.hide();
            }else {
                this.titleEl.show();
                if(c.title){
                    this.titleTextEl.innerHTML = c.title;
                }
            }

        //}
        this.duration = c.duration || .30;
        this.slideDuration = c.slideDuration || .45;
        this.config = c;
        if(c.collapsed){
            this.collapse(true);
        }
        if(c.hidden){
            this.hide();
        }
    },
    /**
     * Returns true if this region is currently visible.
     * @return {Boolean}
     */
    isVisible : function(){
        return  this.visible;
    },

    /**
     * Updates the title for collapsed north/south regions (used with {@link #collapsedTitle} config option)
     * @param {String} title (optional) The title text (accepts HTML markup, defaults to the numeric character reference for a non-breaking space, "&amp;#160;")
     */
    setCollapsedTitle : function(D){
        D = D || "&#160;";
        if(this.collapsedTitleTextEl){
            this.collapsedTitleTextEl.innerHTML = D;
        }
    },

    getBox : function(){
        var  b;
        if(!this.collapsed){
            b = this.el.getBox(false, true);
        }else {
            b = this.collapsedEl.getBox(false, true);
        }
        return  b;
    },

    getMargins : function(){
        return  this.collapsed ? this.cmargins : this.margins;
    },

    highlight : function(){
        this.el.addClass("x-layout-panel-dragover");
    },

    unhighlight : function(){
        this.el.removeClass("x-layout-panel-dragover");
    },

    updateBox : function(E){
        this.box = E;
        if(!this.collapsed){
            this.el.dom.style.left = E.x + "px";
            this.el.dom.style.top = E.y + "px";
            this.updateBody(E.width, E.height);
        }else {
            this.collapsedEl.dom.style.left = E.x + "px";
            this.collapsedEl.dom.style.top = E.y + "px";
            this.collapsedEl.setSize(E.width, E.height);
        }
        if(this.tabs){
            this.tabs.autoSizeTabs();
        }
    },

    updateBody : function(w, h){
        if(w !== null){
            this.el.setWidth(w);
            w -= this.el.getBorderWidth("rl");
            if(this.config.adjustments){
                w += this.config.adjustments[0];
            }
        }
        if(h !== null){
            this.el.setHeight(h);
            h = this.titleEl && this.titleEl.isDisplayed() ? h - (this.titleEl.getHeight()||0) : h;
            h -= this.el.getBorderWidth("tb");
            if(this.config.adjustments){
                h += this.config.adjustments[1];
            }

            this.bodyEl.setHeight(h);
            if(this.tabs){
                h = this.tabs.syncHeight(h);
            }
        }
        if(this.panelSize){
            w = w !== null ? w : this.panelSize.width;
            h = h !== null ? h : this.panelSize.height;
        }
        if(this.activePanel){
            var  el = this.activePanel.getEl();
            w = w !== null ? w : el.getWidth();
            h = h !== null ? h : el.getHeight();
            this.panelSize = {width: w, height: h};
            this.activePanel.setSize(w, h);
        }
        if(Roo.isIE && this.tabs){
            this.tabs.el.repaint();
        }
    },

    /**
     * Returns the container element for this region.
     * @return {Roo.Element}
     */
    getEl : function(){
        return  this.el;
    },

    /**
     * Hides this region.
     */
    hide : function(){
        if(!this.collapsed){
            this.el.dom.style.left = "-2000px";
            this.el.hide();
        }else {
            this.collapsedEl.dom.style.left = "-2000px";
            this.collapsedEl.hide();
        }

        this.visible = false;
        this.fireEvent("visibilitychange", this, false);
    },

    /**
     * Shows this region if it was previously hidden.
     */
    show : function(){
        if(!this.collapsed){
            this.el.show();
        }else {
            this.collapsedEl.show();
        }

        this.visible = true;
        this.fireEvent("visibilitychange", this, true);
    },

    closeClicked : function(){
        if(this.activePanel){
            this.remove(this.activePanel);
        }
    },

    collapseClick : function(e){
        if(this.isSlid){
           e.stopPropagation();
           this.slideIn();
        }else {
           e.stopPropagation();
           this.slideOut();
        }
    },

    /**
     * Collapses this region.
     * @param {Boolean} skipAnim (optional) true to collapse the element without animation (if animate is true)
     */
    collapse : function(F){
        if(this.collapsed) return;
        this.collapsed = true;
        if(this.split){
            this.split.el.hide();
        }
        if(this.config.animate && F !== true){
            this.fireEvent("invalidated", this);
            this.animateCollapse();
        }else {
            this.el.setLocation(-20000,-20000);
            this.el.hide();
            this.collapsedEl.show();
            this.fireEvent("collapsed", this);
            this.fireEvent("invalidated", this);
        }
    },

    animateCollapse : function(){
        // overridden
    },

    /**
     * Expands this region if it was previously collapsed.
     * @param {Roo.EventObject} e The event that triggered the expand (or null if calling manually)
     * @param {Boolean} skipAnim (optional) true to expand the element without animation (if animate is true)
     */
    expand : function(e, G){
        if(e) e.stopPropagation();
        if(!this.collapsed || this.el.hasActiveFx()) return;
        if(this.isSlid){
            this.afterSlideIn();
            G = true;
        }

        this.collapsed = false;
        if(this.config.animate && G !== true){
            this.animateExpand();
        }else {
            this.el.show();
            if(this.split){
                this.split.el.show();
            }

            this.collapsedEl.setLocation(-2000,-2000);
            this.collapsedEl.hide();
            this.fireEvent("invalidated", this);
            this.fireEvent("expanded", this);
        }
    },

    animateExpand : function(){
        // overridden
    },

    initTabs : function(){
        this.bodyEl.setStyle("overflow", "hidden");
        var  ts = new  Roo.TabPanel(this.bodyEl.dom, {
            tabPosition: this.bottomTabs ? 'bottom' : 'top',
            disableTooltips: this.config.disableTabTips
        });
        if(this.config.hideTabs){
            ts.stripWrap.setDisplayed(false);
        }

        this.tabs = ts;
        ts.resizeTabs = this.config.resizeTabs === true;
        ts.minTabWidth = this.config.minTabWidth || 40;
        ts.maxTabWidth = this.config.maxTabWidth || 250;
        ts.preferredTabWidth = this.config.preferredTabWidth || 150;
        ts.monitorResize = false;
        ts.bodyEl.setStyle("overflow", this.config.autoScroll ? "auto" : "hidden");
        ts.bodyEl.addClass('x-layout-tabs-body');
        this.panels.each(this.initPanelAsTab, this);
    },

    initPanelAsTab : function(H){
        var  ti = this.tabs.addTab(H.getEl().id, H.getTitle(), null,
                    this.config.closeOnTab && H.isClosable());
        if(H.tabTip !== undefined){
            ti.setTooltip(H.tabTip);
        }

        ti.on("activate", function(){
              this.setActivePanel(H);
        }, this);
        if(this.config.closeOnTab){
            ti.on("beforeclose", function(t, e){
                e.cancel = true;
                this.remove(H);
            }, this);
        }
        return  ti;
    },

    updatePanelTitle : function(I, J){
        if(this.activePanel == I){
            this.updateTitle(J);
        }
        if(this.tabs){
            var  ti = this.tabs.getTab(I.getEl().id);
            ti.setText(J);
            if(I.tabTip !== undefined){
                ti.setTooltip(I.tabTip);
            }
        }
    },

    updateTitle : function(K){
        if(this.titleTextEl && !this.config.title){
            this.titleTextEl.innerHTML = (typeof  K != "undefined" && K.length > 0 ? K : "&#160;");
        }
    },

    setActivePanel : function(L){
        L = this.getPanel(L);
        if(this.activePanel && this.activePanel != L){
            this.activePanel.setActiveState(false);
        }

        this.activePanel = L;
        L.setActiveState(true);
        if(this.panelSize){
            L.setSize(this.panelSize.width, this.panelSize.height);
        }
        if(this.closeBtn){
            this.closeBtn.setVisible(!this.config.closeOnTab && !this.isSlid && L.isClosable());
        }

        this.updateTitle(L.getTitle());
        if(this.tabs){
            this.fireEvent("invalidated", this);
        }

        this.fireEvent("panelactivated", this, L);
    },

    /**
     * Shows the specified panel.
     * @param {Number/String/ContentPanel} panelId The panel's index, id or the panel itself
     * @return {Roo.ContentPanel} The shown panel, or null if a panel could not be found from panelId
     */
    showPanel : function(M){
        if(M = this.getPanel(M)){
            if(this.tabs){
                var  tab = this.tabs.getTab(M.getEl().id);
                if(tab.isHidden()){
                    this.tabs.unhideTab(tab.id);
                }

                tab.activate();
            }else {
                this.setActivePanel(M);
            }
        }
        return  M;
    },

    /**
     * Get the active panel for this region.
     * @return {Roo.ContentPanel} The active panel or null
     */
    getActivePanel : function(){
        return  this.activePanel;
    },

    validateVisibility : function(){
        if(this.panels.getCount() < 1){
            this.updateTitle("&#160;");
            this.closeBtn.hide();
            this.hide();
        }else {
            if(!this.isVisible()){
                this.show();
            }
        }
    },

    /**
     * Adds the passed ContentPanel(s) to this region.
     * @param {ContentPanel...} panel The ContentPanel(s) to add (you can pass more than one)
     * @return {Roo.ContentPanel} The panel added (if only one was added; null otherwise)
     */
    add : function(N){
        if(arguments.length > 1){
            for(var  i = 0, len = arguments.length; i < len; i++) {
                this.add(arguments[i]);
            }
            return  null;
        }
        if(this.hasPanel(N)){
            this.showPanel(N);
            return  N;
        }

        N.setRegion(this);
        this.panels.add(N);
        if(this.panels.getCount() == 1 && !this.config.alwaysShowTabs){
            this.bodyEl.dom.appendChild(N.getEl().dom);
            if(N.background !== true){
                this.setActivePanel(N);
            }

            this.fireEvent("paneladded", this, N);
            return  N;
        }
        if(!this.tabs){
            this.initTabs();
        }else {
            this.initPanelAsTab(N);
        }
        if(N.background !== true){
            this.tabs.activate(N.getEl().id);
        }

        this.fireEvent("paneladded", this, N);
        return  N;
    },

    /**
     * Hides the tab for the specified panel.
     * @param {Number/String/ContentPanel} panel The panel's index, id or the panel itself
     */
    hidePanel : function(O){
        if(this.tabs && (O = this.getPanel(O))){
            this.tabs.hideTab(O.getEl().id);
        }
    },

    /**
     * Unhides the tab for a previously hidden panel.
     * @param {Number/String/ContentPanel} panel The panel's index, id or the panel itself
     */
    unhidePanel : function(P){
        if(this.tabs && (P = this.getPanel(P))){
            this.tabs.unhideTab(P.getEl().id);
        }
    },

    clearPanels : function(){
        while(this.panels.getCount() > 0){
             this.remove(this.panels.first());
        }
    },

    /**
     * Removes the specified panel. If preservePanel is not true (either here or in the config), the panel is destroyed.
     * @param {Number/String/ContentPanel} panel The panel's index, id or the panel itself
     * @param {Boolean} preservePanel Overrides the config preservePanel option
     * @return {Roo.ContentPanel} The panel that was removed
     */
    remove : function(Q, R){
        Q = this.getPanel(Q);
        if(!Q){
            return  null;
        }
        var  e = {};
        this.fireEvent("beforeremove", this, Q, e);
        if(e.cancel === true){
            return  null;
        }

        R = (typeof  R != "undefined" ? R : (this.config.preservePanels === true || Q.preserve === true));
        var  S = Q.getId();
        this.panels.removeKey(S);
        if(R){
            document.body.appendChild(Q.getEl().dom);
        }
        if(this.tabs){
            this.tabs.removeTab(Q.getEl().id);
        }else  if (!R){
            this.bodyEl.dom.removeChild(Q.getEl().dom);
        }
        if(this.panels.getCount() == 1 && this.tabs && !this.config.alwaysShowTabs){
            var  p = this.panels.first();
            var  tempEl = document.createElement("div"); // temp holder to keep IE from deleting the node
            tempEl.appendChild(p.getEl().dom);
            this.bodyEl.update("");
            this.bodyEl.dom.appendChild(p.getEl().dom);
            tempEl = null;
            this.updateTitle(p.getTitle());
            this.tabs = null;
            this.bodyEl.setStyle("overflow", this.config.autoScroll ? "auto" : "hidden");
            this.setActivePanel(p);
        }

        Q.setRegion(null);
        if(this.activePanel == Q){
            this.activePanel = null;
        }
        if(this.config.autoDestroy !== false && R !== true){
            try{Q.destroy();}catch(e){}
        }

        this.fireEvent("panelremoved", this, Q);
        return  Q;
    },

    /**
     * Returns the TabPanel component used by this region
     * @return {Roo.TabPanel}
     */
    getTabs : function(){
        return  this.tabs;
    },

    createTool : function(T, U){
        var  V = Roo.DomHelper.append(T, {tag: "div", cls: "x-layout-tools-button",
            children: [{tag: "div", cls: "x-layout-tools-button-inner " + U, html: "&#160;"}]}, true);
        V.addClassOnOver("x-layout-tools-button-over");
        return  V;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 


/**
 * @class Roo.SplitLayoutRegion
 * @extends Roo.LayoutRegion
 * Adds a splitbar and other (private) useful functionality to a {@link Roo.LayoutRegion}.
 */
Roo.SplitLayoutRegion = function(A, B, C, D){
    this.cursor = D;
    Roo.SplitLayoutRegion.superclass.constructor.call(this, A, B, C);
};

Roo.extend(Roo.SplitLayoutRegion, Roo.LayoutRegion, {
    splitTip : "Drag to resize.",
    collapsibleSplitTip : "Drag to resize. Double click to hide.",
    useSplitTips : false,

    applyConfig : function(E){
        Roo.SplitLayoutRegion.superclass.applyConfig.call(this, E);
        if(E.split){
            if(!this.split){
                var  splitEl = Roo.DomHelper.append(this.mgr.el.dom, 
                        {tag: "div", id: this.el.id + "-split", cls: "x-layout-split x-layout-split-"+this.position, html: "&#160;"});
                /** The SplitBar for this region 
                * @type Roo.SplitBar */
                this.split = new  Roo.SplitBar(splitEl, this.el, this.orientation);
                this.split.on("moved", this.onSplitMove, this);
                this.split.useShim = E.useShim === true;
                this.split.getMaximumSize = this[this.position == 'north' || this.position == 'south' ? 'getVMaxSize' : 'getHMaxSize'].createDelegate(this);
                if(this.useSplitTips){
                    this.split.el.dom.title = E.collapsible ? this.collapsibleSplitTip : this.splitTip;
                }
                if(E.collapsible){
                    this.split.el.on("dblclick", this.collapse,  this);
                }
            }
            if(typeof  E.minSize != "undefined"){
                this.split.minSize = E.minSize;
            }
            if(typeof  E.maxSize != "undefined"){
                this.split.maxSize = E.maxSize;
            }
            if(E.hideWhenEmpty || E.hidden || E.collapsed){
                this.hideSplitter();
            }
        }
    },

    getHMaxSize : function(){
         var  F = this.config.maxSize || 10000;
         var  G = this.mgr.getRegion("center");
         return  Math.min(F, (this.el.getWidth()+G.getEl().getWidth())-G.getMinWidth());
    },

    getVMaxSize : function(){
         var  H = this.config.maxSize || 10000;
         var  I = this.mgr.getRegion("center");
         return  Math.min(H, (this.el.getHeight()+I.getEl().getHeight())-I.getMinHeight());
    },

    onSplitMove : function(J, K){
        this.fireEvent("resized", this, K);
    },
    
    /** 
     * Returns the {@link Roo.SplitBar} for this region.
     * @return {Roo.SplitBar}
     */
    getSplitBar : function(){
        return  this.split;
    },
    
    hide : function(){
        this.hideSplitter();
        Roo.SplitLayoutRegion.superclass.hide.call(this);
    },

    hideSplitter : function(){
        if(this.split){
            this.split.el.setLocation(-2000,-2000);
            this.split.el.hide();
        }
    },

    show : function(){
        if(this.split){
            this.split.el.show();
        }

        Roo.SplitLayoutRegion.superclass.show.call(this);
    },
    
    beforeSlide: function(){
        if(Roo.isGecko){// firefox overflow auto bug workaround
            this.bodyEl.clip();
            if(this.tabs) this.tabs.bodyEl.clip();
            if(this.activePanel){
                this.activePanel.getEl().clip();
                
                if(this.activePanel.beforeSlide){
                    this.activePanel.beforeSlide();
                }
            }
        }
    },
    
    afterSlide : function(){
        if(Roo.isGecko){// firefox overflow auto bug workaround
            this.bodyEl.unclip();
            if(this.tabs) this.tabs.bodyEl.unclip();
            if(this.activePanel){
                this.activePanel.getEl().unclip();
                if(this.activePanel.afterSlide){
                    this.activePanel.afterSlide();
                }
            }
        }
    },

    initAutoHide : function(){
        if(this.autoHide !== false){
            if(!this.autoHideHd){
                var  st = new  Roo.util.DelayedTask(this.slideIn, this);
                this.autoHideHd = {
                    "mouseout": function(e){
                        if(!e.within(this.el, true)){
                            st.delay(500);
                        }
                    },
                    "mouseover" : function(e){
                        st.cancel();
                    },
                    scope : this
                };
            }

            this.el.on(this.autoHideHd);
        }
    },

    clearAutoHide : function(){
        if(this.autoHide !== false){
            this.el.un("mouseout", this.autoHideHd.mouseout);
            this.el.un("mouseover", this.autoHideHd.mouseover);
        }
    },

    clearMonitor : function(){
        Roo.get(document).un("click", this.slideInIf, this);
    },

    // these names are backwards but not changed for compat
    slideOut : function(){
        if(this.isSlid || this.el.hasActiveFx()){
            return;
        }

        this.isSlid = true;
        if(this.collapseBtn){
            this.collapseBtn.hide();
        }

        this.closeBtnState = this.closeBtn.getStyle('display');
        this.closeBtn.hide();
        if(this.stickBtn){
            this.stickBtn.show();
        }

        this.el.show();
        this.el.alignTo(this.collapsedEl, this.getCollapseAnchor());
        this.beforeSlide();
        this.el.setStyle("z-index", 10001);
        this.el.slideIn(this.getSlideAnchor(), {
            callback: function(){
                this.afterSlide();
                this.initAutoHide();
                Roo.get(document).on("click", this.slideInIf, this);
                this.fireEvent("slideshow", this);
            },
            scope: this,
            block: true
        });
    },

    afterSlideIn : function(){
        this.clearAutoHide();
        this.isSlid = false;
        this.clearMonitor();
        this.el.setStyle("z-index", "");
        if(this.collapseBtn){
            this.collapseBtn.show();
        }

        this.closeBtn.setStyle('display', this.closeBtnState);
        if(this.stickBtn){
            this.stickBtn.hide();
        }

        this.fireEvent("slidehide", this);
    },

    slideIn : function(cb){
        if(!this.isSlid || this.el.hasActiveFx()){
            Roo.callback(cb);
            return;
        }

        this.isSlid = false;
        this.beforeSlide();
        this.el.slideOut(this.getSlideAnchor(), {
            callback: function(){
                this.el.setLeftTop(-10000, -10000);
                this.afterSlide();
                this.afterSlideIn();
                Roo.callback(cb);
            },
            scope: this,
            block: true
        });
    },
    
    slideInIf : function(e){
        if(!e.within(this.el)){
            this.slideIn();
        }
    },

    animateCollapse : function(){
        this.beforeSlide();
        this.el.setStyle("z-index", 20000);
        var  L = this.getSlideAnchor();
        this.el.slideOut(L, {
            callback : function(){
                this.el.setStyle("z-index", "");
                this.collapsedEl.slideIn(L, {duration:.3});
                this.afterSlide();
                this.el.setLocation(-10000,-10000);
                this.el.hide();
                this.fireEvent("collapsed", this);
            },
            scope: this,
            block: true
        });
    },

    animateExpand : function(){
        this.beforeSlide();
        this.el.alignTo(this.collapsedEl, this.getCollapseAnchor(), this.getExpandAdj());
        this.el.setStyle("z-index", 20000);
        this.collapsedEl.hide({
            duration:.1
        });
        this.el.slideIn(this.getSlideAnchor(), {
            callback : function(){
                this.el.setStyle("z-index", "");
                this.afterSlide();
                if(this.split){
                    this.split.el.show();
                }

                this.fireEvent("invalidated", this);
                this.fireEvent("expanded", this);
            },
            scope: this,
            block: true
        });
    },

    anchors : {
        "west" : "left",
        "east" : "right",
        "north" : "top",
        "south" : "bottom"
    },

    sanchors : {
        "west" : "l",
        "east" : "r",
        "north" : "t",
        "south" : "b"
    },

    canchors : {
        "west" : "tl-tr",
        "east" : "tr-tl",
        "north" : "tl-bl",
        "south" : "bl-tl"
    },

    getAnchor : function(){
        return  this.anchors[this.position];
    },

    getCollapseAnchor : function(){
        return  this.canchors[this.position];
    },

    getSlideAnchor : function(){
        return  this.sanchors[this.position];
    },

    getAlignAdj : function(){
        var  cm = this.cmargins;
        switch(this.position){
            case  "west":
                return  [0, 0];
            break;
            case  "east":
                return  [0, 0];
            break;
            case  "north":
                return  [0, 0];
            break;
            case  "south":
                return  [0, 0];
            break;
        }
    },

    getExpandAdj : function(){
        var  c = this.collapsedEl, cm = this.cmargins;
        switch(this.position){
            case  "west":
                return  [-(cm.right+c.getWidth()+cm.left), 0];
            break;
            case  "east":
                return  [cm.right+c.getWidth()+cm.left, 0];
            break;
            case  "north":
                return  [0, -(cm.top+cm.bottom+c.getHeight())];
            break;
            case  "south":
                return  [0, cm.top+cm.bottom+c.getHeight()];
            break;
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/*
 * These classes are private internal classes
 */
Roo.CenterLayoutRegion = function(A, B){
    Roo.LayoutRegion.call(this, A, B, "center");
    this.visible = true;
    this.minWidth = B.minWidth || 20;
    this.minHeight = B.minHeight || 20;
};

Roo.extend(Roo.CenterLayoutRegion, Roo.LayoutRegion, {
    hide : function(){
        // center panel can't be hidden
    },
    
    show : function(){
        // center panel can't be hidden
    },
    
    getMinWidth: function(){
        return  this.minWidth;
    },
    
    getMinHeight: function(){
        return  this.minHeight;
    }
});


Roo.NorthLayoutRegion = function(C, D){
    Roo.LayoutRegion.call(this, C, D, "north", "n-resize");
    if(this.split){
        this.split.placement = Roo.SplitBar.TOP;
        this.split.orientation = Roo.SplitBar.VERTICAL;
        this.split.el.addClass("x-layout-split-v");
    }
    var  E = D.initialSize || D.height;
    if(typeof  E != "undefined"){
        this.el.setHeight(E);
    }
};
Roo.extend(Roo.NorthLayoutRegion, Roo.SplitLayoutRegion, {
    orientation: Roo.SplitBar.VERTICAL,
    getBox : function(){
        if(this.collapsed){
            return  this.collapsedEl.getBox();
        }
        var  F = this.el.getBox();
        if(this.split){
            F.height += this.split.el.getHeight();
        }
        return  F;
    },
    
    updateBox : function(G){
        if(this.split && !this.collapsed){
            G.height -= this.split.el.getHeight();
            this.split.el.setLeft(G.x);
            this.split.el.setTop(G.y+G.height);
            this.split.el.setWidth(G.width);
        }
        if(this.collapsed){
            this.updateBody(G.width, null);
        }

        Roo.LayoutRegion.prototype.updateBox.call(this, G);
    }
});

Roo.SouthLayoutRegion = function(H, I){
    Roo.SplitLayoutRegion.call(this, H, I, "south", "s-resize");
    if(this.split){
        this.split.placement = Roo.SplitBar.BOTTOM;
        this.split.orientation = Roo.SplitBar.VERTICAL;
        this.split.el.addClass("x-layout-split-v");
    }
    var  J = I.initialSize || I.height;
    if(typeof  J != "undefined"){
        this.el.setHeight(J);
    }
};
Roo.extend(Roo.SouthLayoutRegion, Roo.SplitLayoutRegion, {
    orientation: Roo.SplitBar.VERTICAL,
    getBox : function(){
        if(this.collapsed){
            return  this.collapsedEl.getBox();
        }
        var  K = this.el.getBox();
        if(this.split){
            var  sh = this.split.el.getHeight();
            K.height += sh;
            K.y -= sh;
        }
        return  K;
    },
    
    updateBox : function(L){
        if(this.split && !this.collapsed){
            var  sh = this.split.el.getHeight();
            L.height -= sh;
            L.y += sh;
            this.split.el.setLeft(L.x);
            this.split.el.setTop(L.y-sh);
            this.split.el.setWidth(L.width);
        }
        if(this.collapsed){
            this.updateBody(L.width, null);
        }

        Roo.LayoutRegion.prototype.updateBox.call(this, L);
    }
});

Roo.EastLayoutRegion = function(M, N){
    Roo.SplitLayoutRegion.call(this, M, N, "east", "e-resize");
    if(this.split){
        this.split.placement = Roo.SplitBar.RIGHT;
        this.split.orientation = Roo.SplitBar.HORIZONTAL;
        this.split.el.addClass("x-layout-split-h");
    }
    var  O = N.initialSize || N.width;
    if(typeof  O != "undefined"){
        this.el.setWidth(O);
    }
};
Roo.extend(Roo.EastLayoutRegion, Roo.SplitLayoutRegion, {
    orientation: Roo.SplitBar.HORIZONTAL,
    getBox : function(){
        if(this.collapsed){
            return  this.collapsedEl.getBox();
        }
        var  P = this.el.getBox();
        if(this.split){
            var  sw = this.split.el.getWidth();
            P.width += sw;
            P.x -= sw;
        }
        return  P;
    },

    updateBox : function(Q){
        if(this.split && !this.collapsed){
            var  sw = this.split.el.getWidth();
            Q.width -= sw;
            this.split.el.setLeft(Q.x);
            this.split.el.setTop(Q.y);
            this.split.el.setHeight(Q.height);
            Q.x += sw;
        }
        if(this.collapsed){
            this.updateBody(null, Q.height);
        }

        Roo.LayoutRegion.prototype.updateBox.call(this, Q);
    }
});

Roo.WestLayoutRegion = function(R, S){
    Roo.SplitLayoutRegion.call(this, R, S, "west", "w-resize");
    if(this.split){
        this.split.placement = Roo.SplitBar.LEFT;
        this.split.orientation = Roo.SplitBar.HORIZONTAL;
        this.split.el.addClass("x-layout-split-h");
    }
    var  T = S.initialSize || S.width;
    if(typeof  T != "undefined"){
        this.el.setWidth(T);
    }
};
Roo.extend(Roo.WestLayoutRegion, Roo.SplitLayoutRegion, {
    orientation: Roo.SplitBar.HORIZONTAL,
    getBox : function(){
        if(this.collapsed){
            return  this.collapsedEl.getBox();
        }
        var  U = this.el.getBox();
        if(this.split){
            U.width += this.split.el.getWidth();
        }
        return  U;
    },
    
    updateBox : function(V){
        if(this.split && !this.collapsed){
            var  sw = this.split.el.getWidth();
            V.width -= sw;
            this.split.el.setLeft(V.x+V.width);
            this.split.el.setTop(V.y);
            this.split.el.setHeight(V.height);
        }
        if(this.collapsed){
            this.updateBody(null, V.height);
        }

        Roo.LayoutRegion.prototype.updateBox.call(this, V);
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
 
/*
 * Private internal class for reading and applying state
 */
Roo.LayoutStateManager = function(A){
     // default empty state
     this.state = {
        north: {},
        south: {},
        east: {},
        west: {}       
    };
};

Roo.LayoutStateManager.prototype = {
    init : function(B, C){
        this.provider = C;
        var  D = C.get(B.id+"-layout-state");
        if(D){
            var  wasUpdating = B.isUpdating();
            if(!wasUpdating){
                B.beginUpdate();
            }
            for(var  key  in  D){
                if(typeof  D[key] != "function"){
                    var  rstate = D[key];
                    var  r = B.getRegion(key);
                    if(r && rstate){
                        if(rstate.size){
                            r.resizeTo(rstate.size);
                        }
                        if(rstate.collapsed == true){
                            r.collapse(true);
                        }else {
                            r.expand(null, true);
                        }
                    }
                }
            }
            if(!wasUpdating){
                B.endUpdate();
            }

            this.state = D; 
        }

        this.layout = B;
        B.on("regionresized", this.onRegionResized, this);
        B.on("regioncollapsed", this.onRegionCollapsed, this);
        B.on("regionexpanded", this.onRegionExpanded, this);
    },
    
    storeState : function(){
        this.provider.set(this.layout.id+"-layout-state", this.state);
    },
    
    onRegionResized : function(E, F){
        this.state[E.getPosition()].size = F;
        this.storeState();
    },
    
    onRegionCollapsed : function(G){
        this.state[G.getPosition()].collapsed = true;
        this.storeState();
    },
    
    onRegionExpanded : function(H){
        this.state[H.getPosition()].collapsed = false;
        this.storeState();
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.ContentPanel
 * @extends Roo.util.Observable
 * A basic ContentPanel element.
 * @cfg {Boolean} fitToFrame True for this panel to adjust its size to fit when the region resizes  (defaults to false)
 * @cfg {Boolean} fitContainer When using {@link #fitToFrame} and {@link #resizeEl}, you can also fit the parent container  (defaults to false)
 * @cfg {Boolean/Object} autoCreate True to auto generate the DOM element for this panel, or a {@link Roo.DomHelper} config of the element to create
 * @cfg {Boolean} closable True if the panel can be closed/removed
 * @cfg {Boolean} background True if the panel should not be activated when it is added (defaults to false)
 * @cfg {String/HTMLElement/Element} resizeEl An element to resize if {@link #fitToFrame} is true (instead of this panel's element)
 * @cfg {Toolbar} toolbar A toolbar for this panel
 * @cfg {Boolean} autoScroll True to scroll overflow in this panel (use with {@link #fitToFrame})
 * @cfg {String} title The title for this panel
 * @cfg {Array} adjustments Values to <b>add</b> to the width/height when doing a {@link #fitToFrame} (default is [0, 0])
 * @cfg {String} url Calls {@link #setUrl} with this value
 * @cfg {String/Object} params When used with {@link #url}, calls {@link #setUrl} with this value
 * @cfg {Boolean} loadOnce When used with {@link #url}, calls {@link #setUrl} with this value
 * @constructor
 * Create a new ContentPanel.
 * @param {String/HTMLElement/Roo.Element} el The container element for this panel
 * @param {String/Object} config A string to set only the title or a config object
 * @param {String} content (optional) Set the HTML content for this panel
 * @param {String} region (optional) Used by xtype constructors to add to regions. (values center,east,west,south,north)
 */
Roo.ContentPanel = function(el, A, B){
    
     
    /*
    if(el.autoCreate || el.xtype){ // xtype is available if this is called from factory
        config = el;
        el = Roo.id();
    }
    if (config && config.parentLayout) { 
        el = config.parentLayout.el.createChild(); 
    }
    */
    if(el.autoCreate){ // xtype is available if this is called from factory
        A = el;
        el = Roo.id();
    }

    this.el = Roo.get(el);
    if(!this.el && A && A.autoCreate){
        if(typeof  A.autoCreate == "object"){
            if(!A.autoCreate.id){
                A.autoCreate.id = A.id||el;
            }

            this.el = Roo.DomHelper.append(document.body,
                        A.autoCreate, true);
        }else {
            this.el = Roo.DomHelper.append(document.body,
                        {tag: "div", cls: "x-layout-inactive-content", id: A.id||el}, true);
        }
    }

    this.closable = false;
    this.loaded = false;
    this.active = false;
    if(typeof  A == "string"){
        this.title = A;
    }else {
        Roo.apply(this, A);
    }
    
    if (this.toolbar && !this.toolbar.el && this.toolbar.xtype) {
        this.wrapEl = this.el.wrap();    
        this.toolbar = new  Roo.Toolbar(this.el.insertSibling(false, 'before'), [] , this.toolbar);
        
    }
    
    
    
    if(this.resizeEl){
        this.resizeEl = Roo.get(this.resizeEl, true);
    }else {
        this.resizeEl = this.el;
    }

    this.addEvents({
        /**
         * @event activate
         * Fires when this panel is activated. 
         * @param {Roo.ContentPanel} this
         */
        "activate" : true,
        /**
         * @event deactivate
         * Fires when this panel is activated. 
         * @param {Roo.ContentPanel} this
         */
        "deactivate" : true,

        /**
         * @event resize
         * Fires when this panel is resized if fitToFrame is true.
         * @param {Roo.ContentPanel} this
         * @param {Number} width The width after any component adjustments
         * @param {Number} height The height after any component adjustments
         */
        "resize" : true
    });
    if(this.autoScroll){
        this.resizeEl.setStyle("overflow", "auto");
    }

    B = B || this.content;
    if(B){
        this.setContent(B);
    }
    if(A && A.url){
        this.setUrl(this.url, this.params, this.loadOnce);
    }

    
    
    
    Roo.ContentPanel.superclass.constructor.call(this);
};

Roo.extend(Roo.ContentPanel, Roo.util.Observable, {
    tabTip:'',
    setRegion : function(C){
        this.region = C;
        if(C){
           this.el.replaceClass("x-layout-inactive-content", "x-layout-active-content");
        }else {
           this.el.replaceClass("x-layout-active-content", "x-layout-inactive-content");
        } 
    },
    
    /**
     * Returns the toolbar for this Panel if one was configured. 
     * @return {Roo.Toolbar} 
     */
    getToolbar : function(){
        return  this.toolbar;
    },
    
    setActiveState : function(D){
        this.active = D;
        if(!D){
            this.fireEvent("deactivate", this);
        }else {
            this.fireEvent("activate", this);
        }
    },
    /**
     * Updates this panel's element
     * @param {String} content The new content
     * @param {Boolean} loadScripts (optional) true to look for and process scripts
    */
    setContent : function(E, F){
        this.el.update(E, F);
    },

    ignoreResize : function(w, h){
        if(this.lastSize && this.lastSize.width == w && this.lastSize.height == h){
            return  true;
        }else {
            this.lastSize = {width: w, height: h};
            return  false;
        }
    },
    /**
     * Get the {@link Roo.UpdateManager} for this panel. Enables you to perform Ajax updates.
     * @return {Roo.UpdateManager} The UpdateManager
     */
    getUpdateManager : function(){
        return  this.el.getUpdateManager();
    },
     /**
     * Loads this content panel immediately with content from XHR. Note: to delay loading until the panel is activated, use {@link #setUrl}.
     * @param {Object/String/Function} url The url for this request or a function to call to get the url or a config object containing any of the following options:
<pre><code>
panel.load({
    url: "your-url.php",
    params: {param1: "foo", param2: "bar"}, // or a URL encoded string
    callback: yourFunction,
    scope: yourObject, //(optional scope)
    discardUrl: false,
    nocache: false,
    text: "Loading...",
    timeout: 30,
    scripts: false
});
</code></pre>
     * The only required property is <i>url</i>. The optional properties <i>nocache</i>, <i>text</i> and <i>scripts</i>
     * are shorthand for <i>disableCaching</i>, <i>indicatorText</i> and <i>loadScripts</i> and are used to set their associated property on this panel UpdateManager instance.
     * @param {String/Object} params (optional) The parameters to pass as either a URL encoded string "param1=1&amp;param2=2" or an object {param1: 1, param2: 2}
     * @param {Function} callback (optional) Callback when transaction is complete -- called with signature (oElement, bSuccess, oResponse)
     * @param {Boolean} discardUrl (optional) By default when you execute an update the defaultUrl is changed to the last used URL. If true, it will not store the URL.
     * @return {Roo.ContentPanel} this
     */
    load : function(){
        var  um = this.el.getUpdateManager();
        um.update.apply(um, arguments);
        return  this;
    },


    /**
     * Set a URL to be used to load the content for this panel. When this panel is activated, the content will be loaded from that URL.
     * @param {String/Function} url The URL to load the content from or a function to call to get the URL
     * @param {String/Object} params (optional) The string params for the update call or an object of the params. See {@link Roo.UpdateManager#update} for more details. (Defaults to null)
     * @param {Boolean} loadOnce (optional) Whether to only load the content once. If this is false it makes the Ajax call every time this panel is activated. (Defaults to false)
     * @return {Roo.UpdateManager} The UpdateManager
     */
    setUrl : function(G, H, I){
        if(this.refreshDelegate){
            this.removeListener("activate", this.refreshDelegate);
        }

        this.refreshDelegate = this._handleRefresh.createDelegate(this, [G, H, I]);
        this.on("activate", this.refreshDelegate);
        return  this.el.getUpdateManager();
    },
    
    _handleRefresh : function(J, K, L){
        if(!L || !this.loaded){
            var  updater = this.el.getUpdateManager();
            updater.update(J, K, this._setLoaded.createDelegate(this));
        }
    },
    
    _setLoaded : function(){
        this.loaded = true;
    }, 
    
    /**
     * Returns this panel's id
     * @return {String} 
     */
    getId : function(){
        return  this.el.id;
    },
    
    /** 
     * Returns this panel's element - used by regiosn to add.
     * @return {Roo.Element} 
     */
    getEl : function(){
        return  this.wrapEl || this.el;
    },
    
    adjustForComponents : function(M, N){
        if(this.resizeEl != this.el){
            M -= this.el.getFrameWidth('lr');
            N -= this.el.getFrameWidth('tb');
        }
        if(this.toolbar){
            var  te = this.toolbar.getEl();
            N -= te.getHeight();
            te.setWidth(M);
        }
        if(this.adjustments){
            M += this.adjustments[0];
            N += this.adjustments[1];
        }
        return  {"width": M, "height": N};
    },
    
    setSize : function(O, P){
        if(this.fitToFrame && !this.ignoreResize(O, P)){
            if(this.fitContainer && this.resizeEl != this.el){
                this.el.setSize(O, P);
            }
            var  size = this.adjustForComponents(O, P);
            this.resizeEl.setSize(this.autoWidth ? "auto" : size.width, this.autoHeight ? "auto" : size.height);
            this.fireEvent('resize', this, size.width, size.height);
        }
    },
    
    /**
     * Returns this panel's title
     * @return {String} 
     */
    getTitle : function(){
        return  this.title;
    },
    
    /**
     * Set this panel's title
     * @param {String} title
     */
    setTitle : function(Q){
        this.title = Q;
        if(this.region){
            this.region.updatePanelTitle(this, Q);
        }
    },
    
    /**
     * Returns true is this panel was configured to be closable
     * @return {Boolean} 
     */
    isClosable : function(){
        return  this.closable;
    },
    
    beforeSlide : function(){
        this.el.clip();
        this.resizeEl.clip();
    },
    
    afterSlide : function(){
        this.el.unclip();
        this.resizeEl.unclip();
    },
    
    /**
     *   Force a content refresh from the URL specified in the {@link #setUrl} method.
     *   Will fail silently if the {@link #setUrl} method has not been called.
     *   This does not activate the panel, just updates its content.
     */
    refresh : function(){
        if(this.refreshDelegate){
           this.loaded = false;
           this.refreshDelegate();
        }
    },
    
    /**
     * Destroys this panel
     */
    destroy : function(){
        this.el.removeAllListeners();
        var  R = document.createElement("span");
        R.appendChild(this.el.dom);
        R.innerHTML = "";
        this.el.remove();
        this.el = null;
    },
    
      /**
     * Adds a xtype elements to the panel - currently only supports Forms.
     * <pre><code>

layout.addxtype({
       xtype : 'Form',
       items: [ .... ]
   }
);

</code></pre>
     * @param {Object} cfg Xtype definition of item to add.
     */
    
    addxtype : function(S) {
        // add form..
        if (!S.xtype.match(/^Form$/)) {
            return  false;
        }
        var  el = this.el.createChild();

        this.form = new   Roo.form.Form(S);
        
        
        if ( this.form.allItems.length) this.form.render(el.dom);
        return  this.form;
        
    }
});

/**
 * @class Roo.GridPanel
 * @extends Roo.ContentPanel
 * @constructor
 * Create a new GridPanel.
 * @param {Roo.grid.Grid} grid The grid for this panel
 * @param {String/Object} config A string to set only the panel's title, or a config object
 */
Roo.GridPanel = function(T, U){
    
  
    this.wrapper = Roo.DomHelper.append(document.body, // wrapper for IE7 strict & safari scroll issue
        {tag: "div", cls: "x-layout-grid-wrapper x-layout-inactive-content"}, true);
        
    this.wrapper.dom.appendChild(T.getGridEl().dom);
    
    Roo.GridPanel.superclass.constructor.call(this, this.wrapper, U);
    
    if(this.toolbar){
        this.toolbar.el.insertBefore(this.wrapper.dom.firstChild);
    }
    // xtype created footer. - not sure if will work as we normally have to render first..
    if (this.footer && !this.footer.el && this.footer.xtype) {
        
        this.footer.container = this.grid.getView().getFooterPanel(true);
        this.footer.dataSource = this.grid.dataSource;
        this.footer = Roo.factory(this.footer, Roo);
        
    }

    
    T.monitorWindowResize = false; // turn off autosizing
    T.autoHeight = false;
    T.autoWidth = false;
    this.grid = T;
    this.grid.getGridEl().replaceClass("x-layout-inactive-content", "x-layout-component-panel");
};

Roo.extend(Roo.GridPanel, Roo.ContentPanel, {
    getId : function(){
        return  this.grid.id;
    },
    
    /**
     * Returns the grid for this panel
     * @return {Roo.grid.Grid} 
     */
    getGrid : function(){
        return  this.grid;    
    },
    
    setSize : function(V, W){
        if(!this.ignoreResize(V, W)){
            var  T = this.grid;
            var  size = this.adjustForComponents(V, W);
            T.getGridEl().setSize(size.width, size.height);
            T.autoSize();
        }
    },
    
    beforeSlide : function(){
        this.grid.getView().scroller.clip();
    },
    
    afterSlide : function(){
        this.grid.getView().scroller.unclip();
    },
    
    destroy : function(){
        this.grid.destroy();
        delete  this.grid;
        Roo.GridPanel.superclass.destroy.call(this); 
    }
});


/**
 * @class Roo.NestedLayoutPanel
 * @extends Roo.ContentPanel
 * @constructor
 * Create a new NestedLayoutPanel.
 * 
 * 
 * @param {Roo.BorderLayout} layout The layout for this panel
 * @param {String/Object} config A string to set only the title or a config object
 */
Roo.NestedLayoutPanel = function(X, Y)
{
    // construct with only one argument..
    /* FIXME - implement nicer consturctors
    if (layout.layout) {
        config = layout;
        layout = config.layout;
        delete config.layout;
    }
    if (layout.xtype && !layout.getEl) {
        // then layout needs constructing..
        layout = Roo.factory(layout, Roo);
    }
    */
    
    Roo.NestedLayoutPanel.superclass.constructor.call(this, X.getEl(), Y);
    
    X.monitorWindowResize = false; // turn off autosizing
    this.layout = X;
    this.layout.getEl().addClass("x-layout-nested-layout");
    
    
    
};

Roo.extend(Roo.NestedLayoutPanel, Roo.ContentPanel, {

    setSize : function(Z, a){
        if(!this.ignoreResize(Z, a)){
            var  size = this.adjustForComponents(Z, a);
            var  el = this.layout.getEl();
            el.setSize(size.width, size.height);
            var  touch = el.dom.offsetWidth;
            this.layout.layout();
            // ie requires a double layout on the first pass
            if(Roo.isIE && !this.initialized){
                this.initialized = true;
                this.layout.layout();
            }
        }
    },
    
    // activate all subpanels if not currently active..
    
    setActiveState : function(b){
        this.active = b;
        if(!b){
            this.fireEvent("deactivate", this);
            return;
        }

        
        this.fireEvent("activate", this);
        // not sure if this should happen before or after..
        if (!this.layout) {
            return; // should not happen..
        }
        var  c = false;
        for (var  r  in  this.layout.regions) {
            c = this.layout.getRegion(r);
            if (c.getActivePanel()) {
                //reg.showPanel(reg.getActivePanel()); // force it to activate.. 
                c.setActivePanel(c.getActivePanel());
                continue;
            }
            if (!c.panels.length) {
                continue;
            }

            c.showPanel(c.getPanel(0));
        }
        
        
        
        
    },
    
    /**
     * Returns the nested BorderLayout for this panel
     * @return {Roo.BorderLayout} 
     */
    getLayout : function(){
        return  this.layout;
    },
    
     /**
     * Adds a xtype elements to the layout of the nested panel
     * <pre><code>

panel.addxtype({
       xtype : 'ContentPanel',
       region: 'west',
       items: [ .... ]
   }
);

panel.addxtype({
        xtype : 'NestedLayoutPanel',
        region: 'west',
        layout: {
           center: { },
           west: { }   
        },
        items : [ ... list of content panels or nested layout panels.. ]
   }
);
</code></pre>
     * @param {Object} cfg Xtype definition of item to add.
     */
    addxtype : function(d) {
        return  this.layout.addxtype(d);
    
    }
});

Roo.ScrollPanel = function(el, e, f){
    e = e || {};
    e.fitToFrame = true;
    Roo.ScrollPanel.superclass.constructor.call(this, el, e, f);
    
    this.el.dom.style.overflow = "hidden";
    var  g = this.el.wrap({cls: "x-scroller x-layout-inactive-content"});
    this.el.removeClass("x-layout-inactive-content");
    this.el.on("mousewheel", this.onWheel, this);

    var  up = g.createChild({cls: "x-scroller-up", html: "&#160;"}, this.el.dom);
    var  i = g.createChild({cls: "x-scroller-down", html: "&#160;"});
    up.unselectable(); i.unselectable();
    up.on("click", this.scrollUp, this);
    i.on("click", this.scrollDown, this);
    up.addClassOnOver("x-scroller-btn-over");
    i.addClassOnOver("x-scroller-btn-over");
    up.addClassOnClick("x-scroller-btn-click");
    i.addClassOnClick("x-scroller-btn-click");
    this.adjustments = [0, -(up.getHeight() + i.getHeight())];

    this.resizeEl = this.el;
    this.el = g; this.up = up; this.down = i;
};

Roo.extend(Roo.ScrollPanel, Roo.ContentPanel, {
    increment : 100,
    wheelIncrement : 5,
    scrollUp : function(){
        this.resizeEl.scroll("up", this.increment, {callback: this.afterScroll, scope: this});
    },

    scrollDown : function(){
        this.resizeEl.scroll("down", this.increment, {callback: this.afterScroll, scope: this});
    },

    afterScroll : function(){
        var  el = this.resizeEl;
        var  t = el.dom.scrollTop, h = el.dom.scrollHeight, ch = el.dom.clientHeight;
        this.up[t == 0 ? "addClass" : "removeClass"]("x-scroller-btn-disabled");
        this.down[h - t <= ch ? "addClass" : "removeClass"]("x-scroller-btn-disabled");
    },

    setSize : function(){
        Roo.ScrollPanel.superclass.setSize.apply(this, arguments);
        this.afterScroll();
    },

    onWheel : function(e){
        var  d = e.getWheelDelta();
        this.resizeEl.dom.scrollTop -= (d*this.wheelIncrement);
        this.afterScroll();
        e.stopEvent();
    },

    setContent : function(j, k){
        this.resizeEl.update(j, k);
    }

});









/**
 * @class Roo.TreePanel
 * @extends Roo.ContentPanel
 * @constructor
 * Create a new TreePanel.
 * @param {String/Object} config A string to set only the panel's title, or a config object
 * @cfg {Roo.tree.TreePanel} tree The tree TreePanel, with config etc.
 */
Roo.TreePanel = function(l){
    var  el = l.el;
    var  m = l.tree;
    delete  l.tree; 
    delete  l.el; // hopefull!
    Roo.TreePanel.superclass.constructor.call(this, el, l);
    var  n = el.createChild();
    this.tree = new  Roo.tree.TreePanel(n , m);
    //console.log(tree);
    this.on('activate', function()
    {
        if (this.tree.rendered) {
            return;
        }

        //console.log('render tree');
        this.tree.render();
    });
    
    this.on('resize',  function (cp, w, h) {
            this.tree.innerCt.setWidth(w);
            this.tree.innerCt.setHeight(h);
            this.tree.innerCt.setStyle('overflow-y', 'auto');
    });

        
    
};

Roo.extend(Roo.TreePanel, Roo.ContentPanel);












/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.ReaderLayout
 * @extends Roo.BorderLayout
 * This is a pre-built layout that represents a classic, 5-pane application.  It consists of a header, a primary
 * center region containing two nested regions (a top one for a list view and one for item preview below),
 * and regions on either side that can be used for navigation, application commands, informational displays, etc.
 * The setup and configuration work exactly the same as it does for a {@link Roo.BorderLayout} - this class simply
 * expedites the setup of the overall layout and regions for this common application style.
 * Example:
 <pre><code>
var reader = new Roo.ReaderLayout();
var CP = Roo.ContentPanel;  // shortcut for adding

reader.beginUpdate();
reader.add("north", new CP("north", "North"));
reader.add("west", new CP("west", {title: "West"}));
reader.add("east", new CP("east", {title: "East"}));

reader.regions.listView.add(new CP("listView", "List"));
reader.regions.preview.add(new CP("preview", "Preview"));
reader.endUpdate();
</code></pre>
* @constructor
* Create a new ReaderLayout
* @param {Object} config Configuration options
* @param {String/HTMLElement/Element} container (optional) The container this layout is bound to (defaults to
* document.body if omitted)
*/
Roo.ReaderLayout = function(A, B){
    var  c = A || {size:{}};
    Roo.ReaderLayout.superclass.constructor.call(this, B || document.body, {
        north: c.north !== false ? Roo.apply({
            split:false,
            initialSize: 32,
            titlebar: false
        }, c.north) : false,
        west: c.west !== false ? Roo.apply({
            split:true,
            initialSize: 200,
            minSize: 175,
            maxSize: 400,
            titlebar: true,
            collapsible: true,
            animate: true,
            margins:{left:5,right:0,bottom:5,top:5},
            cmargins:{left:5,right:5,bottom:5,top:5}
        }, c.west) : false,
        east: c.east !== false ? Roo.apply({
            split:true,
            initialSize: 200,
            minSize: 175,
            maxSize: 400,
            titlebar: true,
            collapsible: true,
            animate: true,
            margins:{left:0,right:5,bottom:5,top:5},
            cmargins:{left:5,right:5,bottom:5,top:5}
        }, c.east) : false,
        center: Roo.apply({
            tabPosition: 'top',
            autoScroll:false,
            closeOnTab: true,
            titlebar:false,
            margins:{left:c.west!==false ? 0 : 5,right:c.east!==false ? 0 : 5,bottom:5,top:2}
        }, c.center)
    });

    this.el.addClass('x-reader');

    this.beginUpdate();

    var  C = new  Roo.BorderLayout(Roo.get(document.body).createChild(), {
        south: c.preview !== false ? Roo.apply({
            split:true,
            initialSize: 200,
            minSize: 100,
            autoScroll:true,
            collapsible:true,
            titlebar: true,
            cmargins:{top:5,left:0, right:0, bottom:0}
        }, c.preview) : false,
        center: Roo.apply({
            autoScroll:false,
            titlebar:false,
            minHeight:200
        }, c.listView)
    });
    this.add('center', new  Roo.NestedLayoutPanel(C,
            Roo.apply({title: c.mainTitle || '',tabTip:''},c.innerPanelCfg)));

    this.endUpdate();

    this.regions.preview = C.getRegion('south');
    this.regions.listView = C.getRegion('center');
};

Roo.extend(Roo.ReaderLayout, Roo.BorderLayout);
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.grid.Grid
 * @extends Roo.util.Observable
 * This class represents the primary interface of a component based grid control.
 * <br><br>Usage:<pre><code>
 var grid = new Roo.grid.Grid("my-container-id", {
     ds: myDataStore,
     cm: myColModel,
     selModel: mySelectionModel,
     autoSizeColumns: true,
     monitorWindowResize: false,
     trackMouseOver: true
 });
 // set any options
 grid.render();
 * </code></pre>
 * <b>Common Problems:</b><br/>
 * - Grid does not resize properly when going smaller: Setting overflow hidden on the container
 * element will correct this<br/>
 * - If you get el.style[camel]= NaNpx or -2px or something related, be certain you have given your container element
 * dimensions. The grid adapts to your container's size, if your container has no size defined then the results
 * are unpredictable.<br/>
 * - Do not render the grid into an element with display:none. Try using visibility:hidden. Otherwise there is no way for the
 * grid to calculate dimensions/offsets.<br/>
  * @constructor
 * @param {String/HTMLElement/Roo.Element} container The element into which this grid will be rendered -
 * The container MUST have some type of size defined for the grid to fill. The container will be
 * automatically set to position relative if it isn't already.
 * @param {Object} config A config object that sets properties on this grid.
 */
Roo.grid.Grid = function(A, B){
	// initialize the container
	this.container = Roo.get(A);
	this.container.update("");
	this.container.setStyle("overflow", "hidden");
    this.container.addClass('x-grid-container');

    this.id = this.container.id;

    Roo.apply(this, B);
    // check and correct shorthanded configs
    if(this.ds){
        this.dataSource = this.ds;
        delete  this.ds;
    }
    if(this.cm){
        this.colModel = this.cm;
        delete  this.cm;
    }
    if(this.sm){
        this.selModel = this.sm;
        delete  this.sm;
    }

    if (this.selModel) {
        this.selModel = Roo.factory(this.selModel, Roo.grid);
        this.sm = this.selModel;
        this.sm.xmodule = this.xmodule || false;
    }
    if (typeof(this.colModel.config) == 'undefined') {
        this.colModel = new  Roo.grid.ColumnModel(this.colModel);
        this.cm = this.colModel;
        this.cm.xmodule = this.xmodule || false;
    }
    if (this.dataSource) {
        this.dataSource= Roo.factory(this.dataSource, Roo.data);
        this.ds = this.dataSource;
        this.ds.xmodule = this.xmodule || false;
        
    }
    
    
    
    if(this.width){
        this.container.setWidth(this.width);
    }

    if(this.height){
        this.container.setHeight(this.height);
    }

    /** @private */
	this.addEvents({
	    // raw events
	    /**
	     * @event click
	     * The raw click event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "click" : true,
	    /**
	     * @event dblclick
	     * The raw dblclick event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "dblclick" : true,
	    /**
	     * @event contextmenu
	     * The raw contextmenu event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "contextmenu" : true,
	    /**
	     * @event mousedown
	     * The raw mousedown event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "mousedown" : true,
	    /**
	     * @event mouseup
	     * The raw mouseup event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "mouseup" : true,
	    /**
	     * @event mouseover
	     * The raw mouseover event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "mouseover" : true,
	    /**
	     * @event mouseout
	     * The raw mouseout event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "mouseout" : true,
	    /**
	     * @event keypress
	     * The raw keypress event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "keypress" : true,
	    /**
	     * @event keydown
	     * The raw keydown event for the entire grid.
	     * @param {Roo.EventObject} e
	     */
	    "keydown" : true,

	    // custom events

	    /**
	     * @event cellclick
	     * Fires when a cell is clicked
	     * @param {Grid} this
	     * @param {Number} rowIndex
	     * @param {Number} columnIndex
	     * @param {Roo.EventObject} e
	     */
	    "cellclick" : true,
	    /**
	     * @event celldblclick
	     * Fires when a cell is double clicked
	     * @param {Grid} this
	     * @param {Number} rowIndex
	     * @param {Number} columnIndex
	     * @param {Roo.EventObject} e
	     */
	    "celldblclick" : true,
	    /**
	     * @event rowclick
	     * Fires when a row is clicked
	     * @param {Grid} this
	     * @param {Number} rowIndex
	     * @param {Roo.EventObject} e
	     */
	    "rowclick" : true,
	    /**
	     * @event rowdblclick
	     * Fires when a row is double clicked
	     * @param {Grid} this
	     * @param {Number} rowIndex
	     * @param {Roo.EventObject} e
	     */
	    "rowdblclick" : true,
	    /**
	     * @event headerclick
	     * Fires when a header is clicked
	     * @param {Grid} this
	     * @param {Number} columnIndex
	     * @param {Roo.EventObject} e
	     */
	    "headerclick" : true,
	    /**
	     * @event headerdblclick
	     * Fires when a header cell is double clicked
	     * @param {Grid} this
	     * @param {Number} columnIndex
	     * @param {Roo.EventObject} e
	     */
	    "headerdblclick" : true,
	    /**
	     * @event rowcontextmenu
	     * Fires when a row is right clicked
	     * @param {Grid} this
	     * @param {Number} rowIndex
	     * @param {Roo.EventObject} e
	     */
	    "rowcontextmenu" : true,
	    /**
         * @event cellcontextmenu
         * Fires when a cell is right clicked
         * @param {Grid} this
         * @param {Number} rowIndex
         * @param {Number} cellIndex
         * @param {Roo.EventObject} e
         */
         "cellcontextmenu" : true,
	    /**
	     * @event headercontextmenu
	     * Fires when a header is right clicked
	     * @param {Grid} this
	     * @param {Number} columnIndex
	     * @param {Roo.EventObject} e
	     */
	    "headercontextmenu" : true,
	    /**
	     * @event bodyscroll
	     * Fires when the body element is scrolled
	     * @param {Number} scrollLeft
	     * @param {Number} scrollTop
	     */
	    "bodyscroll" : true,
	    /**
	     * @event columnresize
	     * Fires when the user resizes a column
	     * @param {Number} columnIndex
	     * @param {Number} newSize
	     */
	    "columnresize" : true,
	    /**
	     * @event columnmove
	     * Fires when the user moves a column
	     * @param {Number} oldIndex
	     * @param {Number} newIndex
	     */
	    "columnmove" : true,
	    /**
	     * @event startdrag
	     * Fires when row(s) start being dragged
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {event} e The raw browser event
	     */
	    "startdrag" : true,
	    /**
	     * @event enddrag
	     * Fires when a drag operation is complete
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {event} e The raw browser event
	     */
	    "enddrag" : true,
	    /**
	     * @event dragdrop
	     * Fires when dragged row(s) are dropped on a valid DD target
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {String} targetId The target drag drop object
	     * @param {event} e The raw browser event
	     */
	    "dragdrop" : true,
	    /**
	     * @event dragover
	     * Fires while row(s) are being dragged. "targetId" is the id of the Yahoo.util.DD object the selected rows are being dragged over.
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {String} targetId The target drag drop object
	     * @param {event} e The raw browser event
	     */
	    "dragover" : true,
	    /**
	     * @event dragenter
	     *  Fires when the dragged row(s) first cross another DD target while being dragged
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {String} targetId The target drag drop object
	     * @param {event} e The raw browser event
	     */
	    "dragenter" : true,
	    /**
	     * @event dragout
	     * Fires when the dragged row(s) leave another DD target while being dragged
	     * @param {Grid} this
	     * @param {Roo.GridDD} dd The drag drop object
	     * @param {String} targetId The target drag drop object
	     * @param {event} e The raw browser event
	     */
	    "dragout" : true,
        /**
         * @event render
         * Fires when the grid is rendered
         * @param {Grid} grid
         */
        render : true
    });

    Roo.grid.Grid.superclass.constructor.call(this);
};
Roo.extend(Roo.grid.Grid, Roo.util.Observable, {
    /**
     * @cfg {Number} minColumnWidth The minimum width a column can be resized to. Default is 25.
	 */
	minColumnWidth : 25,

    /**
	 * @cfg {Boolean} autoSizeColumns True to automatically resize the columns to fit their content
	 * <b>on initial render.</b> It is more efficient to explicitly size the columns
	 * through the ColumnModel's {@link Roo.grid.ColumnModel#width} config option.  Default is false.
	 */
	autoSizeColumns : false,

	/**
	 * @cfg {Boolean} autoSizeHeaders True to measure headers with column data when auto sizing columns. Default is true.
	 */
	autoSizeHeaders : true,

	/**
	 * @cfg {Boolean} monitorWindowResize True to autoSize the grid when the window resizes. Default is true.
	 */
	monitorWindowResize : true,

	/**
	 * @cfg {Boolean} maxRowsToMeasure If autoSizeColumns is on, maxRowsToMeasure can be used to limit the number of
	 * rows measured to get a columns size. Default is 0 (all rows).
	 */
	maxRowsToMeasure : 0,

	/**
	 * @cfg {Boolean} trackMouseOver True to highlight rows when the mouse is over. Default is true.
	 */
	trackMouseOver : true,

	/**
	 * @cfg {Boolean} enableDragDrop True to enable drag and drop of rows. Default is false.
	 */
	enableDragDrop : false,

	/**
	 * @cfg {Boolean} enableColumnMove True to enable drag and drop reorder of columns. Default is true.
	 */
	enableColumnMove : true,

	/**
	 * @cfg {Boolean} enableColumnHide True to enable hiding of columns with the header context menu. Default is true.
	 */
	enableColumnHide : true,

	/**
	 * @cfg {Boolean} enableRowHeightSync True to manually sync row heights across locked and not locked rows. Default is false.
	 */
	enableRowHeightSync : false,

	/**
	 * @cfg {Boolean} stripeRows True to stripe the rows.  Default is true.
	 */
	stripeRows : true,

	/**
	 * @cfg {Boolean} autoHeight True to fit the height of the grid container to the height of the data. Default is false.
	 */
	autoHeight : false,

    /**
     * @cfg {String} autoExpandColumn The id (or dataIndex) of a column in this grid that should expand to fill unused space. This id can not be 0. Default is false.
     */
    autoExpandColumn : false,

    /**
    * @cfg {Number} autoExpandMin The minimum width the autoExpandColumn can have (if enabled).
    * Default is 50.
    */
    autoExpandMin : 50,

    /**
    * @cfg {Number} autoExpandMax The maximum width the autoExpandColumn can have (if enabled). Default is 1000.
    */
    autoExpandMax : 1000,

    /**
	 * @cfg {Object} view The {@link Roo.grid.GridView} used by the grid. This can be set before a call to render().
	 */
	view : null,

	/**
     * @cfg {Object} loadMask An {@link Roo.LoadMask} config or true to mask the grid while loading. Default is false.
	 */
	loadMask : false,

    // private
    rendered : false,

    /**
    * @cfg {Boolean} autoWidth True to set the grid's width to the default total width of the grid's columns instead
    * of a fixed width. Default is false.
    */
    /**
    * @cfg {Number} maxHeight Sets the maximum height of the grid - ignored if autoHeight is not on.
    */
    /**
     * Called once after all setup has been completed and the grid is ready to be rendered.
     * @return {Roo.grid.Grid} this
     */
    render : function(){
        var  c = this.container;
        // try to detect autoHeight/width mode
        if((!c.dom.offsetHeight || c.dom.offsetHeight < 20) || c.getStyle("height") == "auto"){
    	    this.autoHeight = true;
    	}
    	var  C = this.getView();
        C.init(this);

        c.on("click", this.onClick, this);
        c.on("dblclick", this.onDblClick, this);
        c.on("contextmenu", this.onContextMenu, this);
        c.on("keydown", this.onKeyDown, this);

        this.relayEvents(c, ["mousedown","mouseup","mouseover","mouseout","keypress"]);

        this.getSelectionModel().init(this);

        C.render();

        if(this.loadMask){
            this.loadMask = new  Roo.LoadMask(this.container,
                    Roo.apply({store:this.dataSource}, this.loadMask));
        }
        
        
        if (this.toolbar && this.toolbar.xtype) {
            this.toolbar.container = this.getView().getHeaderPanel(true);
            this.toolbar = new  Ext.Toolbar(this.toolbar);
        }
        if (this.footer && this.footer.xtype) {
            this.footer.dataSource = this.getDataSource();
            this.footer.container = this.getView().getFooterPanel(true);
            this.footer = Roo.factory(this.footer, Roo);
        }

        this.rendered = true;
        this.fireEvent('render', this);
        return  this;
    },

	/**
	 * Reconfigures the grid to use a different Store and Column Model.
	 * The View will be bound to the new objects and refreshed.
	 * @param {Roo.data.Store} dataSource The new {@link Roo.data.Store} object
	 * @param {Roo.grid.ColumnModel} The new {@link Roo.grid.ColumnModel} object
	 */
    reconfigure : function(D, E){
        if(this.loadMask){
            this.loadMask.destroy();
            this.loadMask = new  Roo.LoadMask(this.container,
                    Roo.apply({store:D}, this.loadMask));
        }

        this.view.bind(D, E);
        this.dataSource = D;
        this.colModel = E;
        this.view.refresh(true);
    },

    // private
    onKeyDown : function(e){
        this.fireEvent("keydown", e);
    },

    /**
     * Destroy this grid.
     * @param {Boolean} removeEl True to remove the element
     */
    destroy : function(F, G){
        if(this.loadMask){
            this.loadMask.destroy();
        }
        var  c = this.container;
        c.removeAllListeners();
        this.view.destroy();
        this.colModel.purgeListeners();
        if(!G){
            this.purgeListeners();
        }

        c.update("");
        if(F === true){
            c.remove();
        }
    },

    // private
    processEvent : function(H, e){
        this.fireEvent(H, e);
        var  t = e.getTarget();
        var  v = this.view;
        var  I = v.findHeaderIndex(t);
        if(I !== false){
            this.fireEvent("header" + H, this, I, e);
        }else {
            var  row = v.findRowIndex(t);
            var  cell = v.findCellIndex(t);
            if(row !== false){
                this.fireEvent("row" + H, this, row, e);
                if(cell !== false){
                    this.fireEvent("cell" + H, this, row, cell, e);
                }
            }
        }
    },

    // private
    onClick : function(e){
        this.processEvent("click", e);
    },

    // private
    onContextMenu : function(e, t){
        this.processEvent("contextmenu", e);
    },

    // private
    onDblClick : function(e){
        this.processEvent("dblclick", e);
    },

    // private
    walkCells : function(J, K, L, fn, M){
        var  cm = this.colModel, N = cm.getColumnCount();
        var  ds = this.dataSource, O = ds.getCount(), P = true;
        if(L < 0){
            if(K < 0){
                J--;
                P = false;
            }
            while(J >= 0){
                if(!P){
                    K = N-1;
                }

                P = false;
                while(K >= 0){
                    if(fn.call(M || this, J, K, cm) === true){
                        return  [J, K];
                    }

                    K--;
                }

                J--;
            }
        } else  {
            if(K >= N){
                J++;
                P = false;
            }
            while(J < O){
                if(!P){
                    K = 0;
                }

                P = false;
                while(K < N){
                    if(fn.call(M || this, J, K, cm) === true){
                        return  [J, K];
                    }

                    K++;
                }

                J++;
            }
        }
        return  null;
    },

    // private
    getSelections : function(){
        return  this.selModel.getSelections();
    },

    /**
     * Causes the grid to manually recalculate its dimensions. Generally this is done automatically,
     * but if manual update is required this method will initiate it.
     */
    autoSize : function(){
        if(this.rendered){
            this.view.layout();
            if(this.view.adjustForScroll){
                this.view.adjustForScroll();
            }
        }
    },

    /**
     * Returns the grid's underlying element.
     * @return {Element} The element
     */
    getGridEl : function(){
        return  this.container;
    },

    // private for compatibility, overridden by editor grid
    stopEditing : function(){},

    /**
     * Returns the grid's SelectionModel.
     * @return {SelectionModel}
     */
    getSelectionModel : function(){
        if(!this.selModel){
            this.selModel = new  Roo.grid.RowSelectionModel();
        }
        return  this.selModel;
    },

    /**
     * Returns the grid's DataSource.
     * @return {DataSource}
     */
    getDataSource : function(){
        return  this.dataSource;
    },

    /**
     * Returns the grid's ColumnModel.
     * @return {ColumnModel}
     */
    getColumnModel : function(){
        return  this.colModel;
    },

    /**
     * Returns the grid's GridView object.
     * @return {GridView}
     */
    getView : function(){
        if(!this.view){
            this.view = new  Roo.grid.GridView(this.viewConfig);
        }
        return  this.view;
    },
    /**
     * Called to get grid's drag proxy text, by default returns this.ddText.
     * @return {String}
     */
    getDragDropText : function(){
        var  Q = this.selModel.getCount();
        return  String.format(this.ddText, Q, Q == 1 ? '' : 's');
    }
});
/**
 * Configures the text is the drag proxy (defaults to "%0 selected row(s)").
 * %0 is replaced with the number of selected rows.
 * @type String
 */
Roo.grid.Grid.prototype.ddText = "{0} selected row{1}";
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
Roo.grid.AbstractGridView = function(){
	this.grid = null;
	
	this.events = {
	    "beforerowremoved" : true,
	    "beforerowsinserted" : true,
	    "beforerefresh" : true,
	    "rowremoved" : true,
	    "rowsinserted" : true,
	    "rowupdated" : true,
	    "refresh" : true
	};
    Roo.grid.AbstractGridView.superclass.constructor.call(this);
};

Roo.extend(Roo.grid.AbstractGridView, Roo.util.Observable, {
    rowClass : "x-grid-row",
    cellClass : "x-grid-cell",
    tdClass : "x-grid-td",
    hdClass : "x-grid-hd",
    splitClass : "x-grid-hd-split",
    
	init: function(A){
        this.grid = A;
		var  B = this.grid.getGridEl().id;
        this.colSelector = "#" + B + " ." + this.cellClass + "-";
        this.tdSelector = "#" + B + " ." + this.tdClass + "-";
        this.hdSelector = "#" + B + " ." + this.hdClass + "-";
        this.splitSelector = "#" + B + " ." + this.splitClass + "-";
	},
	
	getColumnRenderers : function(){
    	var  C = [];
    	var  cm = this.grid.colModel;
        var  D = cm.getColumnCount();
        for(var  i = 0; i < D; i++){
            C[i] = cm.getRenderer(i);
        }
        return  C;
    },
    
    getColumnIds : function(){
    	var  E = [];
    	var  cm = this.grid.colModel;
        var  F = cm.getColumnCount();
        for(var  i = 0; i < F; i++){
            E[i] = cm.getColumnId(i);
        }
        return  E;
    },
    
    getDataIndexes : function(){
    	if(!this.indexMap){
            this.indexMap = this.buildIndexMap();
        }
        return  this.indexMap.colToData;
    },
    
    getColumnIndexByDataIndex : function(G){
        if(!this.indexMap){
            this.indexMap = this.buildIndexMap();
        }
    	return  this.indexMap.dataToCol[G];
    },
    
    /**
     * Set a css style for a column dynamically. 
     * @param {Number} colIndex The index of the column
     * @param {String} name The css property name
     * @param {String} value The css value
     */
    setCSSStyle : function(H, I, J){
        var  K = "#" + this.grid.id + " .x-grid-col-" + H;
        Roo.util.CSS.updateRule(K, I, J);
    },
    
    generateRules : function(cm){
        var  L = [], M = this.grid.id + '-cssrules';
        Roo.util.CSS.removeStyleSheet(M);
        for(var  i = 0, len = cm.getColumnCount(); i < len; i++){
            var  B = cm.getColumnId(i);
            L.push(this.colSelector, B, " {\n", cm.config[i].css, "}\n",
                         this.tdSelector, B, " {\n}\n",
                         this.hdSelector, B, " {\n}\n",
                         this.splitSelector, B, " {\n}\n");
        }
        return  Roo.util.CSS.createStyleSheet(L.join(""), M);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

// private
// This is a support class used internally by the Grid components
Roo.grid.HeaderDragZone = function(A, hd, B){
    this.grid = A;
    this.view = A.getView();
    this.ddGroup = "gridHeader" + this.grid.getGridEl().id;
    Roo.grid.HeaderDragZone.superclass.constructor.call(this, hd);
    if(B){
        this.setHandleElId(Roo.id(hd));
        this.setOuterHandleElId(Roo.id(B));
    }

    this.scroll = false;
};
Roo.extend(Roo.grid.HeaderDragZone, Roo.dd.DragZone, {
    maxDragWidth: 120,
    getDragData : function(e){
        var  t = Roo.lib.Event.getTarget(e);
        var  h = this.view.findHeaderCell(t);
        if(h){
            return  {ddel: h.firstChild, header:h};
        }
        return  false;
    },

    onInitDrag : function(e){
        this.view.headersDisabled = true;
        var  C = this.dragData.ddel.cloneNode(true);
        C.id = Roo.id();
        C.style.width = Math.min(this.dragData.header.offsetWidth,this.maxDragWidth) + "px";
        this.proxy.update(C);
        return  true;
    },

    afterValidDrop : function(){
        var  v = this.view;
        setTimeout(function(){
            v.headersDisabled = false;
        }, 50);
    },

    afterInvalidDrop : function(){
        var  v = this.view;
        setTimeout(function(){
            v.headersDisabled = false;
        }, 50);
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
// private
// This is a support class used internally by the Grid components
Roo.grid.HeaderDropZone = function(A, hd, B){
    this.grid = A;
    this.view = A.getView();
    // split the proxies so they don't interfere with mouse events
    this.proxyTop = Roo.DomHelper.append(document.body, {
        cls:"col-move-top", html:"&#160;"
    }, true);
    this.proxyBottom = Roo.DomHelper.append(document.body, {
        cls:"col-move-bottom", html:"&#160;"
    }, true);
    this.proxyTop.hide = this.proxyBottom.hide = function(){
        this.setLeftTop(-100,-100);
        this.setStyle("visibility", "hidden");
    };
    this.ddGroup = "gridHeader" + this.grid.getGridEl().id;
    // temporarily disabled
    //Roo.dd.ScrollManager.register(this.view.scroller.dom);
    Roo.grid.HeaderDropZone.superclass.constructor.call(this, A.getGridEl().dom);
};
Roo.extend(Roo.grid.HeaderDropZone, Roo.dd.DropZone, {
    proxyOffsets : [-4, -9],
    fly: Roo.Element.fly,

    getTargetFromEvent : function(e){
        var  t = Roo.lib.Event.getTarget(e);
        var  C = this.view.findCellIndex(t);
        if(C !== false){
            return  this.view.getHeaderCell(C);
        }
    },

    nextVisible : function(h){
        var  v = this.view, cm = this.grid.colModel;
        h = h.nextSibling;
        while(h){
            if(!cm.isHidden(v.getCellIndex(h))){
                return  h;
            }

            h = h.nextSibling;
        }
        return  null;
    },

    prevVisible : function(h){
        var  v = this.view, cm = this.grid.colModel;
        h = h.prevSibling;
        while(h){
            if(!cm.isHidden(v.getCellIndex(h))){
                return  h;
            }

            h = h.prevSibling;
        }
        return  null;
    },

    positionIndicator : function(h, n, e){
        var  x = Roo.lib.Event.getPageX(e);
        var  r = Roo.lib.Dom.getRegion(n.firstChild);
        var  px, pt, py = r.top + this.proxyOffsets[1];
        if((r.right - x) <= (r.right-r.left)/2){
            px = r.right+this.view.borderWidth;
            pt = "after";
        }else {
            px = r.left;
            pt = "before";
        }
        var  D = this.view.getCellIndex(h);
        var  E = this.view.getCellIndex(n);

        if(this.grid.colModel.isFixed(E)){
            return  false;
        }

        var  F = this.grid.colModel.isLocked(E);

        if(pt == "after"){
            E++;
        }
        if(D < E){
            E--;
        }
        if(D == E && (F == this.grid.colModel.isLocked(D))){
            return  false;
        }

        px +=  this.proxyOffsets[0];
        this.proxyTop.setLeftTop(px, py);
        this.proxyTop.show();
        if(!this.bottomOffset){
            this.bottomOffset = this.view.mainHd.getHeight();
        }

        this.proxyBottom.setLeftTop(px, py+this.proxyTop.dom.offsetHeight+this.bottomOffset);
        this.proxyBottom.show();
        return  pt;
    },

    onNodeEnter : function(n, dd, e, G){
        if(G.header != n){
            this.positionIndicator(G.header, n, e);
        }
    },

    onNodeOver : function(n, dd, e, H){
        var  I = false;
        if(H.header != n){
            I = this.positionIndicator(H.header, n, e);
        }
        if(!I){
            this.proxyTop.hide();
            this.proxyBottom.hide();
        }
        return  I ? this.dropAllowed : this.dropNotAllowed;
    },

    onNodeOut : function(n, dd, e, J){
        this.proxyTop.hide();
        this.proxyBottom.hide();
    },

    onNodeDrop : function(n, dd, e, K){
        var  h = K.header;
        if(h != n){
            var  cm = this.grid.colModel;
            var  x = Roo.lib.Event.getPageX(e);
            var  r = Roo.lib.Dom.getRegion(n.firstChild);
            var  pt = (r.right - x) <= ((r.right-r.left)/2) ? "after" : "before";
            var  D = this.view.getCellIndex(h);
            var  E = this.view.getCellIndex(n);
            var  F = cm.isLocked(E);
            if(pt == "after"){
                E++;
            }
            if(D < E){
                E--;
            }
            if(D == E && (F == cm.isLocked(D))){
                return  false;
            }

            cm.setLocked(D, F, true);
            cm.moveColumn(D, E);
            this.grid.fireEvent("columnmove", D, E);
            return  true;
        }
        return  false;
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
  
/**
 * @class Roo.grid.GridView
 * @extends Roo.util.Observable
 *
 * @constructor
 * @param {Object} config
 */
Roo.grid.GridView = function(A){
    Roo.grid.GridView.superclass.constructor.call(this);
    this.el = null;

    Roo.apply(this, A);
};

Roo.extend(Roo.grid.GridView, Roo.grid.AbstractGridView, {

    /**
     * Override this function to apply custom css classes to rows during rendering
     * @param {Record} record The record
     * @param {Number} index
     * @method getRowClass
     */
    rowClass : "x-grid-row",

    cellClass : "x-grid-col",

    tdClass : "x-grid-td",

    hdClass : "x-grid-hd",

    splitClass : "x-grid-split",

    sortClasses : ["sort-asc", "sort-desc"],

    enableMoveAnim : false,

    hlColor: "C3DAF9",

    dh : Roo.DomHelper,

    fly : Roo.Element.fly,

    css : Roo.util.CSS,

    borderWidth: 1,

    splitOffset: 3,

    scrollIncrement : 22,

    cellRE: /(?:.*?)x-grid-(?:hd|cell|csplit)-(?:[\d]+)-([\d]+)(?:.*?)/,

    findRE: /\s?(?:x-grid-hd|x-grid-col|x-grid-csplit)\s/,

    bind : function(ds, cm){
        if(this.ds){
            this.ds.un("load", this.onLoad, this);
            this.ds.un("datachanged", this.onDataChange, this);
            this.ds.un("add", this.onAdd, this);
            this.ds.un("remove", this.onRemove, this);
            this.ds.un("update", this.onUpdate, this);
            this.ds.un("clear", this.onClear, this);
        }
        if(ds){
            ds.on("load", this.onLoad, this);
            ds.on("datachanged", this.onDataChange, this);
            ds.on("add", this.onAdd, this);
            ds.on("remove", this.onRemove, this);
            ds.on("update", this.onUpdate, this);
            ds.on("clear", this.onClear, this);
        }

        this.ds = ds;

        if(this.cm){
            this.cm.un("widthchange", this.onColWidthChange, this);
            this.cm.un("headerchange", this.onHeaderChange, this);
            this.cm.un("hiddenchange", this.onHiddenChange, this);
            this.cm.un("columnmoved", this.onColumnMove, this);
            this.cm.un("columnlockchange", this.onColumnLock, this);
        }
        if(cm){
            this.generateRules(cm);
            cm.on("widthchange", this.onColWidthChange, this);
            cm.on("headerchange", this.onHeaderChange, this);
            cm.on("hiddenchange", this.onHiddenChange, this);
            cm.on("columnmoved", this.onColumnMove, this);
            cm.on("columnlockchange", this.onColumnLock, this);
        }

        this.cm = cm;
    },

    init: function(B){
		Roo.grid.GridView.superclass.init.call(this, B);

		this.bind(B.dataSource, B.colModel);

	    B.on("headerclick", this.handleHeaderClick, this);

        if(B.trackMouseOver){
            B.on("mouseover", this.onRowOver, this);
	        B.on("mouseout", this.onRowOut, this);
	    }

	    B.cancelTextSelection = function(){};
		this.gridId = B.id;

		var  C = this.templates || {};

		if(!C.master){
		    C.master = new  Roo.Template(
		       '<div class="x-grid" hidefocus="true">',
		          '<div class="x-grid-topbar"></div>',
		          '<div class="x-grid-scroller"><div></div></div>',
		          '<div class="x-grid-locked">',
		              '<div class="x-grid-header">{lockedHeader}</div>',
		              '<div class="x-grid-body">{lockedBody}</div>',
		          "</div>",
		          '<div class="x-grid-viewport">',
		              '<div class="x-grid-header">{header}</div>',
		              '<div class="x-grid-body">{body}</div>',
		          "</div>",
		          '<div class="x-grid-bottombar"></div>',
		          '<a href="#" class="x-grid-focus" tabIndex="-1"></a>',
		          '<div class="x-grid-resize-proxy">&#160;</div>',
		       "</div>"
		    );
		    C.master.disableformats = true;
		}

		if(!C.header){
		    C.header = new  Roo.Template(
		       '<table border="0" cellspacing="0" cellpadding="0">',
		       '<tbody><tr class="x-grid-hd-row">{cells}</tr></tbody>',
		       "</table>{splits}"
		    );
		    C.header.disableformats = true;
		}

		C.header.compile();

		if(!C.hcell){
		    C.hcell = new  Roo.Template(
		        '<td class="x-grid-hd x-grid-td-{id} {cellId}"><div title="{title}" class="x-grid-hd-inner x-grid-hd-{id}">',
		        '<div class="x-grid-hd-text" unselectable="on">{value}<img class="x-grid-sort-icon" src="', Roo.BLANK_IMAGE_URL, '" /></div>',
		        "</div></td>"
		     );
		     C.hcell.disableFormats = true;
		}

		C.hcell.compile();

		if(!C.hsplit){
		    C.hsplit = new  Roo.Template('<div class="x-grid-split {splitId} x-grid-split-{id}" style="{style}" unselectable="on">&#160;</div>');
		    C.hsplit.disableFormats = true;
		}

		C.hsplit.compile();

		if(!C.body){
		    C.body = new  Roo.Template(
		       '<table border="0" cellspacing="0" cellpadding="0">',
		       "<tbody>{rows}</tbody>",
		       "</table>"
		    );
		    C.body.disableFormats = true;
		}

		C.body.compile();

		if(!C.row){
		    C.row = new  Roo.Template('<tr class="x-grid-row {alt}">{cells}</tr>');
		    C.row.disableFormats = true;
		}

		C.row.compile();

		if(!C.cell){
		    C.cell = new  Roo.Template(
		        '<td class="x-grid-col x-grid-td-{id} {cellId} {css}" tabIndex="0">',
		        '<div class="x-grid-col-{id} x-grid-cell-inner"><div class="x-grid-cell-text" unselectable="on" {attr}>{value}</div></div>',
		        "</td>"
		    );
            C.cell.disableFormats = true;
        }

		C.cell.compile();

		this.templates = C;
	},

	// remap these for backwards compat
    onColWidthChange : function(){
        this.updateColumns.apply(this, arguments);
    },
    onHeaderChange : function(){
        this.updateHeaders.apply(this, arguments);
    }, 
    onHiddenChange : function(){
        this.handleHiddenChange.apply(this, arguments);
    },
    onColumnMove : function(){
        this.handleColumnMove.apply(this, arguments);
    },
    onColumnLock : function(){
        this.handleLockChange.apply(this, arguments);
    },

    onDataChange : function(){
        this.refresh();
        this.updateHeaderSortState();
    },

	onClear : function(){
        this.refresh();
    },

	onUpdate : function(ds, D){
        this.refreshRow(D);
    },

    refreshRow : function(E){
        var  ds = this.ds, F;
        if(typeof  E == 'number'){
            F = E;
            E = ds.getAt(F);
        }else {
            F = ds.indexOf(E);
        }

        this.insertRows(ds, F, F, true);
        this.onRemove(ds, E, F+1, true);
        this.syncRowHeights(F, F);
        this.layout();
        this.fireEvent("rowupdated", this, F, E);
    },

    onAdd : function(ds, G, H){
        this.insertRows(ds, H, H + (G.length-1));
    },

    onRemove : function(ds, I, J, K){
        if(K !== true){
            this.fireEvent("beforerowremoved", this, J, I);
        }
        var  bt = this.getBodyTable(), lt = this.getLockedTable();
        if(bt.rows[J]){
            bt.firstChild.removeChild(bt.rows[J]);
        }
        if(lt.rows[J]){
            lt.firstChild.removeChild(lt.rows[J]);
        }
        if(K !== true){
            this.stripeRows(J);
            this.syncRowHeights(J, J);
            this.layout();
            this.fireEvent("rowremoved", this, J, I);
        }
    },

    onLoad : function(){
        this.scrollToTop();
    },

    /**
     * Scrolls the grid to the top
     */
    scrollToTop : function(){
        if(this.scroller){
            this.scroller.dom.scrollTop = 0;
            this.syncScroll();
        }
    },

    /**
     * Gets a panel in the header of the grid that can be used for toolbars etc.
     * After modifying the contents of this panel a call to grid.autoSize() may be
     * required to register any changes in size.
     * @param {Boolean} doShow By default the header is hidden. Pass true to show the panel
     * @return Roo.Element
     */
    getHeaderPanel : function(L){
        if(L){
            this.headerPanel.show();
        }
        return  this.headerPanel;
	},

	/**
     * Gets a panel in the footer of the grid that can be used for toolbars etc.
     * After modifying the contents of this panel a call to grid.autoSize() may be
     * required to register any changes in size.
     * @param {Boolean} doShow By default the footer is hidden. Pass true to show the panel
     * @return Roo.Element
     */
    getFooterPanel : function(M){
        if(M){
            this.footerPanel.show();
        }
        return  this.footerPanel;
	},

	initElements : function(){
	    var  E = Roo.Element;
	    var  el = this.grid.getGridEl().dom.firstChild;
	    var  cs = el.childNodes;

	    this.el = new  E(el);
	    this.headerPanel = new  E(el.firstChild);
	    this.headerPanel.enableDisplayMode("block");

        this.scroller = new  E(cs[1]);
	    this.scrollSizer = new  E(this.scroller.dom.firstChild);

	    this.lockedWrap = new  E(cs[2]);
	    this.lockedHd = new  E(this.lockedWrap.dom.firstChild);
	    this.lockedBody = new  E(this.lockedWrap.dom.childNodes[1]);

	    this.mainWrap = new  E(cs[3]);
	    this.mainHd = new  E(this.mainWrap.dom.firstChild);
	    this.mainBody = new  E(this.mainWrap.dom.childNodes[1]);

	    this.footerPanel = new  E(cs[4]);
	    this.footerPanel.enableDisplayMode("block");

        this.focusEl = new  E(cs[5]);
        this.focusEl.swallowEvent("click", true);
        this.resizeProxy = new  E(cs[6]);

	    this.headerSelector = String.format(
	       '#{0} td.x-grid-hd, #{1} td.x-grid-hd',
	       this.lockedHd.id, this.mainHd.id
	    );

	    this.splitterSelector = String.format(
	       '#{0} div.x-grid-split, #{1} div.x-grid-split',
	       this.idToCssName(this.lockedHd.id), this.idToCssName(this.mainHd.id)
	    );
    },
    idToCssName : function(s)
    {
        return  s.replace(/[^a-z0-9]+/ig, '-');
    },

	getHeaderCell : function(N){
	    return  Roo.DomQuery.select(this.headerSelector)[N];
	},

	getHeaderCellMeasure : function(O){
	    return  this.getHeaderCell(O).firstChild;
	},

	getHeaderCellText : function(P){
	    return  this.getHeaderCell(P).firstChild.firstChild;
	},

	getLockedTable : function(){
	    return  this.lockedBody.dom.firstChild;
	},

	getBodyTable : function(){
	    return  this.mainBody.dom.firstChild;
	},

	getLockedRow : function(Q){
	    return  this.getLockedTable().rows[Q];
	},

	getRow : function(R){
	    return  this.getBodyTable().rows[R];
	},

	getRowComposite : function(S){
	    if(!this.rowEl){
	        this.rowEl = new  Roo.CompositeElementLite();
	    }
        var  T = [], U, V;
        if(U = this.getLockedRow(S)){
            T.push(U);
        }
        if(V = this.getRow(S)){
            T.push(V);
        }

        this.rowEl.elements = T;
	    return  this.rowEl;
	},

	getCell : function(W, X){
	    var  Y = this.cm.getLockedCount();
	    var  Z;
	    if(X < Y){
	        Z = this.lockedBody.dom.firstChild;
	    }else {
	        Z = this.mainBody.dom.firstChild;
	        X -= Y;
	    }
        return  Z.rows[W].childNodes[X];
	},

	getCellText : function(a, b){
	    return  this.getCell(a, b).firstChild.firstChild;
	},

	getCellBox : function(c){
	    var  b = this.fly(c).getBox();
        if(Roo.isOpera){ // opera fails to report the Y
            b.y = c.offsetTop + this.mainBody.getY();
        }
        return  b;
    },

    getCellIndex : function(d){
        var  id = String(d.className).match(this.cellRE);
        if(id){
            return  parseInt(id[1], 10);
        }
        return  0;
    },

    findHeaderIndex : function(n){
        var  r = Roo.fly(n).findParent("td." + this.hdClass, 6);
        return  r ? this.getCellIndex(r) : false;
    },

    findHeaderCell : function(n){
        var  r = Roo.fly(n).findParent("td." + this.hdClass, 6);
        return  r ? r : false;
    },

    findRowIndex : function(n){
        if(!n){
            return  false;
        }
        var  r = Roo.fly(n).findParent("tr." + this.rowClass, 6);
        return  r ? r.rowIndex : false;
    },

    findCellIndex : function(e){
        var  f = this.el.dom;
        while(e && e != f){
            if(this.findRE.test(e.className)){
                return  this.getCellIndex(e);
            }

            e = e.parentNode;
        }
        return  false;
    },

    getColumnId : function(g){
	    return  this.cm.getColumnId(g);
	},

	getSplitters : function(){
	    if(this.splitterSelector){
	       return  Roo.DomQuery.select(this.splitterSelector);
	    }else {
	        return  null;
	    }
	},

	getSplitter : function(k){
	    return  this.getSplitters()[k];
	},

    onRowOver : function(e, t){
        var  o;
        if((o = this.findRowIndex(t)) !== false){
            this.getRowComposite(o).addClass("x-grid-row-over");
        }
    },

    onRowOut : function(e, t){
        var  p;
        if((p = this.findRowIndex(t)) !== false && p !== this.findRowIndex(e.getRelatedTarget())){
            this.getRowComposite(p).removeClass("x-grid-row-over");
        }
    },

    renderHeaders : function(){
	    var  cm = this.cm;
        var  ct = this.templates.hcell, ht = this.templates.header, st = this.templates.hsplit;
        var  cb = [], lb = [], sb = [], q = [], p = {};
        for(var  i = 0, len = cm.getColumnCount(); i < len; i++){
            p.cellId = "x-grid-hd-0-" + i;
            p.splitId = "x-grid-csplit-0-" + i;
            p.id = cm.getColumnId(i);
            p.title = cm.getColumnTooltip(i) || "";
            p.value = cm.getColumnHeader(i) || "";
            p.style = (this.grid.enableColumnResize === false || !cm.isResizable(i) || cm.isFixed(i)) ? 'cursor:default' : '';
            if(!cm.isLocked(i)){
                cb[cb.length] = ct.apply(p);
                sb[sb.length] = st.apply(p);
            }else {
                lb[lb.length] = ct.apply(p);
                q[q.length] = st.apply(p);
            }
        }
        return  [ht.apply({cells: lb.join(""), splits:q.join("")}),
                ht.apply({cells: cb.join(""), splits:sb.join("")})];
	},

	updateHeaders : function(){
        var  u = this.renderHeaders();
        this.lockedHd.update(u[0]);
        this.mainHd.update(u[1]);
    },

    /**
     * Focuses the specified row.
     * @param {Number} row The row index
     */
    focusRow : function(v){
        var  x = this.scroller.dom.scrollLeft;
        this.focusCell(v, 0, false);
        this.scroller.dom.scrollLeft = x;
    },

    /**
     * Focuses the specified cell.
     * @param {Number} row The row index
     * @param {Number} col The column index
     * @param {Boolean} hscroll false to disable horizontal scrolling
     */
    focusCell : function(y, z, AA){
        var  el = this.ensureVisible(y, z, AA);
        this.focusEl.alignTo(el, "tl-tl");
        if(Roo.isGecko){
            this.focusEl.focus();
        }else {
            this.focusEl.focus.defer(1, this.focusEl);
        }
    },

    /**
     * Scrolls the specified cell into view
     * @param {Number} row The row index
     * @param {Number} col The column index
     * @param {Boolean} hscroll false to disable horizontal scrolling
     */
    ensureVisible : function(AB, AC, AD){
        if(typeof  AB != "number"){
            AB = AB.rowIndex;
        }
        if(AB < 0 && AB >= this.ds.getCount()){
            return;
        }

        AC = (AC !== undefined ? AC : 0);
        var  cm = this.grid.colModel;
        while(cm.isHidden(AC)){
            AC++;
        }

        var  el = this.getCell(AB, AC);
        if(!el){
            return;
        }
        var  c = this.scroller.dom;

        var  AE = parseInt(el.offsetTop, 10);
        var  AF = parseInt(el.offsetLeft, 10);
        var  AG = AE + el.offsetHeight;
        var  AH = AF + el.offsetWidth;

        var  ch = c.clientHeight - this.mainHd.dom.offsetHeight;
        var  AI = parseInt(c.scrollTop, 10);
        var  AJ = parseInt(c.scrollLeft, 10);
        var  AK = AI + ch;
        var  AL = AJ + c.clientWidth;

        if(AE < AI){
        	c.scrollTop = AE;
        }else  if(AG > AK){
            c.scrollTop = AG-ch;
        }

        if(AD !== false){
            if(AF < AJ){
                c.scrollLeft = AF;
            }else  if(AH > AL){
                c.scrollLeft = AH-c.clientWidth;
            }
        }
        return  el;
    },

    updateColumns : function(){
        this.grid.stopEditing();
        var  cm = this.grid.colModel, AM = this.getColumnIds();
        //var totalWidth = cm.getTotalWidth();
        var  AN = 0;
        for(var  i = 0, len = cm.getColumnCount(); i < len; i++){
            //if(cm.isHidden(i)) continue;
            var  w = cm.getColumnWidth(i);
            this.css.updateRule(this.colSelector+this.idToCssName(AM[i]), "width", (w - this.borderWidth) + "px");
            this.css.updateRule(this.hdSelector+this.idToCssName(AM[i]), "width", (w - this.borderWidth) + "px");
        }

        this.updateSplitters();
    },

    generateRules : function(cm){
        var  AO = [], AP = this.idToCssName(this.grid.id)+ '-cssrules';
        Roo.util.CSS.removeStyleSheet(AP);
        for(var  i = 0, len = cm.getColumnCount(); i < len; i++){
            var  cid = cm.getColumnId(i);
            var  align = '';
            if(cm.config[i].align){
                align = 'text-align:'+cm.config[i].align+';';
            }
            var  hidden = '';
            if(cm.isHidden(i)){
                hidden = 'display:none;';
            }
            var  width = "width:" + (cm.getColumnWidth(i) - this.borderWidth) + "px;";
            AO.push(
                    this.colSelector, cid, " {\n", cm.config[i].css, align, width, "\n}\n",
                    this.hdSelector, cid, " {\n", align, width, "}\n",
                    this.tdSelector, cid, " {\n",hidden,"\n}\n",
                    this.splitSelector, cid, " {\n", hidden , "\n}\n");
        }
        return  Roo.util.CSS.createStyleSheet(AO.join(""), AP);
    },

    updateSplitters : function(){
        var  cm = this.cm, s = this.getSplitters();
        if(s){ // splitters not created yet
            var  AN = 0, Y = true;
            for(var  i = 0, len = cm.getColumnCount(); i < len; i++){
                if(cm.isHidden(i)) continue;
                var  w = cm.getColumnWidth(i);
                if(!cm.isLocked(i) && Y){
                    AN = 0;
                    Y = false;
                }

                AN += w;
                s[i].style.left = (AN-this.splitOffset) + "px";
            }
        }
    },

    handleHiddenChange : function(AQ, AR, AS){
        if(AS){
            this.hideColumn(AR);
        }else {
            this.unhideColumn(AR);
        }
    },

    hideColumn : function(AT){
        var  AU = this.getColumnId(AT);
        this.css.updateRule(this.tdSelector+this.idToCssName(AU), "display", "none");
        this.css.updateRule(this.splitSelector+this.idToCssName(AU), "display", "none");
        if(Roo.isSafari){
            this.updateHeaders();
        }

        this.updateSplitters();
        this.layout();
    },

    unhideColumn : function(AV){
        var  AW = this.getColumnId(AV);
        this.css.updateRule(this.tdSelector+this.idToCssName(AW), "display", "");
        this.css.updateRule(this.splitSelector+this.idToCssName(AW), "display", "");

        if(Roo.isSafari){
            this.updateHeaders();
        }

        this.updateSplitters();
        this.layout();
    },

    insertRows : function(dm, AX, AY, AZ){
        if(AX == 0 && AY == dm.getCount()-1){
            this.refresh();
        }else {
            if(!AZ){
                this.fireEvent("beforerowsinserted", this, AX, AY);
            }
            var  s = this.getScrollState();
            var  markup = this.renderRows(AX, AY);
            this.bufferRows(markup[0], this.getLockedTable(), AX);
            this.bufferRows(markup[1], this.getBodyTable(), AX);
            this.restoreScroll(s);
            if(!AZ){
                this.fireEvent("rowsinserted", this, AX, AY);
                this.syncRowHeights(AX, AY);
                this.stripeRows(AX);
                this.layout();
            }
        }
    },

    bufferRows : function(Aa, Ab, Ac){
        var  Ad = null, Ae = Ab.rows, Af = Ab.tBodies[0];
        if(Ac < Ae.length){
            Ad = Ae[Ac];
        }
        var  b = document.createElement("div");
        b.innerHTML = "<table><tbody>"+Aa+"</tbody></table>";
        var  Ag = b.firstChild.rows;
        for(var  i = 0, len = Ag.length; i < len; i++){
            if(Ad){
                Af.insertBefore(Ag[0], Ad);
            }else {
                Af.appendChild(Ag[0]);
            }
        }

        b.innerHTML = "";
        b = null;
    },

    deleteRows : function(dm, Ah, Ai){
        if(dm.getRowCount()<1){
            this.fireEvent("beforerefresh", this);
            this.mainBody.update("");
            this.lockedBody.update("");
            this.fireEvent("refresh", this);
        }else {
            this.fireEvent("beforerowsdeleted", this, Ah, Ai);
            var  bt = this.getBodyTable();
            var  Af = bt.firstChild;
            var  Ag = bt.rows;
            for(var  a = Ah; a <= Ai; a++){
                Af.removeChild(Ag[Ah]);
            }

            this.stripeRows(Ah);
            this.fireEvent("rowsdeleted", this, Ah, Ai);
        }
    },

    updateRows : function(Aj, Ak, Al){
        var  s = this.getScrollState();
        this.refresh();
        this.restoreScroll(s);
    },

    handleSort : function(Am, An, Ao, Ap){
        if(!Ap){
           this.refresh();
        }

        this.updateHeaderSortState();
    },

    getScrollState : function(){
        var  sb = this.scroller.dom;
        return  {left: sb.scrollLeft, top: sb.scrollTop};
    },

    stripeRows : function(Aq){
        if(!this.grid.stripeRows || this.ds.getCount() < 1){
            return;
        }

        Aq = Aq || 0;
        var  Ar = this.getBodyTable().rows;
        var  As = this.getLockedTable().rows;
        var  At = ' x-grid-row-alt ';
        for(var  i = Aq, len = Ar.length; i < len; i++){
            var  AB = Ar[i], U = As[i];
            var  isAlt = ((i+1) % 2 == 0);
            var  hasAlt = (' '+AB.className + ' ').indexOf(At) != -1;
            if(isAlt == hasAlt){
                continue;
            }
            if(isAlt){
                AB.className += " x-grid-row-alt";
            }else {
                AB.className = AB.className.replace("x-grid-row-alt", "");
            }
            if(U){
                U.className = AB.className;
            }
        }
    },

    restoreScroll : function(Au){
        var  sb = this.scroller.dom;
        sb.scrollLeft = Au.left;
        sb.scrollTop = Au.top;
        this.syncScroll();
    },

    syncScroll : function(){
        var  sb = this.scroller.dom;
        var  sh = this.mainHd.dom;
        var  bs = this.mainBody.dom;
        var  lv = this.lockedBody.dom;
        sh.scrollLeft = bs.scrollLeft = sb.scrollLeft;
        lv.scrollTop = bs.scrollTop = sb.scrollTop;
    },

    handleScroll : function(e){
        this.syncScroll();
        var  sb = this.scroller.dom;
        this.grid.fireEvent("bodyscroll", sb.scrollLeft, sb.scrollTop);
        e.stopEvent();
    },

    handleWheel : function(e){
        var  d = e.getWheelDelta();
        this.scroller.dom.scrollTop -= d*22;
        // set this here to prevent jumpy scrolling on large tables
        this.lockedBody.dom.scrollTop = this.mainBody.dom.scrollTop = this.scroller.dom.scrollTop;
        e.stopEvent();
    },

    renderRows : function(Av, Aw){
        // pull in all the crap needed to render rows
        var  g = this.grid, cm = g.colModel, ds = g.dataSource, Ax = g.stripeRows;
        var  Ay = cm.getColumnCount();

        if(ds.getCount() < 1){
            return  ["", ""];
        }

        // build a map for all the columns
        var  cs = [];
        for(var  i = 0; i < Ay; i++){
            var  name = cm.getDataIndex(i);
            cs[i] = {
                name : typeof  name == 'undefined' ? ds.fields.get(i).name : name,
                renderer : cm.getRenderer(i),
                id : cm.getColumnId(i),
                locked : cm.isLocked(i)
            };
        }


        Av = Av || 0;
        Aw = typeof  Aw == "undefined"? ds.getCount()-1 : Aw;

        // records to render
        var  rs = ds.getRange(Av, Aw);

        return  this.doRender(cs, rs, ds, Av, Ay, Ax);
    },

    // As much as I hate to duplicate code, this was branched because FireFox really hates
    // [].join("") on strings. The performance difference was substantial enough to
    // branch this function
    doRender : Roo.isGecko ?
            function(cs, rs, ds, Az, A0, A1){
                var  ts = this.templates, ct = ts.cell, rt = ts.row;
                // buffers
                var  A2 = "", A3 = "", cb, A4, c, p = {}, rp = {}, r, a;
                for(var  j = 0, len = rs.length; j < len; j++){
                    r = rs[j]; cb = ""; A4 = ""; a = (j+Az);
                    for(var  i = 0; i < A0; i++){
                        c = cs[i];
                        p.cellId = "x-grid-cell-" + a + "-" + i;
                        p.id = c.id;
                        p.css = p.attr = "";
                        p.value = c.renderer(r.data[c.name], p, r, a, i, ds);
                        if(p.value == undefined || p.value === "") p.value = "&#160;";
                        if(r.dirty && typeof  r.modified[c.name] !== 'undefined'){
                            p.css += p.css ? ' x-grid-dirty-cell' : 'x-grid-dirty-cell';
                        }
                        var  Aa = ct.apply(p);
                        if(!c.locked){
                            cb+= Aa;
                        }else {
                            A4+= Aa;
                        }
                    }
                    var  alt = [];
                    if(A1 && ((a+1) % 2 == 0)){
                        alt[0] = "x-grid-row-alt";
                    }
                    if(r.dirty){
                        alt[1] = " x-grid-dirty-row";
                    }

                    rp.cells = A4;
                    if(this.getRowClass){
                        alt[2] = this.getRowClass(r, a);
                    }

                    rp.alt = alt.join(" ");
                    A3+= rt.apply(rp);
                    rp.cells = cb;
                    A2+=  rt.apply(rp);
                }
                return  [A3, A2];
            } :
            function(cs, rs, ds, A5, A6, A7){
                var  ts = this.templates, ct = ts.cell, rt = ts.row;
                // buffers
                var  A8 = [], A9 = [], cb, BA, c, p = {}, rp = {}, r, a;
                for(var  j = 0, len = rs.length; j < len; j++){
                    r = rs[j]; cb = []; BA = []; a = (j+A5);
                    for(var  i = 0; i < A6; i++){
                        c = cs[i];
                        p.cellId = "x-grid-cell-" + a + "-" + i;
                        p.id = c.id;
                        p.css = p.attr = "";
                        p.value = c.renderer(r.data[c.name], p, r, a, i, ds);
                        if(p.value == undefined || p.value === "") p.value = "&#160;";
                        if(r.dirty && typeof  r.modified[c.name] !== 'undefined'){
                            p.css += p.css ? ' x-grid-dirty-cell' : 'x-grid-dirty-cell';
                        }
                        var  Aa = ct.apply(p);
                        if(!c.locked){
                            cb[cb.length] = Aa;
                        }else {
                            BA[BA.length] = Aa;
                        }
                    }
                    var  alt = [];
                    if(A7 && ((a+1) % 2 == 0)){
                        alt[0] = "x-grid-row-alt";
                    }
                    if(r.dirty){
                        alt[1] = " x-grid-dirty-row";
                    }

                    rp.cells = BA;
                    if(this.getRowClass){
                        alt[2] = this.getRowClass(r, a);
                    }

                    rp.alt = alt.join(" ");
                    rp.cells = BA.join("");
                    A9[A9.length] = rt.apply(rp);
                    rp.cells = cb.join("");
                    A8[A8.length] =  rt.apply(rp);
                }
                return  [A9.join(""), A8.join("")];
            },

    renderBody : function(){
        var  BB = this.renderRows();
        var  bt = this.templates.body;
        return  [bt.apply({rows: BB[0]}), bt.apply({rows: BB[1]})];
    },

    /**
     * Refreshes the grid
     * @param {Boolean} headersToo
     */
    refresh : function(BC){
        this.fireEvent("beforerefresh", this);
        this.grid.stopEditing();
        var  BD = this.renderBody();
        this.lockedBody.update(BD[0]);
        this.mainBody.update(BD[1]);
        if(BC === true){
            this.updateHeaders();
            this.updateColumns();
            this.updateSplitters();
            this.updateHeaderSortState();
        }

        this.syncRowHeights();
        this.layout();
        this.fireEvent("refresh", this);
    },

    handleColumnMove : function(cm, BE, BF){
        this.indexMap = null;
        var  s = this.getScrollState();
        this.refresh(true);
        this.restoreScroll(s);
        this.afterMove(BF);
    },

    afterMove : function(BG){
        if(this.enableMoveAnim && Roo.enableFx){
            this.fly(this.getHeaderCell(BG).firstChild).highlight(this.hlColor);
        }
    },

    updateCell : function(dm, BH, BI){
        var  BJ = this.getColumnIndexByDataIndex(BI);
        if(typeof  BJ == "undefined"){ // not present in grid
            return;
        }
        var  cm = this.grid.colModel;
        var  BK = this.getCell(BH, BJ);
        var  BL = this.getCellText(BH, BJ);

        var  p = {
            cellId : "x-grid-cell-" + BH + "-" + BJ,
            id : cm.getColumnId(BJ),
            css: BJ == cm.getColumnCount()-1 ? "x-grid-col-last" : ""
        };
        var  BM = cm.getRenderer(BJ);
        var  BN = BM(dm.getValueAt(BH, BI), p, BH, BJ, dm);
        if(typeof  BN == "undefined" || BN === "") BN = "&#160;";
        BL.innerHTML = BN;
        BK.className = this.cellClass + " " + this.idToCssName(p.cellId) + " " + p.css;
        this.syncRowHeights(BH, BH);
    },

    calcColumnWidth : function(BO, BP){
        var  BQ = 0;
        if(this.grid.autoSizeHeaders){
            var  h = this.getHeaderCellMeasure(BO);
            BQ = Math.max(BQ, h.scrollWidth);
        }
        var  tb, BR;
        if(this.cm.isLocked(BO)){
            tb = this.getLockedTable();
            BR = BO;
        }else {
            tb = this.getBodyTable();
            BR = BO - this.cm.getLockedCount();
        }
        if(tb && tb.rows){
            var  Ar = tb.rows;
            var  stopIndex = Math.min(BP || Ar.length, Ar.length);
            for(var  i = 0; i < stopIndex; i++){
                var  BK = Ar[i].childNodes[BR].firstChild;
                BQ = Math.max(BQ, BK.scrollWidth);
            }
        }
        return  BQ + /*margin for error in IE*/ 5;
    },
    /**
     * Autofit a column to its content.
     * @param {Number} colIndex
     * @param {Boolean} forceMinSize true to force the column to go smaller if possible
     */
     autoSizeColumn : function(BS, BT, BU){
         if(this.cm.isHidden(BS)){
             return; // can't calc a hidden column
         }
        if(BT){
            var  AW = this.cm.getColumnId(BS);
            this.css.updateRule(this.colSelector +this.idToCssName( AW), "width", this.grid.minColumnWidth + "px");
           if(this.grid.autoSizeHeaders){
               this.css.updateRule(this.hdSelector + this.idToCssName(AW), "width", this.grid.minColumnWidth + "px");
           }
        }
        var  BV = this.calcColumnWidth(BS);
        this.cm.setColumnWidth(BS,
            Math.max(this.grid.minColumnWidth, BV), BU);
        if(!BU){
            this.grid.fireEvent("columnresize", BS, BV);
        }
    },

    /**
     * Autofits all columns to their content and then expands to fit any extra space in the grid
     */
     autoSizeColumns : function(){
        var  cm = this.grid.colModel;
        var  BW = cm.getColumnCount();
        for(var  i = 0; i < BW; i++){
            this.autoSizeColumn(i, true, true);
        }
        if(cm.getTotalWidth() < this.scroller.dom.clientWidth){
            this.fitColumns();
        }else {
            this.updateColumns();
            this.layout();
        }
    },

    /**
     * Autofits all columns to the grid's width proportionate with their current size
     * @param {Boolean} reserveScrollSpace Reserve space for a scrollbar
     */
    fitColumns : function(BX){
        var  cm = this.grid.colModel;
        var  BY = cm.getColumnCount();
        var  BZ = [];
        var  Ba = 0;
        var  i, w;
        for (i = 0; i < BY; i++){
            if(!cm.isHidden(i) && !cm.isFixed(i)){
                w = cm.getColumnWidth(i);
                BZ.push(i);
                BZ.push(w);
                Ba += w;
            }
        }
        var  Bb = Math.min(this.scroller.dom.clientWidth, this.el.getWidth());
        if(BX){
            Bb -= 17;
        }
        var  Bc = (Bb - cm.getTotalWidth())/Ba;
        while (BZ.length){
            w = BZ.pop();
            i = BZ.pop();
            cm.setColumnWidth(i, Math.floor(w + w*Bc), true);
        }

        this.updateColumns();
        this.layout();
    },

    onRowSelect : function(Bd){
        var  Be = this.getRowComposite(Bd);
        Be.addClass("x-grid-row-selected");
    },

    onRowDeselect : function(Bf){
        var  Bg = this.getRowComposite(Bf);
        Bg.removeClass("x-grid-row-selected");
    },

    onCellSelect : function(Bh, Bi){
        var  Bj = this.getCell(Bh, Bi);
        if(Bj){
            Roo.fly(Bj).addClass("x-grid-cell-selected");
        }
    },

    onCellDeselect : function(Bk, Bl){
        var  Bm = this.getCell(Bk, Bl);
        if(Bm){
            Roo.fly(Bm).removeClass("x-grid-cell-selected");
        }
    },

    updateHeaderSortState : function(){
        var  Bn = this.ds.getSortState();
        if(!Bn){
            return;
        }

        this.sortState = Bn;
        var  Bo = this.cm.findColumnIndex(Bn.field);
        if(Bo != -1){
            var  Ao = Bn.direction;
            var  sc = this.sortClasses;
            var  hds = this.el.select(this.headerSelector).removeClass(sc);
            hds.item(Bo).addClass(sc[Ao == "DESC" ? 1 : 0]);
        }
    },

    handleHeaderClick : function(g, Bp){
        if(this.headersDisabled){
            return;
        }
        var  dm = g.dataSource, cm = g.colModel;
	    if(!cm.isSortable(Bp)){
            return;
        }

	    g.stopEditing();
        dm.sort(cm.getDataIndex(Bp));
    },


    destroy : function(){
        if(this.colMenu){
            this.colMenu.removeAll();
            Roo.menu.MenuMgr.unregister(this.colMenu);
            this.colMenu.getEl().remove();
            delete  this.colMenu;
        }
        if(this.hmenu){
            this.hmenu.removeAll();
            Roo.menu.MenuMgr.unregister(this.hmenu);
            this.hmenu.getEl().remove();
            delete  this.hmenu;
        }
        if(this.grid.enableColumnMove){
            var  dds = Roo.dd.DDM.ids['gridHeader' + this.grid.getGridEl().id];
            if(dds){
                for(var  dd  in  dds){
                    if(!dds[dd].config.isTarget && dds[dd].dragElId){
                        var  elid = dds[dd].dragElId;
                        dds[dd].unreg();
                        Roo.get(elid).remove();
                    } else  if(dds[dd].config.isTarget){
                        dds[dd].proxyTop.remove();
                        dds[dd].proxyBottom.remove();
                        dds[dd].unreg();
                    }
                    if(Roo.dd.DDM.locationCache[dd]){
                        delete  Roo.dd.DDM.locationCache[dd];
                    }
                }
                delete  Roo.dd.DDM.ids['gridHeader' + this.grid.getGridEl().id];
            }
        }

        Roo.util.CSS.removeStyleSheet(this.idToCssName(this.grid.id) + '-cssrules');
        this.bind(null, null);
        Roo.EventManager.removeResizeListener(this.onWindowResize, this);
    },

    handleLockChange : function(){
        this.refresh(true);
    },

    onDenyColumnLock : function(){

    },

    onDenyColumnHide : function(){

    },

    handleHdMenuClick : function(Bq){
        var  Br = this.hdCtxIndex;
        var  cm = this.cm, ds = this.ds;
        switch(Bq.id){
            case  "asc":
                ds.sort(cm.getDataIndex(Br), "ASC");
                break;
            case  "desc":
                ds.sort(cm.getDataIndex(Br), "DESC");
                break;
            case  "lock":
                var  lc = cm.getLockedCount();
                if(cm.getColumnCount(true) <= lc+1){
                    this.onDenyColumnLock();
                    return;
                }
                if(lc != Br){
                    cm.setLocked(Br, true, true);
                    cm.moveColumn(Br, lc);
                    this.grid.fireEvent("columnmove", Br, lc);
                }else {
                    cm.setLocked(Br, true);
                }
            break;
            case  "unlock":
                var  lc = cm.getLockedCount();
                if((lc-1) != Br){
                    cm.setLocked(Br, false, true);
                    cm.moveColumn(Br, lc-1);
                    this.grid.fireEvent("columnmove", Br, lc-1);
                }else {
                    cm.setLocked(Br, false);
                }
            break;
            default:
                Br = cm.getIndexById(Bq.id.substr(4));
                if(Br != -1){
                    if(Bq.checked && cm.getColumnCount(true) <= 1){
                        this.onDenyColumnHide();
                        return  false;
                    }

                    cm.setHidden(Br, Bq.checked);
                }
        }
        return  true;
    },

    beforeColMenuShow : function(){
        var  cm = this.cm,  Bs = cm.getColumnCount();
        this.colMenu.removeAll();
        for(var  i = 0; i < Bs; i++){
            this.colMenu.add(new  Roo.menu.CheckItem({
                id: "col-"+cm.getColumnId(i),
                text: cm.getColumnHeader(i),
                checked: !cm.isHidden(i),
                hideOnClick:false
            }));
        }
    },

    handleHdCtx : function(g, Bt, e){
        e.stopEvent();
        var  hd = this.getHeaderCell(Bt);
        this.hdCtxIndex = Bt;
        var  ms = this.hmenu.items, cm = this.cm;
        ms.get("asc").setDisabled(!cm.isSortable(Bt));
        ms.get("desc").setDisabled(!cm.isSortable(Bt));
        if(this.grid.enableColLock !== false){
            ms.get("lock").setDisabled(cm.isLocked(Bt));
            ms.get("unlock").setDisabled(!cm.isLocked(Bt));
        }

        this.hmenu.show(hd, "tl-bl");
    },

    handleHdOver : function(e){
        var  hd = this.findHeaderCell(e.getTarget());
        if(hd && !this.headersDisabled){
            if(this.grid.colModel.isSortable(this.getCellIndex(hd))){
               this.fly(hd).addClass("x-grid-hd-over");
            }
        }
    },

    handleHdOut : function(e){
        var  hd = this.findHeaderCell(e.getTarget());
        if(hd){
            this.fly(hd).removeClass("x-grid-hd-over");
        }
    },

    handleSplitDblClick : function(e, t){
        var  i = this.getCellIndex(t);
        if(this.grid.enableColumnResize !== false && this.cm.isResizable(i) && !this.cm.isFixed(i)){
            this.autoSizeColumn(i, true);
            this.layout();
        }
    },

    render : function(){

        var  cm = this.cm;
        var  Bu = cm.getColumnCount();

        if(this.grid.monitorWindowResize === true){
            Roo.EventManager.onWindowResize(this.onWindowResize, this, true);
        }
        var  Bv = this.renderHeaders();
        var  Bw = this.templates.body.apply({rows:""});
        var  Bx = this.templates.master.apply({
            lockedBody: Bw,
            body: Bw,
            lockedHeader: Bv[0],
            header: Bv[1]
        });

        //this.updateColumns();

        this.grid.getGridEl().dom.innerHTML = Bx;

        this.initElements();

        this.scroller.on("scroll", this.handleScroll, this);
        this.lockedBody.on("mousewheel", this.handleWheel, this);
        this.mainBody.on("mousewheel", this.handleWheel, this);

        this.mainHd.on("mouseover", this.handleHdOver, this);
        this.mainHd.on("mouseout", this.handleHdOut, this);
        this.mainHd.on("dblclick", this.handleSplitDblClick, this,
                {delegate: "."+this.splitClass});

        this.lockedHd.on("mouseover", this.handleHdOver, this);
        this.lockedHd.on("mouseout", this.handleHdOut, this);
        this.lockedHd.on("dblclick", this.handleSplitDblClick, this,
                {delegate: "."+this.splitClass});

        if(this.grid.enableColumnResize !== false && Roo.grid.SplitDragZone){
            new  Roo.grid.SplitDragZone(this.grid, this.lockedHd.dom, this.mainHd.dom);
        }


        this.updateSplitters();

        if(this.grid.enableColumnMove && Roo.grid.HeaderDragZone){
            new  Roo.grid.HeaderDragZone(this.grid, this.lockedHd.dom, this.mainHd.dom);
            new  Roo.grid.HeaderDropZone(this.grid, this.lockedHd.dom, this.mainHd.dom);
        }

        if(this.grid.enableCtxMenu !== false && Roo.menu.Menu){
            this.hmenu = new  Roo.menu.Menu({id: this.grid.id + "-hctx"});
            this.hmenu.add(
                {id:"asc", text: this.sortAscText, cls: "xg-hmenu-sort-asc"},
                {id:"desc", text: this.sortDescText, cls: "xg-hmenu-sort-desc"}
            );
            if(this.grid.enableColLock !== false){
                this.hmenu.add('-',
                    {id:"lock", text: this.lockText, cls: "xg-hmenu-lock"},
                    {id:"unlock", text: this.unlockText, cls: "xg-hmenu-unlock"}
                );
            }
            if(this.grid.enableColumnHide !== false){

                this.colMenu = new  Roo.menu.Menu({id:this.grid.id + "-hcols-menu"});
                this.colMenu.on("beforeshow", this.beforeColMenuShow, this);
                this.colMenu.on("itemclick", this.handleHdMenuClick, this);

                this.hmenu.add('-',
                    {id:"columns", text: this.columnsText, menu: this.colMenu}
                );
            }

            this.hmenu.on("itemclick", this.handleHdMenuClick, this);

            this.grid.on("headercontextmenu", this.handleHdCtx, this);
        }

        if((this.grid.enableDragDrop || this.grid.enableDrag) && Roo.grid.GridDragZone){
            this.dd = new  Roo.grid.GridDragZone(this.grid, {
                ddGroup : this.grid.ddGroup || 'GridDD'
            });
        }


        /*
        for(var i = 0; i < colCount; i++){
            if(cm.isHidden(i)){
                this.hideColumn(i);
            }
            if(cm.config[i].align){
                this.css.updateRule(this.colSelector + i, "textAlign", cm.config[i].align);
                this.css.updateRule(this.hdSelector + i, "textAlign", cm.config[i].align);
            }
        }*/
        
        this.updateHeaderSortState();

        this.beforeInitialResize();
        this.layout(true);

        // two part rendering gives faster view to the user
        this.renderPhase2.defer(1, this);
    },

    renderPhase2 : function(){
        // render the rows now
        this.refresh();
        if(this.grid.autoSizeColumns){
            this.autoSizeColumns();
        }
    },

    beforeInitialResize : function(){

    },

    onColumnSplitterMoved : function(i, w){
        this.userResized = true;
        var  cm = this.grid.colModel;
        cm.setColumnWidth(i, w, true);
        var  By = cm.getColumnId(i);
        this.css.updateRule(this.colSelector + this.idToCssName(By), "width", (w-this.borderWidth) + "px");
        this.css.updateRule(this.hdSelector + this.idToCssName(By), "width", (w-this.borderWidth) + "px");
        this.updateSplitters();
        this.layout();
        this.grid.fireEvent("columnresize", i, w);
    },

    syncRowHeights : function(Bz, B0){
        if(this.grid.enableRowHeightSync === true && this.cm.getLockedCount() > 0){
            Bz = Bz || 0;
            var  mrows = this.getBodyTable().rows;
            var  As = this.getLockedTable().rows;
            var  len = mrows.length-1;
            B0 = Math.min(B0 || len, len);
            for(var  i = Bz; i <= B0; i++){
                var  m = mrows[i], l = As[i];
                var  h = Math.max(m.offsetHeight, l.offsetHeight);
                m.style.height = l.style.height = h + "px";
            }
        }
    },

    layout : function(B1, B2){
        var  g = this.grid;
        var  B3 = g.autoHeight;
        var  B4 = 16;
        var  c = g.getGridEl(), cm = this.cm,
                B5 = g.autoExpandColumn,
                gv = this;
        //c.beginMeasure();

        if(!c.dom.offsetWidth){ // display:none?
            if(B1){
                this.lockedWrap.show();
                this.mainWrap.show();
            }
            return;
        }

        var  B6 = this.cm.isLocked(0);

        var  B7 = this.headerPanel.getHeight();
        var  B8 = this.footerPanel.getHeight();

        if(B3){
            var  ch = this.getBodyTable().offsetHeight + B7 + B8 + this.mainHd.getHeight();
            var  newHeight = ch + c.getBorderWidth("tb");
            if(g.maxHeight){
                newHeight = Math.min(g.maxHeight, newHeight);
            }

            c.setHeight(newHeight);
        }

        if(g.autoWidth){
            c.setWidth(cm.getTotalWidth()+c.getBorderWidth('lr'));
        }

        var  s = this.scroller;

        var  B9 = c.getSize(true);

        this.el.setSize(B9.width, B9.height);

        this.headerPanel.setWidth(B9.width);
        this.footerPanel.setWidth(B9.width);

        var  CA = this.mainHd.getHeight();
        var  vw = B9.width;
        var  vh = B9.height - (B7 + B8);

        s.setSize(vw, vh);

        var  bt = this.getBodyTable();
        var  CB = B6 ?
                      Math.max(this.getLockedTable().offsetWidth, this.lockedHd.dom.firstChild.offsetWidth) : 0;

        var  CC = bt.offsetHeight;
        var  CD = CB + bt.offsetWidth;
        var  CE = false, CF = false;

        this.scrollSizer.setSize(CD, CC+CA);

        var  lw = this.lockedWrap, mw = this.mainWrap;
        var  lb = this.lockedBody, mb = this.mainBody;

        setTimeout(function(){
            var  t = s.dom.offsetTop;
            var  w = s.dom.clientWidth,
                h = s.dom.clientHeight;

            lw.setTop(t);
            lw.setSize(CB, h);

            mw.setLeftTop(CB, t);
            mw.setSize(w-CB, h);

            lb.setHeight(h-CA);
            mb.setHeight(h-CA);

            if(B2 !== true && !gv.userResized && B5){
                // high speed resize without full column calculation
                
                var  ci = cm.getIndexById(B5);
                if (ci < 0) {
                    ci = cm.findColumnIndex(B5);
                }

                ci = Math.max(0, ci); // make sure it's got at least the first col.
                var  expandId = cm.getColumnId(ci);
                var   tw = cm.getTotalWidth(false);
                var  currentWidth = cm.getColumnWidth(ci);
                var  cw = Math.min(Math.max(((w-tw)+currentWidth-2)-/*scrollbar*/(w <= s.dom.offsetWidth ? 0 : 18), g.autoExpandMin), g.autoExpandMax);
                if(currentWidth != cw){
                    cm.setColumnWidth(ci, cw, true);
                    gv.css.updateRule(gv.colSelector+gv.idToCssName(expandId), "width", (cw - gv.borderWidth) + "px");
                    gv.css.updateRule(gv.hdSelector+gv.idToCssName(expandId), "width", (cw - gv.borderWidth) + "px");
                    gv.updateSplitters();
                    gv.layout(false, true);
                }
            }

            if(B1){
                lw.show();
                mw.show();
            }
            //c.endMeasure();
        }, 10);
    },

    onWindowResize : function(){
        if(!this.grid.monitorWindowResize || this.grid.autoHeight){
            return;
        }

        this.layout();
    },

    appendFooter : function(CG){
        return  null;
    },

    sortAscText : "Sort Ascending",
    sortDescText : "Sort Descending",
    lockText : "Lock Column",
    unlockText : "Unlock Column",
    columnsText : "Columns"
});


Roo.grid.GridView.ColumnDragZone = function(CH, hd){
    Roo.grid.GridView.ColumnDragZone.superclass.constructor.call(this, CH, hd, null);
    this.proxy.el.addClass('x-grid3-col-dd');
};

Roo.extend(Roo.grid.GridView.ColumnDragZone, Roo.grid.HeaderDragZone, {
    handleMouseDown : function(e){

    },

    callHandleMouseDown : function(e){
        Roo.grid.GridView.ColumnDragZone.superclass.handleMouseDown.call(this, e);
    }
});

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
// private
// This is a support class used internally by the Grid components
Roo.grid.SplitDragZone = function(A, hd, B){
    this.grid = A;
    this.view = A.getView();
    this.proxy = this.view.resizeProxy;
    Roo.grid.SplitDragZone.superclass.constructor.call(this, hd,
        "gridSplitters" + this.grid.getGridEl().id, {
        dragElId : Roo.id(this.proxy.dom), resizeFrame:false
    });
    this.setHandleElId(Roo.id(hd));
    this.setOuterHandleElId(Roo.id(B));
    this.scroll = false;
};
Roo.extend(Roo.grid.SplitDragZone, Roo.dd.DDProxy, {
    fly: Roo.Element.fly,

    b4StartDrag : function(x, y){
        this.view.headersDisabled = true;
        this.proxy.setHeight(this.view.mainWrap.getHeight());
        var  w = this.cm.getColumnWidth(this.cellIndex);
        var  C = Math.max(w-this.grid.minColumnWidth, 0);
        this.resetConstraints();
        this.setXConstraint(C, 1000);
        this.setYConstraint(0, 0);
        this.minX = x - C;
        this.maxX = x + 1000;
        this.startPos = x;
        Roo.dd.DDProxy.prototype.b4StartDrag.call(this, x, y);
    },


    handleMouseDown : function(e){
        ev = Roo.EventObject.setEvent(e);
        var  t = this.fly(ev.getTarget());
        if(t.hasClass("x-grid-split")){
            this.cellIndex = this.view.getCellIndex(t.dom);
            this.split = t.dom;
            this.cm = this.grid.colModel;
            if(this.cm.isResizable(this.cellIndex) && !this.cm.isFixed(this.cellIndex)){
                Roo.grid.SplitDragZone.superclass.handleMouseDown.apply(this, arguments);
            }
        }
    },

    endDrag : function(e){
        this.view.headersDisabled = false;
        var  D = Math.max(this.minX, Roo.lib.Event.getPageX(e));
        var  E = D - this.startPos;
        this.view.onColumnSplitterMoved(this.cellIndex, this.cm.getColumnWidth(this.cellIndex)+E);
    },

    autoOffset : function(){
        this.setDelta(0,0);
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
// private
// This is a support class used internally by the Grid components
Roo.grid.GridDragZone = function(A, B){
    this.view = A.getView();
    Roo.grid.GridDragZone.superclass.constructor.call(this, this.view.mainBody.dom, B);
    if(this.view.lockedBody){
        this.setHandleElId(Roo.id(this.view.mainBody.dom));
        this.setOuterHandleElId(Roo.id(this.view.lockedBody.dom));
    }

    this.scroll = false;
    this.grid = A;
    this.ddel = document.createElement('div');
    this.ddel.className = 'x-grid-dd-wrap';
};

Roo.extend(Roo.grid.GridDragZone, Roo.dd.DragZone, {
    ddGroup : "GridDD",

    getDragData : function(e){
        var  t = Roo.lib.Event.getTarget(e);
        var  C = this.view.findRowIndex(t);
        if(C !== false){
            var  sm = this.grid.selModel;
            //if(!sm.isSelected(rowIndex) || e.hasModifier()){
              //  sm.mouseDown(e, t);
            //}
            if (e.hasModifier()){
                sm.handleMouseDown(e, t); // non modifier buttons are handled by row select.
            }
            return  {grid: this.grid, ddel: this.ddel, rowIndex: C, selections:sm.getSelections()};
        }
        return  false;
    },

    onInitDrag : function(e){
        var  D = this.dragData;
        this.ddel.innerHTML = this.grid.getDragDropText();
        this.proxy.update(this.ddel);
        // fire start drag?
    },

    afterRepair : function(){
        this.dragging = false;
    },

    getRepairXY : function(e, E){
        return  false;
    },

    onEndDrag : function(F, e){
        // fire end drag?
    },

    onValidDrop : function(dd, e, id){
        // fire drag drop?
        this.hideProxy();
    },

    beforeInvalidDrop : function(e, id){

    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 

/**
 * @class Roo.grid.ColumnModel
 * @extends Roo.util.Observable
 * This is the default implementation of a ColumnModel used by the Grid. It defines
 * the columns in the grid.
 * <br>Usage:<br>
 <pre><code>
 var colModel = new Roo.grid.ColumnModel([
	{header: "Ticker", width: 60, sortable: true, locked: true},
	{header: "Company Name", width: 150, sortable: true},
	{header: "Market Cap.", width: 100, sortable: true},
	{header: "$ Sales", width: 100, sortable: true, renderer: money},
	{header: "Employees", width: 100, sortable: true, resizable: false}
 ]);
 </code></pre>
 * <p>
 
 * The config options listed for this class are options which may appear in each
 * individual column definition.
 * <br/>RooJS Fix - column id's are not sequential but use Roo.id() - fixes bugs with layouts.
 * @constructor
 * @param {Object} config An Array of column config objects. See this class's
 * config objects for details.
*/
Roo.grid.ColumnModel = function(A){
	/**
     * The config passed into the constructor
     */
    this.config = A;
    this.lookup = {};

    // if no id, create one
    // if the column does not have a dataIndex mapping,
    // map it to the order it is in the config
    for(var  i = 0, len = A.length; i < len; i++){
        var  c = A[i];
        if(typeof  c.dataIndex == "undefined"){
            c.dataIndex = i;
        }
        if(typeof  c.renderer == "string"){
            c.renderer = Roo.util.Format[c.renderer];
        }
        if(typeof  c.id == "undefined"){
            c.id = Roo.id();
        }
        if(c.editor && c.editor.xtype){
            c.editor  = Roo.factory(c.editor, Roo.grid);
        }
        if(c.editor && c.editor.isFormField){
            c.editor = new  Roo.grid.GridEditor(c.editor);
        }

        this.lookup[c.id] = c;
    }


    /**
     * The width of columns which have no width specified (defaults to 100)
     * @type Number
     */
    this.defaultWidth = 100;

    /**
     * Default sortable of columns which have no sortable specified (defaults to false)
     * @type Boolean
     */
    this.defaultSortable = false;

    this.addEvents({
        /**
	     * @event widthchange
	     * Fires when the width of a column changes.
	     * @param {ColumnModel} this
	     * @param {Number} columnIndex The column index
	     * @param {Number} newWidth The new width
	     */
	    "widthchange": true,
        /**
	     * @event headerchange
	     * Fires when the text of a header changes.
	     * @param {ColumnModel} this
	     * @param {Number} columnIndex The column index
	     * @param {Number} newText The new header text
	     */
	    "headerchange": true,
        /**
	     * @event hiddenchange
	     * Fires when a column is hidden or "unhidden".
	     * @param {ColumnModel} this
	     * @param {Number} columnIndex The column index
	     * @param {Boolean} hidden true if hidden, false otherwise
	     */
	    "hiddenchange": true,
	    /**
         * @event columnmoved
         * Fires when a column is moved.
         * @param {ColumnModel} this
         * @param {Number} oldIndex
         * @param {Number} newIndex
         */
        "columnmoved" : true,
        /**
         * @event columlockchange
         * Fires when a column's locked state is changed
         * @param {ColumnModel} this
         * @param {Number} colIndex
         * @param {Boolean} locked true if locked
         */
        "columnlockchange" : true
    });
    Roo.grid.ColumnModel.superclass.constructor.call(this);
};
Roo.extend(Roo.grid.ColumnModel, Roo.util.Observable, {
    /**
     * @cfg {String} header The header text to display in the Grid view.
     */
    /**
     * @cfg {String} dataIndex (Optional) The name of the field in the grid's {@link Roo.data.Store}'s
     * {@link Roo.data.Record} definition from which to draw the column's value. If not
     * specified, the column's index is used as an index into the Record's data Array.
     */
    /**
     * @cfg {Number} width (Optional) The initial width in pixels of the column. Using this
     * instead of {@link Roo.grid.Grid#autoSizeColumns} is more efficient.
     */
    /**
     * @cfg {Boolean} sortable (Optional) True if sorting is to be allowed on this column.
     * Defaults to the value of the {@link #defaultSortable} property.
     * Whether local/remote sorting is used is specified in {@link Roo.data.Store#remoteSort}.
     */
    /**
     * @cfg {Boolean} locked (Optional) True to lock the column in place while scrolling the Grid.  Defaults to false.
     */
    /**
     * @cfg {Boolean} fixed (Optional) True if the column width cannot be changed.  Defaults to false.
     */
    /**
     * @cfg {Boolean} resizable (Optional) False to disable column resizing. Defaults to true.
     */
    /**
     * @cfg {Boolean} hidden (Optional) True to hide the column. Defaults to false.
     */
    /**
     * @cfg {Function} renderer (Optional) A function used to generate HTML markup for a cell
     * given the cell's data value. See {@link #setRenderer}. If not specified, the
     * default renderer uses the raw data value.
     */
       /**
     * @cfg {Roo.grid.GridEditor} editor (Optional) For grid editors - returns the grid editor 
     */
    /**
     * @cfg {String} align (Optional) Set the CSS text-align property of the column.  Defaults to undefined.
     */

    /**
     * Returns the id of the column at the specified index.
     * @param {Number} index The column index
     * @return {String} the id
     */
    getColumnId : function(B){
        return  this.config[B].id;
    },

    /**
     * Returns the column for a specified id.
     * @param {String} id The column id
     * @return {Object} the column
     */
    getColumnById : function(id){
        return  this.lookup[id];
    },

    /**
     * Returns the index for a specified column id.
     * @param {String} id The column id
     * @return {Number} the index, or -1 if not found
     */
    getIndexById : function(id){
        for(var  i = 0, len = this.config.length; i < len; i++){
            if(this.config[i].id == id){
                return  i;
            }
        }
        return  -1;
    },
    /**
     * Returns the index for a specified column dataIndex.
     * @param {String} dataIndex The column dataIndex
     * @return {Number} the index, or -1 if not found
     */
    
    findColumnIndex : function(C){
        for(var  i = 0, len = this.config.length; i < len; i++){
            if(this.config[i].dataIndex == C){
                return  i;
            }
        }
        return  -1;
    },
    
    
    moveColumn : function(D, E){
        var  c = this.config[D];
        this.config.splice(D, 1);
        this.config.splice(E, 0, c);
        this.dataMap = null;
        this.fireEvent("columnmoved", this, D, E);
    },

    isLocked : function(F){
        return  this.config[F].locked === true;
    },

    setLocked : function(G, H, I){
        if(this.isLocked(G) == H){
            return;
        }

        this.config[G].locked = H;
        if(!I){
            this.fireEvent("columnlockchange", this, G, H);
        }
    },

    getTotalLockedWidth : function(){
        var  J = 0;
        for(var  i = 0; i < this.config.length; i++){
            if(this.isLocked(i) && !this.isHidden(i)){
                this.totalWidth += this.getColumnWidth(i);
            }
        }
        return  J;
    },

    getLockedCount : function(){
        for(var  i = 0, len = this.config.length; i < len; i++){
            if(!this.isLocked(i)){
                return  i;
            }
        }
    },

    /**
     * Returns the number of columns.
     * @return {Number}
     */
    getColumnCount : function(K){
        if(K === true){
            var  c = 0;
            for(var  i = 0, len = this.config.length; i < len; i++){
                if(!this.isHidden(i)){
                    c++;
                }
            }
            return  c;
        }
        return  this.config.length;
    },

    /**
     * Returns the column configs that return true by the passed function that is called with (columnConfig, index)
     * @param {Function} fn
     * @param {Object} scope (optional)
     * @return {Array} result
     */
    getColumnsBy : function(fn, L){
        var  r = [];
        for(var  i = 0, len = this.config.length; i < len; i++){
            var  c = this.config[i];
            if(fn.call(L||this, c, i) === true){
                r[r.length] = c;
            }
        }
        return  r;
    },

    /**
     * Returns true if the specified column is sortable.
     * @param {Number} col The column index
     * @return {Boolean}
     */
    isSortable : function(M){
        if(typeof  this.config[M].sortable == "undefined"){
            return  this.defaultSortable;
        }
        return  this.config[M].sortable;
    },

    /**
     * Returns the rendering (formatting) function defined for the column.
     * @param {Number} col The column index.
     * @return {Function} The function used to render the cell. See {@link #setRenderer}.
     */
    getRenderer : function(N){
        if(!this.config[N].renderer){
            return  Roo.grid.ColumnModel.defaultRenderer;
        }
        return  this.config[N].renderer;
    },

    /**
     * Sets the rendering (formatting) function for a column.
     * @param {Number} col The column index
     * @param {Function} fn The function to use to process the cell's raw data
     * to return HTML markup for the grid view. The render function is called with
     * the following parameters:<ul>
     * <li>Data value.</li>
     * <li>Cell metadata. An object in which you may set the following attributes:<ul>
     * <li>css A CSS style string to apply to the table cell.</li>
     * <li>attr An HTML attribute definition string to apply to the data container element <i>within</i> the table cell.</li></ul>
     * <li>The {@link Roo.data.Record} from which the data was extracted.</li>
     * <li>Row index</li>
     * <li>Column index</li>
     * <li>The {@link Roo.data.Store} object from which the Record was extracted</li></ul>
     */
    setRenderer : function(O, fn){
        this.config[O].renderer = fn;
    },

    /**
     * Returns the width for the specified column.
     * @param {Number} col The column index
     * @return {Number}
     */
    getColumnWidth : function(P){
        return  this.config[P].width || this.defaultWidth;
    },

    /**
     * Sets the width for a column.
     * @param {Number} col The column index
     * @param {Number} width The new width
     */
    setColumnWidth : function(Q, R, S){
        this.config[Q].width = R;
        this.totalWidth = null;
        if(!S){
             this.fireEvent("widthchange", this, Q, R);
        }
    },

    /**
     * Returns the total width of all columns.
     * @param {Boolean} includeHidden True to include hidden column widths
     * @return {Number}
     */
    getTotalWidth : function(T){
        if(!this.totalWidth){
            this.totalWidth = 0;
            for(var  i = 0, len = this.config.length; i < len; i++){
                if(T || !this.isHidden(i)){
                    this.totalWidth += this.getColumnWidth(i);
                }
            }
        }
        return  this.totalWidth;
    },

    /**
     * Returns the header for the specified column.
     * @param {Number} col The column index
     * @return {String}
     */
    getColumnHeader : function(U){
        return  this.config[U].header;
    },

    /**
     * Sets the header for a column.
     * @param {Number} col The column index
     * @param {String} header The new header
     */
    setColumnHeader : function(V, W){
        this.config[V].header = W;
        this.fireEvent("headerchange", this, V, W);
    },

    /**
     * Returns the tooltip for the specified column.
     * @param {Number} col The column index
     * @return {String}
     */
    getColumnTooltip : function(X){
            return  this.config[X].tooltip;
    },
    /**
     * Sets the tooltip for a column.
     * @param {Number} col The column index
     * @param {String} tooltip The new tooltip
     */
    setColumnTooltip : function(Y, Z){
            this.config[Y].tooltip = Z;
    },

    /**
     * Returns the dataIndex for the specified column.
     * @param {Number} col The column index
     * @return {Number}
     */
    getDataIndex : function(a){
        return  this.config[a].dataIndex;
    },

    /**
     * Sets the dataIndex for a column.
     * @param {Number} col The column index
     * @param {Number} dataIndex The new dataIndex
     */
    setDataIndex : function(b, d){
        this.config[b].dataIndex = d;
    },

    
    
    /**
     * Returns true if the cell is editable.
     * @param {Number} colIndex The column index
     * @param {Number} rowIndex The row index
     * @return {Boolean}
     */
    isCellEditable : function(e, f){
        return  (this.config[e].editable || (typeof  this.config[e].editable == "undefined" && this.config[e].editor)) ? true : false;
    },

    /**
     * Returns the editor defined for the cell/column.
     * return false or null to disable editing.
     * @param {Number} colIndex The column index
     * @param {Number} rowIndex The row index
     * @return {Object}
     */
    getCellEditor : function(g, h){
        return  this.config[g].editor;
    },

    /**
     * Sets if a column is editable.
     * @param {Number} col The column index
     * @param {Boolean} editable True if the column is editable
     */
    setEditable : function(j, k){
        this.config[j].editable = k;
    },


    /**
     * Returns true if the column is hidden.
     * @param {Number} colIndex The column index
     * @return {Boolean}
     */
    isHidden : function(l){
        return  this.config[l].hidden;
    },


    /**
     * Returns true if the column width cannot be changed
     */
    isFixed : function(m){
        return  this.config[m].fixed;
    },

    /**
     * Returns true if the column can be resized
     * @return {Boolean}
     */
    isResizable : function(n){
        return  n >= 0 && this.config[n].resizable !== false && this.config[n].fixed !== true;
    },
    /**
     * Sets if a column is hidden.
     * @param {Number} colIndex The column index
     * @param {Boolean} hidden True if the column is hidden
     */
    setHidden : function(o, p){
        this.config[o].hidden = p;
        this.totalWidth = null;
        this.fireEvent("hiddenchange", this, o, p);
    },

    /**
     * Sets the editor for a column.
     * @param {Number} col The column index
     * @param {Object} editor The editor object
     */
    setEditor : function(q, s){
        this.config[q].editor = s;
    }
});

Roo.grid.ColumnModel.defaultRenderer = function(t){
	if(typeof  t == "string" && t.length < 1){
	    return  "&#160;";
	}
	return  t;
};

// Alias for backwards compatibility
Roo.grid.DefaultColumnModel = Roo.grid.ColumnModel;

/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

/**
 * @class Roo.grid.AbstractSelectionModel
 * @extends Roo.util.Observable
 * Abstract base class for grid SelectionModels.  It provides the interface that should be
 * implemented by descendant classes.  This class should not be directly instantiated.
 * @constructor
 */
Roo.grid.AbstractSelectionModel = function(){
    this.locked = false;
    Roo.grid.AbstractSelectionModel.superclass.constructor.call(this);
};

Roo.extend(Roo.grid.AbstractSelectionModel, Roo.util.Observable,  {
    /** @ignore Called by the grid automatically. Do not call directly. */
    init : function(A){
        this.grid = A;
        this.initEvents();
    },

    /**
     * Locks the selections.
     */
    lock : function(){
        this.locked = true;
    },

    /**
     * Unlocks the selections.
     */
    unlock : function(){
        this.locked = false;
    },

    /**
     * Returns true if the selections are locked.
     * @return {Boolean}
     */
    isLocked : function(){
        return  this.locked;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @extends Roo.grid.AbstractSelectionModel
 * @class Roo.grid.RowSelectionModel
 * The default SelectionModel used by {@link Roo.grid.Grid}.
 * It supports multiple selections and keyboard selection/navigation. 
 * @constructor
 * @param {Object} config
 */
Roo.grid.RowSelectionModel = function(A){
    Roo.apply(this, A);
    this.selections = new  Roo.util.MixedCollection(false, function(o){
        return  o.id;
    });

    this.last = false;
    this.lastActive = false;

    this.addEvents({
        /**
	     * @event selectionchange
	     * Fires when the selection changes
	     * @param {SelectionModel} this
	     */
	    "selectionchange" : true,
        /**
	     * @event afterselectionchange
	     * Fires after the selection changes (eg. by key press or clicking)
	     * @param {SelectionModel} this
	     */
	    "afterselectionchange" : true,
        /**
	     * @event beforerowselect
	     * Fires when a row is selected being selected, return false to cancel.
	     * @param {SelectionModel} this
	     * @param {Number} rowIndex The selected index
	     * @param {Boolean} keepExisting False if other selections will be cleared
	     */
	    "beforerowselect" : true,
        /**
	     * @event rowselect
	     * Fires when a row is selected.
	     * @param {SelectionModel} this
	     * @param {Number} rowIndex The selected index
	     * @param {Roo.data.Record} r The record
	     */
	    "rowselect" : true,
        /**
	     * @event rowdeselect
	     * Fires when a row is deselected.
	     * @param {SelectionModel} this
	     * @param {Number} rowIndex The selected index
	     */
        "rowdeselect" : true
    });
    Roo.grid.RowSelectionModel.superclass.constructor.call(this);
    this.locked = false;
};

Roo.extend(Roo.grid.RowSelectionModel, Roo.grid.AbstractSelectionModel,  {
    /**
     * @cfg {Boolean} singleSelect
     * True to allow selection of only one row at a time (defaults to false)
     */
    singleSelect : false,

    // private
    initEvents : function(){

        if(!this.grid.enableDragDrop && !this.grid.enableDrag){
            this.grid.on("mousedown", this.handleMouseDown, this);
        }else { // allow click to work like normal
            this.grid.on("rowclick", this.handleDragableRowClick, this);
        }


        this.rowNav = new  Roo.KeyNav(this.grid.getGridEl(), {
            "up" : function(e){
                if(!e.shiftKey){
                    this.selectPrevious(e.shiftKey);
                }else  if(this.last !== false && this.lastActive !== false){
                    var  last = this.last;
                    this.selectRange(this.last,  this.lastActive-1);
                    this.grid.getView().focusRow(this.lastActive);
                    if(last !== false){
                        this.last = last;
                    }
                }else {
                    this.selectFirstRow();
                }

                this.fireEvent("afterselectionchange", this);
            },
            "down" : function(e){
                if(!e.shiftKey){
                    this.selectNext(e.shiftKey);
                }else  if(this.last !== false && this.lastActive !== false){
                    var  last = this.last;
                    this.selectRange(this.last,  this.lastActive+1);
                    this.grid.getView().focusRow(this.lastActive);
                    if(last !== false){
                        this.last = last;
                    }
                }else {
                    this.selectFirstRow();
                }

                this.fireEvent("afterselectionchange", this);
            },
            scope: this
        });

        var  B = this.grid.view;
        B.on("refresh", this.onRefresh, this);
        B.on("rowupdated", this.onRowUpdated, this);
        B.on("rowremoved", this.onRemove, this);
    },

    // private
    onRefresh : function(){
        var  ds = this.grid.dataSource, i, v = this.grid.view;
        var  s = this.selections;
        s.each(function(r){
            if((i = ds.indexOfId(r.id)) != -1){
                v.onRowSelect(i);
            }else {
                s.remove(r);
            }
        });
    },

    // private
    onRemove : function(v, C, r){
        this.selections.remove(r);
    },

    // private
    onRowUpdated : function(v, D, r){
        if(this.isSelected(r)){
            v.onRowSelect(D);
        }
    },

    /**
     * Select records.
     * @param {Array} records The records to select
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectRecords : function(E, F){
        if(!F){
            this.clearSelections();
        }
        var  ds = this.grid.dataSource;
        for(var  i = 0, len = E.length; i < len; i++){
            this.selectRow(ds.indexOf(E[i]), true);
        }
    },

    /**
     * Gets the number of selected rows.
     * @return {Number}
     */
    getCount : function(){
        return  this.selections.length;
    },

    /**
     * Selects the first row in the grid.
     */
    selectFirstRow : function(){
        this.selectRow(0);
    },

    /**
     * Select the last row.
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectLastRow : function(G){
        this.selectRow(this.grid.dataSource.getCount() - 1, G);
    },

    /**
     * Selects the row immediately following the last selected row.
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectNext : function(H){
        if(this.last !== false && (this.last+1) < this.grid.dataSource.getCount()){
            this.selectRow(this.last+1, H);
            this.grid.getView().focusRow(this.last);
        }
    },

    /**
     * Selects the row that precedes the last selected row.
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectPrevious : function(I){
        if(this.last){
            this.selectRow(this.last-1, I);
            this.grid.getView().focusRow(this.last);
        }
    },

    /**
     * Returns the selected records
     * @return {Array} Array of selected records
     */
    getSelections : function(){
        return  [].concat(this.selections.items);
    },

    /**
     * Returns the first selected record.
     * @return {Record}
     */
    getSelected : function(){
        return  this.selections.itemAt(0);
    },


    /**
     * Clears all selections.
     */
    clearSelections : function(J){
        if(this.locked) return;
        if(J !== true){
            var  ds = this.grid.dataSource;
            var  s = this.selections;
            s.each(function(r){
                this.deselectRow(ds.indexOfId(r.id));
            }, this);
            s.clear();
        }else {
            this.selections.clear();
        }

        this.last = false;
    },


    /**
     * Selects all rows.
     */
    selectAll : function(){
        if(this.locked) return;
        this.selections.clear();
        for(var  i = 0, len = this.grid.dataSource.getCount(); i < len; i++){
            this.selectRow(i, true);
        }
    },

    /**
     * Returns True if there is a selection.
     * @return {Boolean}
     */
    hasSelection : function(){
        return  this.selections.length > 0;
    },

    /**
     * Returns True if the specified row is selected.
     * @param {Number/Record} record The record or index of the record to check
     * @return {Boolean}
     */
    isSelected : function(K){
        var  r = typeof  K == "number" ? this.grid.dataSource.getAt(K) : K;
        return  (r && this.selections.key(r.id) ? true : false);
    },

    /**
     * Returns True if the specified record id is selected.
     * @param {String} id The id of record to check
     * @return {Boolean}
     */
    isIdSelected : function(id){
        return  (this.selections.key(id) ? true : false);
    },

    // private
    handleMouseDown : function(e, t){
        var  L = this.grid.getView(), M;
        if(this.isLocked() || (M = L.findRowIndex(t)) === false){
            return;
        };
        if(e.shiftKey && this.last !== false){
            var  last = this.last;
            this.selectRange(last, M, e.ctrlKey);
            this.last = last; // reset the last
            L.focusRow(M);
        }else {
            var  isSelected = this.isSelected(M);
            if(e.button !== 0 && isSelected){
                L.focusRow(M);
            }else  if(e.ctrlKey && isSelected){
                this.deselectRow(M);
            }else  if(!isSelected){
                this.selectRow(M, e.button === 0 && (e.ctrlKey || e.shiftKey));
                L.focusRow(M);
            }
        }

        this.fireEvent("afterselectionchange", this);
    },
    // private
    handleDragableRowClick :  function(N, O, e) 
    {
        if(e.button === 0 && !e.shiftKey && !e.ctrlKey) {
            this.selectRow(O, false);
            N.view.focusRow(O);
             this.fireEvent("afterselectionchange", this);
        }
    },
    
    /**
     * Selects multiple rows.
     * @param {Array} rows Array of the indexes of the row to select
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectRows : function(P, Q){
        if(!Q){
            this.clearSelections();
        }
        for(var  i = 0, len = P.length; i < len; i++){
            this.selectRow(P[i], true);
        }
    },

    /**
     * Selects a range of rows. All rows in between startRow and endRow are also selected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     * @param {Boolean} keepExisting (optional) True to retain existing selections
     */
    selectRange : function(R, S, T){
        if(this.locked) return;
        if(!T){
            this.clearSelections();
        }
        if(R <= S){
            for(var  i = R; i <= S; i++){
                this.selectRow(i, true);
            }
        }else {
            for(var  i = R; i >= S; i--){
                this.selectRow(i, true);
            }
        }
    },

    /**
     * Deselects a range of rows. All rows in between startRow and endRow are also deselected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     */
    deselectRange : function(U, V, W){
        if(this.locked) return;
        for(var  i = U; i <= V; i++){
            this.deselectRow(i, W);
        }
    },

    /**
     * Selects a row.
     * @param {Number} row The index of the row to select
     * @param {Boolean} keepExisting (optional) True to keep existing selections
     */
    selectRow : function(X, Y, Z){
        if(this.locked || (X < 0 || X >= this.grid.dataSource.getCount())) return;
        if(this.fireEvent("beforerowselect", this, X, Y) !== false){
            if(!Y || this.singleSelect){
                this.clearSelections();
            }
            var  r = this.grid.dataSource.getAt(X);
            this.selections.add(r);
            this.last = this.lastActive = X;
            if(!Z){
                this.grid.getView().onRowSelect(X);
            }

            this.fireEvent("rowselect", this, X, r);
            this.fireEvent("selectionchange", this);
        }
    },

    /**
     * Deselects a row.
     * @param {Number} row The index of the row to deselect
     */
    deselectRow : function(a, b){
        if(this.locked) return;
        if(this.last == a){
            this.last = false;
        }
        if(this.lastActive == a){
            this.lastActive = false;
        }
        var  r = this.grid.dataSource.getAt(a);
        this.selections.remove(r);
        if(!b){
            this.grid.getView().onRowDeselect(a);
        }

        this.fireEvent("rowdeselect", this, a);
        this.fireEvent("selectionchange", this);
    },

    // private
    restoreLast : function(){
        if(this._last){
            this.last = this._last;
        }
    },

    // private
    acceptsNav : function(c, d, cm){
        return  !cm.isHidden(d) && cm.isCellEditable(d, c);
    },

    // private
    onEditorKey : function(f, e){
        var  k = e.getKey(), h, g = this.grid, ed = g.activeEditor;
        if(k == e.TAB){
            e.stopEvent();
            ed.completeEdit();
            if(e.shiftKey){
                h = g.walkCells(ed.row, ed.col-1, -1, this.acceptsNav, this);
            }else {
                h = g.walkCells(ed.row, ed.col+1, 1, this.acceptsNav, this);
            }
        }else  if(k == e.ENTER && !e.ctrlKey){
            e.stopEvent();
            ed.completeEdit();
            if(e.shiftKey){
                h = g.walkCells(ed.row-1, ed.col, -1, this.acceptsNav, this);
            }else {
                h = g.walkCells(ed.row+1, ed.col, 1, this.acceptsNav, this);
            }
        }else  if(k == e.ESC){
            ed.cancelEdit();
        }
        if(h){
            g.startEditing(h[0], h[1]);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
/**
 * @class Roo.grid.CellSelectionModel
 * @extends Roo.grid.AbstractSelectionModel
 * This class provides the basic implementation for cell selection in a grid.
 * @constructor
 * @param {Object} config The object containing the configuration of this model.
 */
Roo.grid.CellSelectionModel = function(A){
    Roo.apply(this, A);

    this.selection = null;

    this.addEvents({
        /**
	     * @event beforerowselect
	     * Fires before a cell is selected.
	     * @param {SelectionModel} this
	     * @param {Number} rowIndex The selected row index
	     * @param {Number} colIndex The selected cell index
	     */
	    "beforecellselect" : true,
        /**
	     * @event cellselect
	     * Fires when a cell is selected.
	     * @param {SelectionModel} this
	     * @param {Number} rowIndex The selected row index
	     * @param {Number} colIndex The selected cell index
	     */
	    "cellselect" : true,
        /**
	     * @event selectionchange
	     * Fires when the active selection changes.
	     * @param {SelectionModel} this
	     * @param {Object} selection null for no selection or an object (o) with two properties
	        <ul>
	        <li>o.record: the record object for the row the selection is in</li>
	        <li>o.cell: An array of [rowIndex, columnIndex]</li>
	        </ul>
	     */
	    "selectionchange" : true
    });
    Roo.grid.CellSelectionModel.superclass.constructor.call(this);
};

Roo.extend(Roo.grid.CellSelectionModel, Roo.grid.AbstractSelectionModel,  {

    /** @ignore */
    initEvents : function(){
        this.grid.on("mousedown", this.handleMouseDown, this);
        this.grid.getGridEl().on(Roo.isIE ? "keydown" : "keypress", this.handleKeyDown, this);
        var  B = this.grid.view;
        B.on("refresh", this.onViewChange, this);
        B.on("rowupdated", this.onRowUpdated, this);
        B.on("beforerowremoved", this.clearSelections, this);
        B.on("beforerowsinserted", this.clearSelections, this);
        if(this.grid.isEditor){
            this.grid.on("beforeedit", this.beforeEdit,  this);
        }
    },

	//private
    beforeEdit : function(e){
        this.select(e.row, e.column, false, true, e.record);
    },

	//private
    onRowUpdated : function(v, C, r){
        if(this.selection && this.selection.record == r){
            v.onCellSelect(C, this.selection.cell[1]);
        }
    },

	//private
    onViewChange : function(){
        this.clearSelections(true);
    },

	/**
	 * Returns the currently selected cell,.
	 * @return {Array} The selected cell (row, column) or null if none selected.
	 */
    getSelectedCell : function(){
        return  this.selection ? this.selection.cell : null;
    },

    /**
     * Clears all selections.
     * @param {Boolean} true to prevent the gridview from being notified about the change.
     */
    clearSelections : function(D){
        var  s = this.selection;
        if(s){
            if(D !== true){
                this.grid.view.onCellDeselect(s.cell[0], s.cell[1]);
            }

            this.selection = null;
            this.fireEvent("selectionchange", this, null);
        }
    },

    /**
     * Returns true if there is a selection.
     * @return {Boolean}
     */
    hasSelection : function(){
        return  this.selection ? true : false;
    },

    /** @ignore */
    handleMouseDown : function(e, t){
        var  v = this.grid.getView();
        if(this.isLocked()){
            return;
        };
        var  E = v.findRowIndex(t);
        var  F = v.findCellIndex(t);
        if(E !== false && F !== false){
            this.select(E, F);
        }
    },

    /**
     * Selects a cell.
     * @param {Number} rowIndex
     * @param {Number} collIndex
     */
    select : function(G, H, I, J, /*internal*/ r){
        if(this.fireEvent("beforecellselect", this, G, H) !== false){
            this.clearSelections();
            r = r || this.grid.dataSource.getAt(G);
            this.selection = {
                record : r,
                cell : [G, H]
            };
            if(!I){
                var  v = this.grid.getView();
                v.onCellSelect(G, H);
                if(J !== true){
                    v.focusCell(G, H);
                }
            }

            this.fireEvent("cellselect", this, G, H);
            this.fireEvent("selectionchange", this, this.selection);
        }
    },

	//private
    isSelectable : function(K, L, cm){
        return  !cm.isHidden(L);
    },

    /** @ignore */
    handleKeyDown : function(e){
        if(!e.isNavKeyPress()){
            return;
        }
        var  g = this.grid, s = this.selection;
        if(!s){
            e.stopEvent();
            var  F = g.walkCells(0, 0, 1, this.isSelectable,  this);
            if(F){
                this.select(F[0], F[1]);
            }
            return;
        }
        var  sm = this;
        var  M = function(O, P, Q){
            return  g.walkCells(O, P, Q, sm.isSelectable,  sm);
        };
        var  k = e.getKey(), r = s.cell[0], c = s.cell[1];
        var  N;

        switch(k){
             case  e.TAB:
                 if(e.shiftKey){
                     N = M(r, c-1, -1);
                 }else {
                     N = M(r, c+1, 1);
                 }
             break;
             case  e.DOWN:
                 N = M(r+1, c, 1);
             break;
             case  e.UP:
                 N = M(r-1, c, -1);
             break;
             case  e.RIGHT:
                 N = M(r, c+1, 1);
             break;
             case  e.LEFT:
                 N = M(r, c-1, -1);
             break;
             case  e.ENTER:
                 if(g.isEditor && !g.editing){
                    g.startEditing(r, c);
                    e.stopEvent();
                    return;
                }
             break;
        };
        if(N){
            this.select(N[0], N[1]);
            e.stopEvent();
        }
    },

    acceptsNav : function(O, P, cm){
        return  !cm.isHidden(P) && cm.isCellEditable(P, O);
    },

    onEditorKey : function(Q, e){
        var  k = e.getKey(), R, g = this.grid, ed = g.activeEditor;
        if(k == e.TAB){
            if(e.shiftKey){
                R = g.walkCells(ed.row, ed.col-1, -1, this.acceptsNav, this);
            }else {
                R = g.walkCells(ed.row, ed.col+1, 1, this.acceptsNav, this);
            }

            e.stopEvent();
        }else  if(k == e.ENTER && !e.ctrlKey){
            ed.completeEdit();
            e.stopEvent();
        }else  if(k == e.ESC){
            ed.cancelEdit();
        }
        if(R){
            g.startEditing(R[0], R[1]);
        }
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.grid.EditorGrid
 * @extends Roo.grid.Grid
 * Class for creating and editable grid.
 * @param {String/HTMLElement/Roo.Element} container The element into which this grid will be rendered - 
 * The container MUST have some type of size defined for the grid to fill. The container will be 
 * automatically set to position relative if it isn't already.
 * @param {Object} dataSource The data model to bind to
 * @param {Object} colModel The column model with info about this grid's columns
 */
Roo.grid.EditorGrid = function(A, B){
    Roo.grid.EditorGrid.superclass.constructor.call(this, A, B);
    this.getGridEl().addClass("xedit-grid");

    if(!this.selModel){
        this.selModel = new  Roo.grid.CellSelectionModel();
    }


    this.activeEditor = null;

	this.addEvents({
	    /**
	     * @event beforeedit
	     * Fires before cell editing is triggered. The edit event object has the following properties <br />
	     * <ul style="padding:5px;padding-left:16px;">
	     * <li>grid - This grid</li>
	     * <li>record - The record being edited</li>
	     * <li>field - The field name being edited</li>
	     * <li>value - The value for the field being edited.</li>
	     * <li>row - The grid row index</li>
	     * <li>column - The grid column index</li>
	     * <li>cancel - Set this to true to cancel the edit or return false from your handler.</li>
	     * </ul>
	     * @param {Object} e An edit event (see above for description)
	     */
	    "beforeedit" : true,
	    /**
	     * @event afteredit
	     * Fires after a cell is edited. <br />
	     * <ul style="padding:5px;padding-left:16px;">
	     * <li>grid - This grid</li>
	     * <li>record - The record being edited</li>
	     * <li>field - The field name being edited</li>
	     * <li>value - The value being set</li>
	     * <li>originalValue - The original value for the field, before the edit.</li>
	     * <li>row - The grid row index</li>
	     * <li>column - The grid column index</li>
	     * </ul>
	     * @param {Object} e An edit event (see above for description)
	     */
	    "afteredit" : true,
	    /**
	     * @event validateedit
	     * Fires after a cell is edited, but before the value is set in the record. 
         * You can use this to modify the value being set in the field, Return false
	     * to cancel the change. The edit event object has the following properties <br />
	     * <ul style="padding:5px;padding-left:16px;">
         * <li>editor - This editor</li>
	     * <li>grid - This grid</li>
	     * <li>record - The record being edited</li>
	     * <li>field - The field name being edited</li>
	     * <li>value - The value being set</li>
	     * <li>originalValue - The original value for the field, before the edit.</li>
	     * <li>row - The grid row index</li>
	     * <li>column - The grid column index</li>
	     * <li>cancel - Set this to true to cancel the edit or return false from your handler.</li>
	     * </ul>
	     * @param {Object} e An edit event (see above for description)
	     */
	    "validateedit" : true
	});
    this.on("bodyscroll", this.stopEditing,  this);
    this.on(this.clicksToEdit == 1 ? "cellclick" : "celldblclick", this.onCellDblClick,  this);
};

Roo.extend(Roo.grid.EditorGrid, Roo.grid.Grid, {
    /**
     * @cfg {Number} clicksToEdit
     * The number of clicks on a cell required to display the cell's editor (defaults to 2)
     */
    clicksToEdit: 2,

    // private
    isEditor : true,
    // private
    trackMouseOver: false, // causes very odd FF errors

    onCellDblClick : function(g, C, D){
        this.startEditing(C, D);
    },

    onEditComplete : function(ed, E, F){
        this.editing = false;
        this.activeEditor = null;
        ed.un("specialkey", this.selModel.onEditorKey, this.selModel);
        var  r = ed.record;
        var  G = this.colModel.getDataIndex(ed.col);
        var  e = {
            grid: this,
            record: r,
            field: G,
            originalValue: F,
            value: E,
            row: ed.row,
            column: ed.col,
            cancel:false,
            editor: ed
        };
        if(String(E) !== String(F)){
            
            if(this.fireEvent("validateedit", e) !== false && !e.cancel){
                r.set(G, e.value);
                delete  e.cancel; //?? why!!!
                this.fireEvent("afteredit", e);
            }
        } else  {
            this.fireEvent("afteredit", e); // always fir it!
        }

        this.view.focusCell(ed.row, ed.col);
    },

    /**
     * Starts editing the specified for the specified row/column
     * @param {Number} rowIndex
     * @param {Number} colIndex
     */
    startEditing : function(H, I){
        this.stopEditing();
        if(this.colModel.isCellEditable(I, H)){
            this.view.ensureVisible(H, I, true);
            var  r = this.dataSource.getAt(H);
            var  G = this.colModel.getDataIndex(I);
            var  e = {
                grid: this,
                record: r,
                field: G,
                value: r.data[G],
                row: H,
                column: I,
                cancel:false
            };
            if(this.fireEvent("beforeedit", e) !== false && !e.cancel){
                this.editing = true;
                var  ed = this.colModel.getCellEditor(I, H);
                if (!ed) {
                    return;
                }
                if(!ed.rendered){
                    ed.render(ed.parentEl || document.body);
                }
                (function(){ // complex but required for focus issues in safari, ie and opera
                    ed.row = H;
                    ed.col = I;
                    ed.record = r;
                    ed.on("complete", this.onEditComplete, this, {single: true});
                    ed.on("specialkey", this.selModel.onEditorKey, this.selModel);
                    this.activeEditor = ed;
                    var  v = r.data[G];
                    ed.startEdit(this.view.getCell(H, I), v);
                }).defer(50, this);
            }
        }
    },
        
    /**
     * Stops any active editing
     */
    stopEditing : function(){
        if(this.activeEditor){
            this.activeEditor.completeEdit();
        }

        this.activeEditor = null;
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */

// private - not really -- you end up using it !
// This is a support class used internally by the Grid components

/**
 * @class Roo.grid.GridEditor
 * @extends Roo.Editor
 * Class for creating and editable grid elements.
 * @param {Object} config any settings (must include field)
 */
Roo.grid.GridEditor = function(A, B){
    if (!B && A.field) {
        B = A;
        A = Roo.factory(B.field, Roo.form);
    }

    Roo.grid.GridEditor.superclass.constructor.call(this, A, B);
    A.monitorTab = false;
};

Roo.extend(Roo.grid.GridEditor, Roo.Editor, {
    
    /**
     * @cfg {Roo.form.Field} field Field to wrap (or xtyped)
     */
    
    alignment: "tl-tl",
    autoSize: "width",
    hideEl : false,
    cls: "x-small-editor x-grid-editor",
    shim:false,
    shadow:"frame"
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
  

  
Roo.grid.PropertyRecord = Roo.data.Record.create([
    {name:'name',type:'string'},  'value'
]);


Roo.grid.PropertyStore = function(A, B){
    this.grid = A;
    this.store = new  Roo.data.Store({
        recordType : Roo.grid.PropertyRecord
    });
    this.store.on('update', this.onUpdate,  this);
    if(B){
        this.setSource(B);
    }

    Roo.grid.PropertyStore.superclass.constructor.call(this);
};



Roo.extend(Roo.grid.PropertyStore, Roo.util.Observable, {
    setSource : function(o){
        this.source = o;
        this.store.removeAll();
        var  C = [];
        for(var  k  in  o){
            if(this.isEditableValue(o[k])){
                C.push(new  Roo.grid.PropertyRecord({name: k, value: o[k]}, k));
            }
        }

        this.store.loadRecords({records: C}, {}, true);
    },

    onUpdate : function(ds, D, E){
        if(E == Roo.data.Record.EDIT){
            var  v = D.data['value'];
            var  oldValue = D.modified['value'];
            if(this.grid.fireEvent('beforepropertychange', this.source, D.id, v, oldValue) !== false){
                this.source[D.id] = v;
                D.commit();
                this.grid.fireEvent('propertychange', this.source, D.id, v, oldValue);
            }else {
                D.reject();
            }
        }
    },

    getProperty : function(F){
       return  this.store.getAt(F);
    },

    isEditableValue: function(G){
        if(G && G  instanceof  Date){
            return  true;
        }else  if(typeof  G == 'object' || typeof  G == 'function'){
            return  false;
        }
        return  true;
    },

    setValue : function(H, I){
        this.source[H] = I;
        this.store.getById(H).set('value', I);
    },

    getSource : function(){
        return  this.source;
    }
});

Roo.grid.PropertyColumnModel = function(J, K){
    this.grid = J;
    var  g = Roo.grid;
    g.PropertyColumnModel.superclass.constructor.call(this, [
        {header: this.nameText, sortable: true, dataIndex:'name', id: 'name'},
        {header: this.valueText, resizable:false, dataIndex: 'value', id: 'value'}
    ]);
    this.store = K;
    this.bselect = Roo.DomHelper.append(document.body, {
        tag: 'select', style:'display:none', cls: 'x-grid-editor', children: [
            {tag: 'option', value: 'true', html: 'true'},
            {tag: 'option', value: 'false', html: 'false'}
        ]
    });
    Roo.id(this.bselect);
    var  f = Roo.form;
    this.editors = {
        'date' : new  g.GridEditor(new  f.DateField({selectOnFocus:true})),
        'string' : new  g.GridEditor(new  f.TextField({selectOnFocus:true})),
        'number' : new  g.GridEditor(new  f.NumberField({selectOnFocus:true, style:'text-align:left;'})),
        'int' : new  g.GridEditor(new  f.NumberField({selectOnFocus:true, allowDecimals:false, style:'text-align:left;'})),
        'boolean' : new  g.GridEditor(new  f.Field({el:this.bselect,selectOnFocus:true}))
    };
    this.renderCellDelegate = this.renderCell.createDelegate(this);
    this.renderPropDelegate = this.renderProp.createDelegate(this);
};

Roo.extend(Roo.grid.PropertyColumnModel, Roo.grid.ColumnModel, {
    
    
    nameText : 'Name',
    valueText : 'Value',
    
    dateFormat : 'm/j/Y',
    
    
    renderDate : function(L){
        return  L.dateFormat(this.dateFormat);
    },

    renderBool : function(M){
        return  M ? 'true' : 'false';
    },

    isCellEditable : function(N, O){
        return  N == 1;
    },

    getRenderer : function(P){
        return  P == 1 ?
            this.renderCellDelegate : this.renderPropDelegate;
    },

    renderProp : function(v){
        return  this.getPropertyName(v);
    },

    renderCell : function(Q){
        var  rv = Q;
        if(Q  instanceof  Date){
            rv = this.renderDate(Q);
        }else  if(typeof  Q == 'boolean'){
            rv = this.renderBool(Q);
        }
        return  Roo.util.Format.htmlEncode(rv);
    },

    getPropertyName : function(R){
        var  pn = this.grid.propertyNames;
        return  pn && pn[R] ? pn[R] : R;
    },

    getCellEditor : function(S, T){
        var  p = this.store.getProperty(T);
        var  n = p.data['name'], U = p.data['value'];
        
        if(typeof(this.grid.customEditors[n]) == 'string'){
            return  this.editors[this.grid.customEditors[n]];
        }
        if(typeof(this.grid.customEditors[n]) != 'undefined'){
            return  this.grid.customEditors[n];
        }
        if(U  instanceof  Date){
            return  this.editors['date'];
        }else  if(typeof  U == 'number'){
            return  this.editors['number'];
        }else  if(typeof  U == 'boolean'){
            return  this.editors['boolean'];
        }else {
            return  this.editors['string'];
        }
    }
});

/**
 * @class Roo.grid.PropertyGrid
 * @extends Roo.grid.EditorGrid
 * This class represents the  interface of a component based property grid control.
 * <br><br>Usage:<pre><code>
 var grid = new Roo.grid.PropertyGrid("my-container-id", {
      
 });
 // set any options
 grid.render();
 * </code></pre>
  
 * @constructor
 * @param {String/HTMLElement/Roo.Element} container The element into which this grid will be rendered -
 * The container MUST have some type of size defined for the grid to fill. The container will be
 * automatically set to position relative if it isn't already.
 * @param {Object} config A config object that sets properties on this grid.
 */
Roo.grid.PropertyGrid = function(V, W){
    W = W || {};
    var  X = new  Roo.grid.PropertyStore(this);
    this.store = X;
    var  cm = new  Roo.grid.PropertyColumnModel(this, X);
    X.store.sort('name', 'ASC');
    Roo.grid.PropertyGrid.superclass.constructor.call(this, V, Roo.apply({
        ds: X.store,
        cm: cm,
        enableColLock:false,
        enableColumnMove:false,
        stripeRows:false,
        trackMouseOver: false,
        clicksToEdit:1
    }, W));
    this.getGridEl().addClass('x-props-grid');
    this.lastEditRow = null;
    this.on('columnresize', this.onColumnResize, this);
    this.addEvents({
         /**
	     * @event beforepropertychange
	     * Fires before a property changes (return false to stop?)
	     * @param {Roo.grid.PropertyGrid} grid property grid? (check could be store)
	     * @param {String} id Record Id
	     * @param {String} newval New Value
         * @param {String} oldval Old Value
	     */
        "beforepropertychange": true,
        /**
	     * @event propertychange
	     * Fires after a property changes
	     * @param {Roo.grid.PropertyGrid} grid property grid? (check could be store)
	     * @param {String} id Record Id
	     * @param {String} newval New Value
         * @param {String} oldval Old Value
	     */
        "propertychange": true
    });
    this.customEditors = this.customEditors || {};
};
Roo.extend(Roo.grid.PropertyGrid, Roo.grid.EditorGrid, {
    
     /**
     * @cfg {Object} customEditors map of colnames=> custom editors.
     * the custom editor can be one of the standard ones (date|string|number|int|boolean), or a
     * grid editor eg. Roo.grid.GridEditor(new Roo.form.TextArea({selectOnFocus:true})),
     * false disables editing of the field.
	 */
    
      /**
     * @cfg {Object} propertyNames map of property Names to their displayed value
	 */
    
    render : function(){
        Roo.grid.PropertyGrid.superclass.render.call(this);
        this.autoSize.defer(100, this);
    },

    autoSize : function(){
        Roo.grid.PropertyGrid.superclass.autoSize.call(this);
        if(this.view){
            this.view.fitColumns();
        }
    },

    onColumnResize : function(){
        this.colModel.setColumnWidth(1, this.container.getWidth(true)-this.colModel.getColumnWidth(0));
        this.autoSize();
    },
    /**
     * Sets the data for the Grid
     * accepts a Key => Value object of all the elements avaiable.
     * @param {Object} data  to appear in grid.
     */
    setSource : function(Y){
        this.store.setSource(Y);
        //this.autoSize();
    },
    /**
     * Gets all the data from the grid.
     * @return {Object} data  data stored in grid
     */
    getSource : function(){
        return  this.store.getSource();
    }
});
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
 
/**
 * @class Roo.LoadMask
 * A simple utility class for generically masking elements while loading data.  If the element being masked has
 * an underlying {@link Roo.data.Store}, the masking will be automatically synchronized with the store's loading
 * process and the mask element will be cached for reuse.  For all other elements, this mask will replace the
 * element's UpdateManager load indicator and will be destroyed after the initial load.
 * @constructor
 * Create a new LoadMask
 * @param {String/HTMLElement/Roo.Element} el The element or DOM node, or its id
 * @param {Object} config The config object
 */
Roo.LoadMask = function(el, A){
    this.el = Roo.get(el);
    Roo.apply(this, A);
    if(this.store){
        this.store.on('beforeload', this.onBeforeLoad, this);
        this.store.on('load', this.onLoad, this);
        this.store.on('loadexception', this.onLoad, this);
        this.removeMask = false;
    }else {
        var  um = this.el.getUpdateManager();
        um.showLoadIndicator = false; // disable the default indicator
        um.on('beforeupdate', this.onBeforeLoad, this);
        um.on('update', this.onLoad, this);
        um.on('failure', this.onLoad, this);
        this.removeMask = true;
    }
};

Roo.LoadMask.prototype = {
    /**
     * @cfg {Boolean} removeMask
     * True to create a single-use mask that is automatically destroyed after loading (useful for page loads),
     * False to persist the mask element reference for multiple uses (e.g., for paged data widgets).  Defaults to false.
     */
    /**
     * @cfg {String} msg
     * The text to display in a centered loading message box (defaults to 'Loading...')
     */
    msg : 'Loading...',
    /**
     * @cfg {String} msgCls
     * The CSS class to apply to the loading message element (defaults to "x-mask-loading")
     */
    msgCls : 'x-mask-loading',

    /**
     * Read-only. True if the mask is currently disabled so that it will not be displayed (defaults to false)
     * @type Boolean
     */
    disabled: false,

    /**
     * Disables the mask to prevent it from being displayed
     */
    disable : function(){
       this.disabled = true;
    },

    /**
     * Enables the mask so that it can be displayed
     */
    enable : function(){
        this.disabled = false;
    },

    // private
    onLoad : function(){
        this.el.unmask(this.removeMask);
    },

    // private
    onBeforeLoad : function(){
        if(!this.disabled){
            this.el.mask(this.msg, this.msgCls);
        }
    },

    // private
    destroy : function(){
        if(this.store){
            this.store.un('beforeload', this.onBeforeLoad, this);
            this.store.un('load', this.onLoad, this);
            this.store.un('loadexception', this.onLoad, this);
        }else {
            var  um = this.el.getUpdateManager();
            um.un('beforeupdate', this.onBeforeLoad, this);
            um.un('update', this.onLoad, this);
            um.un('failure', this.onLoad, this);
        }
    }
};
/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */
Roo.XTemplate = function(){
    Roo.XTemplate.superclass.constructor.apply(this, arguments);
    var  s = this.html;

    s = ['<tpl>', s, '</tpl>'].join('');

    var  re = /<tpl\b[^>]*>((?:(?=([^<]+))\2|<(?!tpl\b[^>]*>))*?)<\/tpl>/;

    var  A = /^<tpl\b[^>]*?for="(.*?)"/;
    var  B = /^<tpl\b[^>]*?if="(.*?)"/;
    var  C = /^<tpl\b[^>]*?exec="(.*?)"/;
    var  m, id = 0;
    var  D = [];

    while(m = s.match(re)){
       var  m2 = m[0].match(A);
       var  m3 = m[0].match(B);
       var  m4 = m[0].match(C);
       var  exp = null, fn = null, exec = null;
       var  name = m2 && m2[1] ? m2[1] : '';
       if(m3){
           exp = m3 && m3[1] ? m3[1] : null;
           if(exp){
               fn = new  Function('values', 'parent', 'with(values){ return '+(Roo.util.Format.htmlDecode(exp))+'; }');
           }
       }
       if(m4){
           exp = m4 && m4[1] ? m4[1] : null;
           if(exp){
               exec = new  Function('values', 'parent', 'with(values){ '+(Roo.util.Format.htmlDecode(exp))+'; }');
           }
       }
       if(name){
           switch(name){
               case  '.': name = new  Function('values', 'parent', 'with(values){ return values; }'); break;
               case  '..': name = new  Function('values', 'parent', 'with(values){ return parent; }'); break;
               default: name = new  Function('values', 'parent', 'with(values){ return '+name+'; }');
           }
       }

       D.push({
            id: id,
            target: name,
            exec: exec,
            test: fn,
            body: m[1]||''
        });
       s = s.replace(m[0], '{xtpl'+ id + '}');
       ++id;
    }
    for(var  i = D.length-1; i >= 0; --i){
        this.compileTpl(D[i]);
    }

    this.master = D[D.length-1];
    this.tpls = D;
};
Roo.extend(Roo.XTemplate, Roo.Template, {

    re : /\{([\w-\.]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,

    applySubTemplate : function(id, E, F){
        var  t = this.tpls[id];
        if(t.test && !t.test.call(this, E, F)){
            return  '';
        }
        if(t.exec && t.exec.call(this, E, F)){
            return  '';
        }
        var  vs = t.target ? t.target.call(this, E, F) : E;
        F = t.target ? E : F;
        if(t.target && vs  instanceof  Array){
            var  buf = [];
            for(var  i = 0, len = vs.length; i < len; i++){
                buf[buf.length] = t.compiled.call(this, vs[i], F);
            }
            return  buf.join('');
        }
        return  t.compiled.call(this, vs, F);
    },

    compileTpl : function(G){
        var  fm = Roo.util.Format;
        var  H = this.disableFormats !== true;
        var  I = Roo.isGecko ? "+" : ",";
        var  fn = function(m, K, L, M){
            if(K.substr(0, 4) == 'xtpl'){
                return  "'"+ I +'this.applySubTemplate('+K.substr(4)+', values, parent)'+I+"'";
            }
            var  v;
            if(K.indexOf('.') != -1){
                v = K;
            }else {
                v = "values['" + K + "']";
            }
            if(L && H){
                M = M ? ',' + M : "";
                if(L.substr(0, 5) != "this."){
                    L = "fm." + L + '(';
                }else {
                    L = 'this.call("'+ L.substr(5) + '", ';
                    M = ", values";
                }
            }else {
                M= ''; L = "("+v+" === undefined ? '' : ";
            }
            return  "'"+ I + L + v + M + ")"+I+"'";
        };
        var  J;
        // branched to use + in gecko and [].join() in others
        if(Roo.isGecko){
            J = "tpl.compiled = function(values, parent){ return '" +
                   G.body.replace(/(\r\n|\n)/g, '\\n').replace(/'/g, "\\'").replace(this.re, fn) +
                    "';};";
        }else {
            J = ["tpl.compiled = function(values, parent){ return ['"];
            J.push(G.body.replace(/(\r\n|\n)/g, '\\n').replace(/'/g, "\\'").replace(this.re, fn));
            J.push("'].join('');};");
            J = J.join('');
        }

        /** eval:var:zzzzzzz */
        eval(J);
        return  this;
    },

    applyTemplate : function(K){
        return  this.master.compiled.call(this, K, {});
        var  s = this.subs;
    },

    apply : function(){
        return  this.applyTemplate.apply(this, arguments);
    },

    compile : function(){return  this;}
});

Roo.XTemplate.from = function(el){
    el = Roo.getDom(el);
    return  new  Roo.XTemplate(el.value || el.innerHTML);
};
